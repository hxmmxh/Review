
# 目录
* [数据结构](#数据结构)
* [算法](#算法)
------------------------------------------
# 数据结构

## 二叉查找树
* 若它的左子树不空，则左子树上的关键字的值均小于根关键字的值。
* 若它的右子树不空，则右子树上的关键字的值均大于根关键字的值。
* 左右子树又各是一棵二叉查找树

## AVL树
* 为了避免树的高度增长过快，降低二叉排序树的性能，规定在插入和删除二叉树节点时，要保证任意节点的左、右子树高度差的绝对值不超过1，就将这样的二叉树称为平衡二叉树。

## 红黑树
* 节点是要么红色或要么是黑色。
* 根一定是黑色节点。
* 每个叶子结点都带有两个空的黑色结点（称之为NIL节点，它又被称为黑哨兵）。
* 每个红色节点的两个子节点都是黑色（或者说从每个叶子到根的所有路径上不能有两个连续的红色节点）。
* 从任一节点到它所能到达得叶子节点的所有简单路径都包含相同数目的黑色节点。

保证了根节点到任意叶子节点的路径长度，最多相差一半（因为路径上的黑色节点相等，差别只是不能相邻的红色节点个数），所以红黑树是一个基本平衡的二叉搜索树，它没有AVL树那么绝对平衡，但是同样的关键字组成的红黑树相比AVL旋转操作要少，而且删除操作也比AVL树效率更高，实际应用效果也比AVL树更出众。

## 哈希表
* 概念
    * 通过关键码值(Key value)而直接进行访问的数据结构。
    * 通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。

* 常见哈希函数
    1.直接定址法
        * 取关键字的某个线性函数为散列地址：Hash（Key）= A*Key + B
        * 优点：简单、均匀
        * 缺点：需要事先知道关键字的分布情况
        * 适合查找比较小且连续的情况
    2.除留余数法
        * 设散列表中允许的地址数为m，取一个不大于m，但最接近或者等于m的质数p作为除数，按照哈希函数：Hash(key) = key% p(p<=m),将关键码转换成哈希地址
    3.平方取中法
        * 假设关键字为1234，对它平方就是1522756，抽取中间的3位227作为哈希地址；
        * 再比如关键字为4321，对它平方就是18671041，抽取中间的3位671(或710)作为哈希地址
        * 平方取中法比较适合：不知道关键字的分布，而位数又不是很大的情况
    4.折叠法
        * 折叠法是将关键字从左到右分割成位数相等的几部分(最后一部分位数可以短些)，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址折叠法适合事先不需要知道关键字的分布，适合关键字位数比较多的情况
    5.随机数法
        * 选择一个随机函数，取关键字的随机函数值为它的哈希地址，即H(key) = random(key),其中random为随机数函数通常应用于关键字长度不等时采用此法

* 哈希冲突的解决方法
    1. 开发地址法 
        * 线性探测再散列
        * 平方探测再散列
        * 随机探测在散列（双探测再散列）
    2. 链地址法
        产生hash冲突后在存储数据后面加一个指针，指向后面冲突的数据
    3. 公共溢出区法
        建立一个特殊存储空间，专门存放冲突的数据。此种方法适用于数据和冲突较少的情况。
    4.再散列法
        准备若干个hash函数，如果使用第一个hash函数发生了冲突，就使用第二个hash函数，第二个也冲突，使用第三个……



















--------------------------------------------------
## 海量数据处理
[十道海量数据处理面试题与十个方法大总结](https://blog.csdn.net/v_JULY_v/article/details/6279498)
[教你如何迅速秒杀掉：99%的海量数据处理面试题](https://blog.csdn.net/v_july_v/article/details/7382693)

## 位运算



## 动态规划
### 01背包问题
[参考资料](https://blog.csdn.net/qq_36303472/article/details/68935954)
[参考资料](https://blog.csdn.net/qq_38410730/article/details/81667885)