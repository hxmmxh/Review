
- [分类](#分类)
- [比较排序](#比较排序)
  - [1.插入排序](#1插入排序)
  - [2.冒泡排序](#2冒泡排序)
  - [3.选择排序](#3选择排序)
  - [4.shell排序](#4shell排序)
  - [5.归并排序](#5归并排序)
  - [6.快速排序](#6快速排序)
  - [7.堆排序](#7堆排序)
- [非比较排序](#非比较排序)
  - [1. 计数排序](#1-计数排序)
  - [2. 桶排序](#2-桶排序)
  - [3. 基数排序](#3-基数排序)
- [外部排序](#外部排序)
  - [1.多路归并](#1多路归并)
    - [k的选择](#k的选择)
    - [优化](#优化)

# 分类

- 是否通过比较来进行排序
  - 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。
    - 有七种：选择，插入，冒泡，希尔，快速，归并，堆
  - 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序
    - 有三种：计数，桶，基数排序
- 稳定性
  - 相同的元素在排序前和排序后的前后位置是否发生改变，没有改变则排序是稳定的，改变则排序是不稳定的
  - 不稳定：选择排序、快速排序、希尔排序、堆排序   
  - 稳定：冒泡排序、插入排序、归并排序，三种非比较的排序
- 是否需要额外空间
  - 需要：快速，归并，三种非比较排序
  - 不需要：插入，选择，冒泡，希尔，堆
   
# 比较排序

## 1.插入排序

- 最佳：升序。时间复杂度为O(n)
- 最差：降序。时间复杂度为O(n^2)
- 平均：对于每个元素，前面有一半元素比它大。时间复杂度为O(n^2)


## 2.冒泡排序

- 从数组的底部比较到顶部，比较相邻元素。如果下面的元素更小则交换，否则，上面的元素继续往上比较。这个过程每次使最小元素像个“气泡”似地被推到数组的顶部
- 冒泡排序是一种相对较慢的排序，没有较好的最佳情况执行时间。通常情况下时间复杂度都是O(n^2)
- 优化：
  - 增加一个变量flag，用于记录一次循环是否发生了交换，如果没发生交换说明已经有序，可以提前结束
  - 优化后时间复杂度最好为O(n)

## 3.选择排序

- 第i次“选择”数组中第i小的记录，并将该记录放到数组的第i个位置。换句话说，每次从未排序的序列中找到最小元素，放到未排序数组的最前面
- 不管数组是否有序，在从未排序的序列中查找最小元素时，都需要遍历完最小序列，所以时间复杂度为O(n^2)

## 4.shell排序

- 是简单插入排序的改进版
- 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：
  - 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
  - 按增量序列个数k，对序列进行k 趟排序；
  - 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。
- 一般来说，增量每次除以2时并没有多大效果，而“增量每次除以3”时效果更好
- 当选择“增量每次除以3”递减时，Shell排序的平均运行时间是O(n^(1.5))

## 5.归并排序

- 将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表
- 步骤
  - 把长度为n的输入序列分成两个长度为n/2的子序列；
  - 对这两个子序列分别采用归并排序；
  - 将两个排序好的子序列合并成一个最终的排序序列
- 始终都是O(nlogn）的时间复杂度
- 空间复杂度为O(n)
- 也可以实现自底向上的空间复杂度为O(1)的算法

## 6.快速排序

- 通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。
- 步骤
  - 从数列中挑出一个元素，称为 “基准”（pivot）；
  - 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
  - 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。
- 最佳情况：O(nlogn),平均情况：O(nlogn),最差情况：每次处理将所有元素划分到轴值一侧，O(n^2)
- 空间复杂度为O(nlogn)
- **快速排序是所有内部排序算法中平均性能最优的排序算法**
- 优化
  - 最明显的改进之处是轴值的选取，如果轴值选取合适，每次处理可以将元素较均匀的划分到轴值两侧：
    - **三者取中法**：三个随机值的中间一个。为了减少随机数生成器产生的延迟，可以选取首中尾三个元素作为随机值
    - 当n很小时，快速排序会很慢。因此当子数组小于某个长度（经验值：9）时，什么也不要做。此时数组已经基本有序，最后调用一次插入排序完成最后处理

## 7.堆排序

- 步骤
  - 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；
  - 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]；
  - 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。
- 平均时间复杂度为O(nlogn)


# 非比较排序

## 1. 计数排序

- 计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 
- 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。
- 步骤
  - 找出待排序的数组中最大和最小的元素；
  - 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；
  - 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；
  - 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。
- 当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法
- 当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。

## 2. 桶排序

- 计数排序的升级版
- 假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）
- 步骤
  - 设置一个定量的数组当作空桶；
  - 遍历输入数据，并且把数据一个一个放到对应的桶里去；
  - 对每个不是空的桶进行排序；
  - 从不是空的桶里把排好序的数据拼接起来
- 桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大

## 3. 基数排序
- 按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位



# 外部排序

## 1.多路归并

多路归并是**外部排序最常用**的算法：**将原文件分解成多个能够一次性装入内存的部分，分别把每一部分调入内存完成排序。然后，对已经排序的子文件进行归并排序**

![](../pic/al-kmerge.png)

### k的选择

假设总共m个子文件，每次归并k个子文件，那么一共需要归并 ![](http://latex.codecogs.com/gif.latex?\\\\$$log_km$) 次（扫描磁盘），在k个元素中找出最小值（或最大值）需要比较k-1次。如果总记录数为N，所以时间复杂度就是 ![](http://latex.codecogs.com/gif.latex?\\\\$$(k-1)Nlog_km=\frac{(k-1)}{logk}Nlogm$)， 由于 ![](http://latex.codecogs.com/gif.latex?\\\\$$\frac{(k-1)}{logk}$) 随k的增大而增大，所以比较次数的增加会逐步抵消“低扫描次数”带来的性能增益，所以对于k值的选择，主要涉及两个问题：

1. **每一轮归并会将结果写回到磁盘，那么k越小，磁盘与内存之间数据的传输就会越多，增大k可以较少扫描次数**
2. **k个元素中选取最小的元素需要比较k-1次，如果k越大，比较的次数就会越大**

### 优化

可以利用下列方法**减少比较次数**：

1. **败者树**
2. **建堆**：使用一个k个元素的数组，第一次将k个文件中最小的元素读入数组（并且记录每个元素来自哪个文件），然后建最小堆，将堆顶元素删除，并从堆顶元素的源文件中取出下一个数，插入堆中，调整后重复上述操作。虽然第一次需要遍历k个文件取出最小元素，加上建堆需要一定时间，但是后续操作可以很快完成
