- [卡特兰数](#卡特兰数)
- [完全二叉树和满二叉树](#完全二叉树和满二叉树)
- [二叉查找树](#二叉查找树)
- [平衡查找树(AVL树)](#平衡查找树avl树)
- [红黑树](#红黑树)
  - [定义](#定义)
  - [优点](#优点)
  - [旋转](#旋转)
  - [和AVL树的对比](#和avl树的对比)
- [2-3查找树](#2-3查找树)
  - [定义](#定义-1)
  - [插入](#插入)
    - [查找](#查找)
- [B树，B+树，B*树](#b树b树b树)
  - [B树](#b树)
    - [定义](#定义-2)
    - [B树中检索关键码](#b树中检索关键码)
    - [B树中插入关键码](#b树中插入关键码)
    - [特性](#特性)
    - [优点](#优点-1)
  - [B+树](#b树-1)
    - [定义](#定义-3)
    - [搜索](#搜索)
    - [插入](#插入-1)
    - [删除](#删除)
    - [特性](#特性-1)
    - [优点](#优点-2)
  - [B*树](#b树-2)
    - [定义](#定义-4)
    - [插入](#插入-2)
    - [和B+树的区别](#和b树的区别)
  - [总结](#总结)

# 卡特兰数

- `C(n,2n)/(n+1)`
- 用途
  - n个结点构成的不同二叉树个数
  - n个不同元素进栈，出栈序列的个数
- 以序列 a,b,c,d 为入栈次序，则出栈序列的个数为？ `（8*7*6*5)/(4*3*2*1)/5=14`
- 先序序列为a,b,c,d 的不同二叉树的个数是,也是14


# 完全二叉树和满二叉树

- 完全二叉树，除最后一层可能不满以外，其他各层都达到该层节点的最大数，最后一层如果不满，该层所有节点都全部靠左排
  - 堆是一个完全二叉树
- 满二叉树，所有层的节点数都达到最大 

# 二叉查找树
- 若它的左子树不空，则左子树上的关键字的值均小于根关键字的值。
- 若它的右子树不空，则右子树上的关键字的值均大于根关键字的值。
- 左右子树又各是一棵二叉查找树

# 平衡查找树(AVL树)
- 为了避免树的高度增长过快，降低二叉排序树的性能，规定在插入和删除二叉树节点时，要保证任意节点的左、右子树高度差的绝对值不超过1，就将这样的二叉树称为平衡二叉树。

# 红黑树

## 定义
- 节点是要么红色或要么是黑色。
- 根一定是黑色节点。
- 每个红色节点的两个子节点都是黑色（或者说从每个叶子到根的所有路径上不能有两个连续的红色节点）。
- 每个叶子结点都带有两个空的黑色结点（称之为NIL节点，它又被称为黑哨兵）。）
- 从任一节点到它所能到达得叶子节点的所有简单路径都包含相同数目的黑色节点。

## 优点
- 保证了根节点到任意叶子节点的路径长度，最多相差一半（因为路径上的黑色节点相等，差别只是不能相邻的红色节点个数），所以红黑树是一个基本平衡的二叉搜索树，它没有AVL树那么绝对平衡，但是同样的关键字组成的红黑树相比AVL旋转操作要少，而且删除操作也比AVL树效率更高，实际应用效果也比AVL树更出众。
- 可以在O(log n)时间内做查找，插入和删除
- 恢复红黑属性需要少量(O(log n))的颜色变更(这在实践中是非常快速的)并且不超过三次树旋转(对于插入是两次)
- 插入最多两次旋转，删除最多三次旋转

## 旋转

- 根据规则，新增节点必须为红，新增节点的父节点必须为黑，如果没有满足这个条件，就要进行旋转


## 和AVL树的对比

- 红黑树在查找，插入删除的性能都是O(logn)，且性能稳定
- AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。


# 2-3查找树

## 定义
- 一棵2-3查找树或为一棵空树，或由以下节点组成：
  - **2-节点**：含有1个键（及其对应的值）和2条链接，左链接指向的2-3树中的键都小于该节点，右链接指向的2-3树中的键都大于该节点
  - **3-节点**：含有2个键（及其对应的值）和3条链接，左链接指向的2-3树中的键都小于该节点，中链接指向的2-3树中的键都位于该节点的两个键之间，右链接指向的2-3树中的键都大于该节点

## 插入
- 在插入和删除节点时也是需要动态维持平衡的，但维持平衡的策略和AVL树是不一样的。AVL树是通过旋转来恢复平衡的，而2-3树是通过节点分裂来维持的
- 如果插入位置是一个2节点的子节点，那么就把这个2节点变成一个3节点即可
- 向3-节点中插入新键
  - **整棵树只包含一个3-节点**（**情况一**）
  - **整棵树包含多个节点**
    - **3-节点的父节点为2-节点**（**情况二**）
    - **3-节点的父节点为3-节点**（**情况三**）
- **情况一**：
  - 先临时将新键存入该节点中，使之成为一个4-节点。
  - 然后将这个4-节点转换成一棵由3个2-节点组成的2-3树：其中一个节点(根)含有中键，一个节点含有3个键中的最小者(左子节点)，一个节点含有3个键中的最大者(右子节点)。
  - **很容易看出插入后的树依然是平衡的**
- **情况二**
  - 先构造一个临时的4-节点并将其分解，但此时不会像情况一一样为中键创建一个新节点，而是将其移动至原来的父节点中。可以将这次转换看成将原3-节点的一条链接替换为新父节点中的原中键左右两边的两条链接，并分别指向两个新的2-节点
- **情况三**
  - 和情况二一样，先构造一个临时的4-节点并分解，将它的中键插入到父节点中。但父节点也是一个3-节点，因此再用这个中键构造一个新的临时4-节点，然后在这个节点上进行相同的变换（即分解这个父节点并将它的中键插入到父节点中）。
  - 推广到一般情况，这样一直向上不断分解临时的4-节点并将中键插入更高层的父节点，直至遇到一个2-节点并将它替换为一个不需要继续分解的3-节点，或者是到达3-节点的根（这种情况下，按情况一进行处理，将临时的4-节点分解为3个2-节点，使得树高加一，因为变换的是根节点，所以**仍然保持树的完美平衡性**）


### 查找
- 查找效率与树的高度是息息相关的。
  - 在最坏的情况下，也就是所有的节点都是2-node节点，查找效率为lgN
  - 在最好的情况下，所有的节点都是3-node节点，查找效率为log3N约等于0.631lgN



# B树，B+树，B*树

## B树

- 一种多路平衡搜索树
- 能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除
- 为系统最优化大块数据的读和写操作。普遍运用在数据库和文件系统

### 定义

- 一个m阶B树有以下特性(m的值应大于2)
  - 孩子节点的数目
    - 任意非叶子结点最多只有m个孩子节点
    - 根至少有2个孩子节点，孩子节点数是`[2,m]`
    - 除了根节点外，每个内部节点有m/2(向上取整)到m个孩子节点，`[m/2,m]`
  - 所有叶子节点在树结构的同一层，因此树总是高度平衡的
  - 非叶子节点的关键字和指针的关系
    - 关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；
    - 指针：P[1], P[2], …, P[M]
    - P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树（开区间）

### B树中检索关键码

- 检索步骤
  - 在当前节点中对关键码进行二分查找
    - 如果找到检索的关键码：返回这条记录
    - 如果没找到，并且当节点是叶子节点：停止查找，报告检索失败
  - 沿着正确的分支继续查找
- 搜索性能等价于在关键字全集内做一次二分查找
  - 性能总是等价于二分查找
  - 时间复杂度为O(logN),N为关键字的总数

### B树中插入关键码

- B树节点插入是2-3树的推广。第一步是找到应当包含插入关键码的叶节点，并检查是否有空间。如果有，直接插入。如果没有，就把这个节点分裂成2个节点，并且把中间的关键码提升到父节点。如果父节点也满了，继续分裂，并再次提升
- 删除结点时，需将两个不足M/2的兄弟结点合并

### 特性

- 关键字集合分布在整颗树中，搜索有可能在非叶子结点结束
- 任何一个关键字出现且只出现在一个结点中
- 自动层次控制，自动维持树的平衡
- 搜索性能等价于在关键字全集内做一次二分查找

### 优点
- B树总是树高平衡的，所有的叶节点都在同一层
- 每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速
- 矮胖的，能减少磁盘或数据库中进行搜索的IO次数


## B+树

### 定义

- 是B-树的变体，也是一种多路搜索树
- 非叶子结点的子树指针与关键字个数相同
- 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（左闭右开）（B树是开区间）
- 所有关键字都在叶子结点出现，非叶结点仅具有索引作用
- 为所有叶子结点增加一个链指针
- 除了有一个指向根节点的头指针，B+树还有一个指向最小关键码的头指针（指向第一个叶子节点）
- 同一个数字会在不同节点中重复出现，根节点的最大元素就是b+树的最大元素

### 搜索

- 只有达到叶子结点才命中（B-树可以在非叶子结点命中）
- 其性能也等价于在关键字全集做一次二分查找；

### 插入

- 找到应当包含记录的**叶节点L**
    - 如果L没满：将新纪录添加进去
    - 如果L已满：
      - 分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针。
      - 这个提升过程可能会一直进行到根节点，引起根节点分裂，从而增加一层
      - 只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针

### 删除
- 删除之前，首先要找到包含要删除的记录R的**叶节点**：
- 如果叶节点超过半满：
  - 只需清除记录R，剩下的叶节点L仍然至少半满
- 如果叶节点没有半满，查看相邻的兄弟节点（节点下溢）：
    * 兄弟节点的记录很多：从兄弟节点获取元素，使两个节点有同样多的记录（这样做是为了尽可能延迟由于删除而引起的节点再次下溢）（**下图2**）
    * 如果没有一个兄弟节点可以把记录借出来，则将叶节点与一个兄弟节点合并（**下图3**）。可能会依次使父节点下溢，如果根节点的最后两个子女合并到一起，那么树就会减少一层

### 特性

- 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；
- 不可能在非叶子结点命中；
- 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；
- 更适合文件索引系统；
- 特别适合范围查询，一旦找到了范围内的第一条记录，通过顺序处理节点中的其余记录，然后继续下去，尽可能深入叶节点链表，就可以找到范围内的其余记录

### 优点

- B+树数据存放的更加紧密，具有更好的空间局部性。因此访问叶子节点上关联的数据也具有更好的缓存命中率。
- B+树的叶子结点都是相连的，因此对整棵树的遍历只需要一次线性遍历叶子结点即可。
- 而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好

## B*树

### 定义

- 是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针
- 非叶子结点关键字个数至少为(2/3)M，即块的最低使用率为2/3

### 插入
- 当一个结点满时
  - 如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）
  - 如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针

### 和B+树的区别

- 节点总是包含至少**三分之二**的记录
- 分裂、合并节点的规则不同

## 总结

- 二叉搜索树
  - 二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；
- B（B-）树
  - 多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；
  - 所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；
- B+树
  - 在B-树基础上，为叶子结点增加链表指针
  - 所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；
- B*树
  - 在B+树基础上，为非叶子结点也增加链表指针
  - 将结点的最低利用率从1/2提高到2/3；

1、B+树的层级更少：相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；
2、B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;
3、B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。
4、B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。

- B树相对于B+树的优点是，如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。