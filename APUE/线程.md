# 线程
- [线程](#线程)
  - [线程概念](#线程概念)
    - [线程标识](#线程标识)
    - [线程的创建和终止](#线程的创建和终止)
      - [创建线程](#创建线程)
      - [终止线程](#终止线程)
    - [线程同步](#线程同步)
      - [互斥量](#互斥量)
      - [读写锁](#读写锁)
      - [条件变量](#条件变量)
      - [自旋锁](#自旋锁)
      - [屏障](#屏障)

## 线程概念

* 多线程程序在单核处理器上运行也能改善响应时间和吞吐量

### 线程标识

- 进程ID在整个系统中是唯一的，但线程ID只有在它所属的进程上下文中才有意义
- 类型为pthread_t，是一个结构体，编写可移植的程序不能把它当作整数处理。  
- 但Linux系统中它的类型都是无符号长整型，用u打印。比较两个pthread_t是否相等时也能直接比较

```c
#include <pthread.h>
typedef unsigned long int pthread_t;
pthread_t pthread_self(void);//返回调用线程的线程ID
int pthread_equal(pthread_t tid1, pthread_t tid2);//比较是否相等
//相等返回非0，否则返回0
```

### 线程的创建和终止

#### 创建线程

- 在程序开始运行时，是以单进程中的单个控制线程启动

```c
#include <pthread.h>
int pthread_create(pthread_t *tidp,
                  const pthread_attr_t *attr,
                  void *(*start_rtn)(void*),
                  void *arg );
//成功返回0，失败返回错误码
```
- 线程ID会被设置成tidp指向的内存单元
- attr参数用于定制各种不同的线程属性，可用NULL表示一个具有默认属性的线程
- start_rtn是线程开始运行的函数地址，start_rtn的参数为arg。如果需要传递的参数有一个以上，需要把这个参数放在一个结构中，把结构的地址作为arg传入
- **线程创建时并不能保证是新创建的线程还是调用线程先运行**
- 新创建的线程会继承调用线程的浮点环境和信号屏蔽字，但会清除挂起信号集

#### 终止线程

- 退出整个进程的所有线程
- 
- 退出单个线程
  - 

### 线程同步

#### 互斥量

```c
#include <pthread.h>
#include <time.h>
int pthread_mutex_init(pthread_mutex_t * mutex, const pthread_mutexattr_t *attr);
int pthread_mutex_destory(pthread_mutex_t *mutex);
int pthread_mutex_lock(pthread_mutex_t * mutex);
int pthread_mutex_trylock(pthread_mutex_t * mutex); 
int pthread_mutex_timedlock(pthread_mutex_t *mutex, const struct timespec *tsptr);
int pthread_mutex_unlock(pthread_mutex_t * mutex);
//成功返回0，失败返回错误编号
```
- 初始化时把attr设为NULLb表示使用默认的属性，注意在释放内存前调用destory
- 如果使用静态的互斥量，可以直接把互斥量设为PTHREAD_MUTEX_INITIALIZER
- 调用lock时如果互斥量已经上锁，调用线程会阻塞直到互斥量被解锁
- 调用trylock时如果互斥量已经上锁，会失败，返回EBUSY
- 调用timedlock时如果互斥量已经上锁，会在等待一定时间后返回错误码ETIMEOUT。tpstr表示的是绝对时间，即等待tpstr时刻，而不是等待tpstr秒。












#### 读写锁

```c
#include <pthread.h>
int pthread_rwlock_init(pthread_rwlock_t * mrwlock, const pthread_rwlockattr_t * attr);
int pthread_rwlock_destory(pthread_rwlock_t * rwlock);
int pthread_rwlock_rdlock(pthread_rwlock_t * rwlock);//读模式锁定
int pthread_rwlock_wrlock(pthread_rwlock_t * rwlock);//写模式锁定
int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_timedwrlock(pthread_rwlock_t *rwlock,const struct timespec *tsptr);
int pthread_rwlock_timedrdlock(pthread_rwlock_t *rwlock,const struct timespec *tsptr);
int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
//成功返回0，失败返回错误编号

```
- 当读写锁处于读模式锁住的状态，而这时有一个线程试图以写模式获取锁时，读写锁通常会阻塞随后的读模式锁请求
- 静态PTHREAD_RWLOCK_INITIALIZER

#### 条件变量

```c
#include <pthread.h>
int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr);
int pthread_cond_destory(pthread_cond_t *cond);

```
- 静态PTHREAD_COND_INITIALIZER



在某下线程的实现中，会造成等待线程从内核中唤醒（由于cond_signal)然后又回到内核空间（因为cond_wait返回后会有原子加锁的 行为），所以一来一回会有性能的问题。详细来说就是，当一个等待线程被唤醒的时候，它必须首先加锁互斥量（参见pthread_cond_wait()执行步骤）。如果线程被唤醒而此时通知线程任然锁住互斥量，则被唤醒线程会立刻阻塞在互斥量上，等待通知线程解锁该互斥量，引起线程的上下文切换。当通知线程解锁后，被唤醒线程继续获得锁，再一次的引起上下文切换。这样导致被唤醒线程不能顺利加锁，延长了加锁时间，加重了系统不必要的负担

但是在LinuxThreads或者NPTL里面，就不会有这个问题，因为在Linux 线程中，有两个队列，分别是cond_wait队列和mutex_lock队列， cond_signal只是让线程从cond_wait队列移到mutex_lock队列，而不用返回到用户空间，不会有性能的损耗。
所以在Linux中推荐使用这种模式。

如果unlock和signal之前，有个低优先级的线程正在mutex上等待的话，那么这个低优先级的线程就会抢占高优先级的线程（cond_wait的线程)，而这在上面的放中间的模式下是不会出现的

 至于为什么在被唤醒之后还要再次进行条件判断（即为什么要使用while循环来判断条件），是因为可能有“惊群效应”。有人觉得此处既然是被唤醒的，肯定是满足条件了，其实不然。如果是多个线程都在等待这个条件，而同时只能有一个线程进行处理，此时就必须要再次条件判断，以使只有一个线程进入临界区处理

thread_cond_signal在多处理器上可能同时唤醒多个线程，当你只能让一个线程处理某个任务时，其它被唤醒的线程就需要继续 wait,while循环的意义就体现在这里了，而且规范要求pthread_cond_signal至少唤醒一个pthread_cond_wait上的线程，其实有些实现为了简单在单处理器上也会唤醒多个线程. 
2，某些应用，如线程池，pthread_cond_broadcast唤醒全部线程，但我们通常只需要一部分线程去做执行任务，所以其它的线程需要继续wait.所以强烈推荐此处使用while循环.

       其实说白了很简单，就是pthread_cond_signal()也可能唤醒多个线程，而如果你同时只允许一个线程访问的话，就必须要使用while来进行条件判断，以保证临界区内只有一个线程在处理。


#### 自旋锁

#### 屏障

- 用户协调多个线程并行工作的同步机制
- 允许每个线程等待，直到所有的合作进程都到达某一点，然后从该点继续执行

```c
#include <pthread.h>
int pthread_barrier_init(pthread_barrier_t *barrier, const pthread_barrierattr_t *attr, unsigned int count);
int pthread_barrier_destory(pthread_barrier_t *barrier);

int pthread_barrier_wait(pthread_barrier_t *barrier);
```

- count指定在允许所有线程继续运行之前，必须到达屏障的线程数目
- wait函数表明线程已完成工作，准备等所有其他线程赶上来。在屏障计数未满足条件时会进入休眠条件
- 对于一个任意线程，pthread_barrier_wait函数返回了PTHREAD_BARRIER_SERIAL_THREAD。剩下的线程看到的返回值都是0。这使得一个线程可以作为主线程，它可以工作在其他所有线程已完成的工作结果上。