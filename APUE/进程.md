# 进程

- [进程](#进程)
  - [1.进程环境](#1进程环境)
    - [1.1 命令行参数和环境表](#11-命令行参数和环境表)
    - [1.2 C程序的存储空间布局](#12-c程序的存储空间布局)
    - [1.3 空间分配,malloc系列](#13-空间分配malloc系列)
    - [1.4 setjmp和longjmp](#14-setjmp和longjmp)
    - [1.5 getrlimit和setrlimit](#15-getrlimit和setrlimit)
  - [2. 进程控制](#2-进程控制)
    - [2.1 进程标识](#21-进程标识)
      - [更改用户ID和更改组ID](#更改用户id和更改组id)
    - [2.2 创建进程](#22-创建进程)
      - [fork函数](#fork函数)
      - [vfork函数](#vfork函数)
      - [exec函数](#exec函数)
    - [2.3 进程终止](#23-进程终止)
      - [exit函数](#exit函数)
      - [终止处理程序](#终止处理程序)
      - [wait函数](#wait函数)
  - [3. 进程关系](#3-进程关系)
    - [3.1 系统的登录](#31-系统的登录)
    - [3.2 进程组](#32-进程组)
    - [3.3 会话](#33-会话)
    - [3.4 控制终端](#34-控制终端)
    - [3.5 作业控制](#35-作业控制)
  - [守护进程](#守护进程)
    - [守护进程的特征](#守护进程的特征)
    - [编写一个守护进程](#编写一个守护进程)
  - [进程间通信](#进程间通信)
    - [管道](#管道)


## 1.进程环境

### 1.1 命令行参数和环境表

```c
int main(int argc, char* argv[]);
extern char **environ;
```

- argc是命令行参数的数目，argv是指向参数的各个指针构成的数组
- environ是环境指针，指向环境表，环境表是一个字符指针数组，每个指针包含一个以null结束的C字符串地址，
- 环境字符串的形式通常为：`name=value`  

```c
#include <stdlib.h>
char* getenv(const char *name);
//成功则返回指向与name关联的value的指针，指向的是name=value字符串中的value,未找到则返回NULL
int putenv(char *str);
//将形式为name=value的字符串放到环境表中，如果name已存在，则先删除其原来的定义.成功返回0，出错返回非0值
int setenv(const char* name, const char *value, int rewrite);
//将name设成value，如果在环境中name已存在，rewrite非0是会先删除其现有的定义，rewrite为0则不删除也不覆盖也不出错,成功返回0，出错返回-1
int unsetenv(const char *name);
//删除name的定义，即使不存在也不算出错,成功返回0，出错返回-1
```

- 以更改当前环境和后面生成的子进程的环境，不能影响父进程的环境
- putenv不会分配存储空间，而setenv会，因为要依据其参数创建环境字符串，如果将存放在栈中的字符串作为参数传递给putenv，可能会发生错误，因为函数返回时其栈占用的存储区可能将被重用  
- 环境表占用的空间在进程地址空间的顶部，无法向高地址扩展，同时也不能移动在它之下的栈，所以也无法向低地址扩展。因此该空间的长度无法增加，这就导致：  
  - 如果修改一个现有的name,新value的长度大于原长度时，必须调用malloc为新字符串分配空间，将新字符串复制到该空间中，并使环境表种对name的指针指向新分配区。
  - 如果新增加一个name时。首先必须调用malloc为name=value字符串分配空间，将该字符串复制到此空间中，随后
    - 如果是第一次增加一个新name，还需要调用malloc为新的指针表分配空间，接着将原来的环境表复制到新分配区，并将指向新name=value字符串的指针存放在新指针表的表尾，然后将一个空指针存放在其后，最后使environ指向新指针表。（但是大部分指针仍指向栈顶上的字符串）
    - 如果不是第一次增加一个新的name，只用调用realloc多分配一个指针的空间。

### 1.2 C程序的存储空间布局

![内存管理](../pic/C++内存模型.png)
从低地址往高地址分别为：

* text segment(代码段):包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。
* data segment(数据段)：存储程序中已初始化的非0全局变量和静态变量
* bss segment：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0。这个段其实并不占用物理空间。
* heap（堆）： 当进程未调用malloc时是没有堆段的，只有调用malloc时采用分配一个堆，并且在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。分配小内存时使用该区域。  堆的起始地址由mm_struct 结构体中的start_brk标识，结束地址由brk标识。
* memory mapping segment(映射区):存储动态链接库等文件映射、申请大内存（malloc时调用mmap函数）
* stack（栈）：使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。在创建进程时会有一个最大栈大小，Linux可以通过ulimit命令指定。
* 存放命令行参数和环境变量

### 1.3 空间分配,malloc系列

```c
#include <stdlib.h>
void* malloc(size_t size);
void* calloc(size_t nobj, size_t size);
void* realloc(void *ptr, size_t newsize);
//成功返回非空指针，失败返回Null
void free(void *ptr);

```

- malloc分配指定字节数的存储区，初始值不确定
- calloc为指定数量指定长度的对象分配存储空间，每一位会被初始化为0
- realloc增加或减少以前分配区的长度。如果增加了长度，新增区域的初始值是不确定的
- free释放ptr指向的存储空间
- 返回的指针是对齐的
* 大多数实现所分配的存储空间会比所要求的要稍大一些。额外的空间用于记录管理信息(分配块的长度，指向下一个分配块的指针等)。因此，如果在超过一个已分配区的尾端或者在已分配区起始位置之前进行写操作，可能会破坏另一块的管理记录信息
* 内存泄漏：调用了malloc函数却忘记调用free函数

### 1.4 setjmp和longjmp

- goto语句不能跨越函数，实行跨越函数的跳转需要用setjmp和longjmp，能有效处理发生在深层嵌套函数调用中的出错情况
- 能在栈上跳过若干调用帧，返回到当前函数调用路径上的某一个函数中

```c
#include <setjmp.h>
int setjmp(jmp_buf env);
//若直接调用返回0，若从longjmp返回，则为非0。
void longjmp(jmp_buf env, int val);
//val指定setjmp返回的值

//一般使用模板为
if(setjump(jmpbuffer)!=0)
{
  ...//longjump返回后需要的操作
}
```

- 在希望返回到的位置调用setjmp
- jmp_buf数据类型是某种形式的数组，其中存放着调用longjmp时能用来恢复栈状态的所有信息，因为需要在另一个函数中引用env，所以通常将env变量定义为全局变量
- 不同类型变量在longjmp前后的变化情况
  - 全局变化,静态变量和易失变量(volatile)在执行longjmp前后保持不变，是最近所呈现的值
  - 自动变量和寄存器变量的值是不确定的
  - 某个系统中，存放在存储器中的变量将具有longjump时的值，而在cpu和浮点寄存器中的变量则会恢复为调用setjump时的值
  - 如果要编写一个使用非局部跳转的可移植程序，必须使用volatile属性

### 1.5 getrlimit和setrlimit

```c
#include <sys/resource.h>
int getrlimit(int resource, struct limit *rpltr);
int setrlimit(int resource, const struct limit *rpltr);
//成功返回0，出错返回非0
struct rlimit
{
    rlimit_t rlim_cur;//软限制，现在的限制
    rlimit_t rlim_max;//硬限制，rlim_cur可以取到的最大值
};
```

- 查询和更改进程的资源限制
- 任何一个进程都可将一个软限制值更改为小于等于其硬限制值
- 任何一个进程都可降低其硬限制值，但它必须大于或等于其软限制值，这种降低对于普通用户而言是不可逆的
- 只有超级用户可以提高硬限制值
- 如果读取和设置的rlimit中的值为RLIM_INFINITY宏，那么表示是无限制。
- resource的可选参数有

RLIMIT_AS/RLIMIT_VMEM: 这两个资源表示的是同一个含义，都是只address space限制，可用内存用户地址空间最大长度，会影响到sbrk和mmap函数。
RLIMIT_STACK：栈的长度，默认一般是8K
RLIMIT_CORE：程序crash后生成的core dump文件的大小，如果为0将不生成对应的core文件。
RLIMIT_NOFILE：进程能够打开的最多文件数目，此限制会影响到sysconf的_SC_OPEN_MAX的返回值。
RLIMIT_NPROC：每个用户ID能够拥有的最大子进程数目，此限制会影响到sysconf的_SC_CHILD_MAX的返回值。
RLIMIT_NICE:对应进程的优先级nice值。
RLIMIT_SWAP：进程能够消耗的最大swap空间。
RLIMIT_CPU：CPU时间的最大值（秒单位），超过此限制后会发送SIGXCPU信号给进程。
RLIMIT_DATA：数据段的最大长度。默认为unlimited
RLIMIT_FSIZE：创建文件的最大字节长度。默认为ulimited
RLIMIT_MSGQUEUE：为posix消息队列可分配的最大存储字节数
RLIMIT_SIGPENDING：可排队的信号最大数量
RLIMIT_NPTS：可同时打开的伪终端数目
RLIMIT_RSS：最大可驻内存字节长度
RLIMIT_SBSIZE：单个用户所有套接字缓冲区的最大长度
RLIMIT_MEMLOCK：一个进程使用mlock能够锁定存储空间中的最大字节长度


## 2. 进程控制

**用fork创建新进程，用exec函数执行新的程序，用exit和wait处理终止和等待终止**

### 2.1 进程标识

- 每个进程都有一个非负整型表示的唯一进程ID
- 进程ID是可复用的。但采用延时复用算法，使得赋予新建进程的ID不同于最近终止进程所使用的ID。防止将新进程误认为是使用同一ID的某个已终止的先前进程。
- 系统中保留的ID值：
  - 0：调度进程，也被称为交换进程，并不执行磁盘上的程序，是内核中的系统进程
  - 1：init进程，在自举过程结束后由内核调用，该进程的程序文件在unix早期版本中是/etc/init，在较新版本中是/sbin/init，负责在自举内核后启动Unix系统。进行系统的初始化，将系统引导到一个状态，该进程绝不会终止，是一个普通的用户进程，但是以超级用户特权运行，是所有孤儿进程的父进程

```c
#include <unistd.h>
pid_t getpid(void);  //进程ID
pid_t getppid(void); //父进程ID
uid_t getuid(void);  //实际用户ID
uid_t geteuid(void); //有效用户ID
gid_t getgid(void);  //实际组ID
gid_t getegid(void); //有效组ID
//没有出错返回
```

#### 更改用户ID和更改组ID

- 特权以及访问控制是基于用户ID和组ID的，当程序需要增加特权或者需要访问当前并不允许访问的资源时，需要更换自己的用户ID或组ID,使新ID具有合适的特权或访问权限
- 最小特权模型：程序应该只具有为完成给定任务所需的最小特权

```c
#include <unistd.h>
int setuid(uid_t uid); //设置用户ID
int setgid(gid_t gid); //设置组ID
//成功返回0，失败返回-1
```

- 若进程拥有超级用户特权，则setuid函数将实际用户ID,有效用户ID以及保存的设置用户ID设置为uid
- 若进程没有超级用户特权，但是uid等于实际用户ID或保存的设置用户ID,则setuid只能将有效用户ID设置为uid，不更改实际用户ID和保存的设置用户ID
- 若上述两个条件都不满足，则出错返回-1，并将errno设置为EPERM

### 2.2 创建进程

#### fork函数

```c
#include <unistd.h>
pid_t fork(void);
//子进程返回0,父进程返回子进程ID,出错返回-1
```

- fork的使用用途
  - 一个父进程希望复制自己，使父进程和子进程同时执行不同的代码片段
  - 一个进程要执行一个不同的程序，子进程从fork返回后立即调用exec
- 由fork创建的新进程被称为子进程，fork函数被调用一次但是返回两次
- 子进程和父进程继续执行fork调用后的指令，但是谁先执行是不确定的
- 子进程获得父进程的数据段、栈和堆的完全副本。现在都使用写时复制技术。一开始这些区域由子进程和父进程共享，只有其中任意一个试图修改这些区域时，才会真正的复制出一个副本
- fork会使父进程的所有打开的文件描述符都被复制到子进程，父进程和子进程每个相同的打开描述符共享一个文件表项，也即共享文件偏移量，文件状态位置和节点指针。这就导致如果子进程和父进程同时写同一描述符指向的文件，如果没有确定形式的同步，输出是会相互混合的。常见处理方式是：
  - 父进程等待子进程完成后再运行
  - 父进程和子进程各自执行不同的程序段
- fork与标准IO函数。如果在fork前，有数据写到缓冲区且并未冲洗，fork之后子进程和父进程都会写入该数据一次。因为缓冲区中的数据也会被复制到子进程中。
- 子进程继承的父进程属性
  - 实际用户ID,有效用户ID,实际组ID,有效组ID
  - 附属组ID
  - 进程组ID
  - 会话ID
  - 控制终端
  - 设置用户ID标志和设置组ID标志
  - 当前工作目录
  - 根目录
  - 文件模式创建屏蔽字
  - 信号屏蔽和安排
  - 对任一打开文件描述符的执行时关闭标志
  - 环境
  - 连接的共享存储段
  - 存储印象
  - 资源限制
- 父进程和子进程的不同
  - fork返回的值不同
  - 进程ID不同
  - tms_utime,tms_stime,tms_cutime,tms_ustime被设置为0
  - 不继承父进程设置的文件锁
  - 未处理闹钟被清除
  - 未处理信号集设置为空集


#### vfork函数

- 不建议在可移植的应用程序中使用这个函数
- 目的是用于创建一个新进程，而该新进程的目的是exec一个新程序
- 和fork区别
  - vfork并不复制父进程的地址空间，因为认为子进程会立即调用exec，因此在子进程调用exec之前，它在父进程的空间中运行，如果这时子进程修改数据、进行函数调用等会造成未知的后果
  - vfork会保证子进程先运行，当子进程调用exec或exit后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖父进程的进一步动作，会导致死锁。

#### exec函数

- 用fork创建新进程，用exec函数执行新的程序，用exit和wait处理终止和等待终止
- 调用exec函数后，进程执行的程序被完全替换成新程序，并从其main函数开始执行
- 并不是创建新进程，所以前后的进程ID并未改变，只是用一个新程序替换了当前进程的正文段，数据段，堆和栈

```c
#include <unistd.h>
int execl(const char *pathname, const char *arg0, ..., (char *)0);
int execv(const char *pathname, char * const argv[]);
int execle(const char* pathname,const char *arg0, ..., (char *)0, char* const envp[]);
int execve(const char *pathname, char * const argv[],char* const envp[]);
int execlp(const char *filename,const char *arg0, ..., (char *)0);
int execvp(const char *filename, char *const argv[]);
int fexecve(int fd, char *const argv[], char *const envp[]);
//出错返回-1，成功不返回
```

- 共有7种函数，前4个取路径名为参数，后两个取文件名作为参数（p结尾），最后一个取文件描述符作为参数（f开头）
- 用文件名作为参数时：
  - 如果filename种包含/，就将其视为路径名
  - 否则就按PATH环境变量，在它所指定的各目录中搜寻指定的可执行文件，即在PATH环境变量中查找第一个包含filename的可执行文件的路径前缀。
  > PATH变量包含了一张目录表,称为路径前缀，目录之间用冒号分隔。零长前缀也表示当前目录。
  > PATH为name=value的格式
- l表示List, execl, execlp和execle，要求将新程序的每个命令行参数都说明为一个单独的参数，并以空指针结尾
- v表示vector,execv,execvp,execve,execve则应先构造一个指向各参数的指针数组，然后将该数组地址作为这四个函数的参数
- e表示环境表，以e结尾的execve,execle,fexecve可以传递一个指向环境字符串指针数组的指针。其他4个函数则使用调用进程中的environ变量为新程序复制现有的环境
- 只有execve是内核的系统调用，其他6个只是库函数，最终都要调用execve
  - fexecve使用/proc把文件描述符参数转换成路径名

### 2.3 进程终止

- 有8种方式可导致进程终止，其中5种为正常终止，分别为  
  1. 从main返回，执行return，等效于调用exit
  2. 调用exit，调用各终止处理程序，然后关闭所有标准IO流
  3. 调用_exit或_Exit，直接终止，不运行终止处理程序，也不冲洗标准IO流
  4. 最后一个线程从其启动例程返回[详情](./线程.md/#终止线程)，这种情况下进程的终止状态总是为0
  5. 从最后一个线程调用pthread_exit，同样这种情况下进程的终止状态总是为0
- 还有3种为异常终止，分别为  
  1. 调用abort，产生SIGABRT信号  
  2. 接到一个信号，信号可由进程自身，其他进程或内核产生  
  3. 最后一个线程对取消请求做出响应，详细说明见  
- **父进程在子进程之前终止**: 子进程的父进程会被改变为init进程。操作过程是：在一个进程终止时，内核逐个检查所有的活动进程，判断它是否是正要终止进程的子进程，如果是，就将该进程的父进程ID改为1，保证每个进程都有一个父进程
- **子进程在父进程之前终止**: 内核会为每个终止子进程保存一定量的信息，当其父进程调用wait或waitpid时，可以获得这些信息，包括进程ID,进程的终止状态以及该进程使用的CPU时间总量。一个已经终止，但父进程尚未对其进行梳理的进程被称为僵死进程，ps命令将僵死进程的状态打印为Z
- **init进程收养的进程**: 不会变成僵死进程，init无论何时只要有一个子进程终止，就会调用一个wait函数取得其终止状态
- 如果一个进程fork一个子进程，但不要它等待子进程终止，也不希望子进程处于僵死状态直到父进程终止。实现这一要求的方法是调用fork两次，让第一个子进程调用第二次fork后exit。

#### exit函数

```c
#include <stdlib.h>
void exit(int status);
void _Exit(int status);
#include <unistd.h>
void _exit(int status);
```

* _exit和_Exit不执行标准IO的缓冲区冲洗操作
* exit会冲洗缓冲区，并关闭IO流
* status是程序终止状态，在shell中用`echo $? `查看程序终止状态
  - 下列情况的终止状态是未定义的
    - 调用这三个函数时不带终止状态
    - main函数执行了一个无返回值的return语句
    - main没有声明返回类型为整型
  - 若main的返回类型是整型，并且main执行到最后一条语句时返回，那么终止状态为0
* 子进程可通过传入退出状态通知其父进程它是如何终止的，父进程可用wait和waitpid获得子进程的退出状态

#### 终止处理程序

```c
#include <stdlib.h>
int atexit(void (*func)(void));
//成功返回0，出错返回非0
```
- 登记函数的终止处理程序，参数是函数指针，参数类型和返回类型都是void
- 进程调用exit后，exit会先调用这些终止处理程序，调用的顺序和登记时候的顺序相反，随后关闭所有的打开流。
- 调用了_exit或_Exit后会清除所有已安装的终止处理程序

#### wait函数

* 当一个进程终止时，内核会向其父进程发送SIGCHLD信号。父进程可以忽略该信号，也可以提供一个信号处理程序。系统的默认动作的忽略它。

```c
#include <sys/wait.h>
pid_t wait (int *stat)；
pid_t waitpid(pid_t pid, int *stat, int option);
//成功返回进程ID,出错返回0或-1
int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
//成功返回0，出错返回-1
```

- 终止进程的终止状态存放在stat指向的地址中，如果不关心终止状态，可以将stat指定为空指针，可用宏来判断stat来得到进程终止的原因
  - `WIFEXITED(stat)`,若为正常终止则为真，并可以用`WEXITSTATUS(stat)`获得子进程传递给exit参数的低8位
  - `WIFSIGNALED(stat)`, 若为异常终止则为真，并可用`WTERMSIG(stat)`获得使子进程终止的信号编号
  - `WCOREDUMP(stat)`, 若产生了core文件则为真
  - `WIFSTOPPED(stat)`，若为当前暂停子进程的返回状态，则为真,并可用`WSTOPSIG(stat)`获得使子进程暂停的信号编号
  - `WIFCONTINUED(stat)`，若为在作业控制暂停后已经继续进程的子进程返回了状态，则为真
- waitpid中pid的取值
  - pid==-1，等待任一子进程，等同于wait
  - pid>0，等待进程ID与pid相等的子进程
  - pid==0，等待组ID等于调用进程组ID的任一子进程
  - pid<-1，等待组ID等于pid绝对值的任一子进程
  - 当指定的进程或进程组不存在，或者不是调用进程的子进程时，会出错
- option控制着waitpid的操作，取值为 0或下列常量 按位或运算的结果
  - `WCONTINUED`,若实现支持作业控制，那么由pid指定的任一子进程在停止后已经继续，但其状态尚未报告，则返回其状态
  - `WNOHANG`, 当由pid指定的子进程并不是立即可用时，不阻塞，直接返回0
  - `WUNTRACED`,若实现支持作业控制，那么由pid指定的任一子进程已处以停止状态，并且其状态自停止以来还未报告过，则返回其状态。
- 调用函数可能出现的状态
  - 如果其所有子进程都还在运行，则阻塞
  - 如果有一个子进程已终止，则取得该子进程的终止状态后返回
  - 如果没有任何子进程，则立即出错返回
- waitid中参数的可能取值
  - idtype的值控制着id的参数的含义
    - P_PID
    - P_PGID
    - P_ALL
  - options参数是下列标志的按位或运算
    - `WCONTINUED`,
    - `WNOHANG`
    - 


## 3. 进程关系

### 3.1 系统的登录 

### 3.2 进程组

- 进程组是一个或多个进程的集合，同一进程组中的各进程结构来自同一终端的信号。
- 每个进程组都有一个唯一的进程组ID,等于进程组组长进程的进程ID
- 进程组的生命期从进程组创建开始到其中最后一个进程离开，组长进程的存在与否并不关系到进程组的存在与否，

```c
#include <unistd.h>
pid_t getpgrp(void); //返回调用进程的进程组ID
pid_t getpgid(pid_t pid); //成功返回pid进程的进程组ID，pid为0时返回调用进程的进程组ID,出错返回-1
int setpgid(pid_t pid, pid_t pgid); //加入一个现有的进程组或者创建一个新进程组，成功返回0，出错返回-1

```

- setpgid函数将pid进程的进程组ID设置为pgid，如果这两个参数相等，则由pid指定的进程变成进程组组织，如果pid是0，则使用调用者的进程ID,如果pgid是0，则由pid指定的进程ID用作进程组ID
- 一个进程只能为它自己或它的子进程设置进程组ID,并且在它的子进程调用exec后，它就不能再更改该子进程的进程组ID了
- 一般在实际应用中，在fork后，父进程和子进程都会调用setpgid函数设置一下子进程的进程组ID，因为父进程和子进程运行的先后顺序不一样，在两个进程都设置才能保证成功

### 3.3 会话

- 会话(session)是一个或多个进程组的集合，这些进程组共享一个控制终端，而这个控制终端通常是创建第一个进程的登录终端
- 会话首进程的ID被视为会话ID

```c
#include <unistd.h>
pid_t setsid(void); //成功返回进程组ID,出错返回-1
pid_t getsid(pid_t pid);
//如果pid是0，返回调用进程的会话首进程的进程组ID
//如果pid并不属于调用者所在的会话，则返回出错，返回-1
```

- 如果调用setsid的进程不是一个进程组的组长，则此函数会创建一个新会话，发生以下步骤
  - 该进程变成新会话的会话首进程，此时该进程是新会话中的唯一进程
  - 该进程称为一个新进程组的组长进程，新进程组ID就是该调用进程的进程ID
  - 该进程没有控制终端，如果在调用setsid之前该进程有一个控制终端，那么这种联系也被切断。但是在某些系统中，当会话首进程打开一个尚未与任何会话相关联的终端设备时，此设备会自动作为控制终端分配给该会话。
- 如果是一个进程组的组长，则调用setsid会返回出错。为了避免这种状况，通常是先调用fork,然后使其父进程终止，在子进程中调用这个函数。因为子进程继承了父进程的进程组ID,而其新进程ID是新分配的，两者不可能相等，保证了子进程不是一个进程组的组长

### 3.4 控制终端

- 一个会话可以有一个控制终端
- 建立与控制终端连接的会话首进程被称为控制进程
- 一个会话中的几个进程组可被分为一个前台进程组和若干个后台进程组
  - 键入终端的中断键(通常是Delete或Ctrl+C)，会发生中断信号到前台进程组的所有进程
  - 键入终端的退出键(通常是Ctrl+\\)，会发送退出信号到前台进程组的所有进程
  - 如果终端接口检测到调制解调器断开连接，会发送挂断信号给控制进程(会话首进程)
- 分配控制终端的两种方式



### 3.5 作业控制







## 守护进程

### 守护进程的特征

* 后台运行
* 没有控制终端
* 生存期长，常常在系统引导装入时启动，仅在系统关闭时终止
* 周期性地执行某项任务或等待某些发生地事件

### 编写一个守护进程

1. 调用umask将文件模式创建屏蔽字设置为一个已知值(通常是0)
2. 调用fork，然后使父进程exit。这样做实现了以下几点: 子进程继承了父进程的进程组ID,但获得了一个新的进程ID,保证了子进程不是一个程组的组长进程
3. 调用setsid创建一个新会话。使调用进程成为新会话的首进程，成为新进程组的组长进程并且没有控制终端。
   * 但是在某些系统中，当会话首进程打开一个尚未与任何会话相关联的终端设备时，此设备会自动作为控制终端分配给该会话。这种情况下，可以再次调用fork,终止子进程，在孙子进程中创建守护进程，保证该守护进程不是会话首进程，防止它取得控制终端。
   * 还需要注意在会话首进程退出时，会对其所在会话的所有进程发送SIGHUP信号，而SIGHUP信号的默认处理函数结束进程。因此在孙子进程中需要忽略这一信号。
   * 还有一种方法是无论何时打开一个终端设备都一定要指定O_NOCTTY。
4. 将当前工作目录更改为根目录。从父进程处继承过来的当前工作目录可能在一个挂载的文件系统中，因为守护进程通常在系统再引导之前是一直存在的，所以如果守护进程的当前工作目录在一个挂载文件系统中，那么该文件系统就不能被卸载。
5. 关闭不再需要的文件描述符。使守护进程不再持有从其父进程继承来的任何文件描述符
6. 打开/dev/null使其具有文件描述符0、1、2，这样任何一个试图读标准输入、写标准输出或标准错误的库例程都不会产生任何效果















## 进程间通信

IPC(InterProcess Communication)

### 管道

* 管道是半双工的
* 管道只能在具有公共祖先的两个进程之间使用

```c
#include <unistd.h>
int pipe(int fd[2]);
//成功返回0，出错返回-1
```

* 通过参数fd返回两个文件描述符
  * fd[0]为读而打开，对其调用read
  * fd[1]为写而打开，对其调用write
  * fd[1]的输出是fd[0]的输入
* 应用场景通常是：进程先调用pipe,接着调用fork,从而创建从父进程到子进程的IPC通道
  * 对于从父进程到子进程的管道，父进程关闭管道的读端(fd[0]),子进程关闭管道的写端(fd[1])
  * 对于从子进程到父进程的管道，父进程关闭管道的写端(fd[1]),子进程关闭管道的读端(fd[0])
* 读一个写端已关闭的管道时，在所有数据读取后，read返回0，表示文件结束
* 写一个读端已关闭的管道时，会产生信号SIGPIPE,write会返回-1，errno设置为EPIPE
* 常量PIPE_BUF规定了内核的管道缓冲区的大小，写管道时写的字节应该小于等于这个值