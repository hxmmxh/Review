进程

--------------------------------------------
- [0. 前言](#0-前言)
- [1. 进程环境](#1-进程环境)
  - [1.1 命令行参数和环境表](#11-命令行参数和环境表)
    - [获取和设置环境变量](#获取和设置环境变量)
  - [1.2 C程序的存储空间布局](#12-c程序的存储空间布局)
  - [1.3 共享库](#13-共享库)
    - [静态链接库与动态链接库](#静态链接库与动态链接库)
  - [1.4 堆空间分配](#14-堆空间分配)
    - [底层函数](#底层函数)
    - [malloc库函数](#malloc库函数)
    - [malloc和free的实现](#malloc和free的实现)
  - [1.5 setjmp和longjmp](#15-setjmp和longjmp)
  - [1.6 进程资源限制](#16-进程资源限制)
  - [1.7 Core Dump](#17-core-dump)
    - [产生Core Dump](#产生core-dump)
- [2. 进程控制](#2-进程控制)
  - [2.1 进程标识](#21-进程标识)
    - [更改用户ID和更改组ID](#更改用户id和更改组id)
    - [用户标识](#用户标识)
  - [2.2 创建新进程](#22-创建新进程)
    - [fork函数](#fork函数)
      - [子进程和父进程的数据共享](#子进程和父进程的数据共享)
    - [vfork函数](#vfork函数)
    - [竞争条件](#竞争条件)
    - [exec函数](#exec函数)
  - [2.3 进程终止](#23-进程终止)
    - [exit函数](#exit函数)
    - [终止处理程序](#终止处理程序)
    - [wait函数](#wait函数)
  - [2.4 解释器文件](#24-解释器文件)
  - [2.5 system函数](#25-system函数)
  - [2.6 进程会计](#26-进程会计)
  - [2.7 进程调度](#27-进程调度)
  - [2.7 进程时间](#27-进程时间)
- [3. 进程关系](#3-进程关系)
  - [3.1 终端登录](#31-终端登录)
  - [3.2 网络登录](#32-网络登录)
  - [3.3 进程组](#33-进程组)
  - [3.4 会话](#34-会话)
  - [3.5 控制终端](#35-控制终端)
  - [3.6 作业控制](#36-作业控制)
  - [3.7 shell执行程序](#37-shell执行程序)
- [4. 守护进程](#4-守护进程)
  - [4.1 守护进程的特征](#41-守护进程的特征)
  - [4.2 守护进程的编程规则](#42-守护进程的编程规则)
- [5. 进程间通信IPC](#5-进程间通信ipc)
  - [5.1 管道](#51-管道)
    - [协同进程](#协同进程)
  - [5.2 FIFO](#52-fifo)
  - [5.3 XSI　IPC](#53-xsiipc)
    - [标识符和键](#标识符和键)
    - [权限结构](#权限结构)
    - [优缺点](#优缺点)
  - [5.4 消息队列](#54-消息队列)
    - [与消息队列相关的函数](#与消息队列相关的函数)
  - [5.5 信号量](#55-信号量)
    - [信号量的相关结构](#信号量的相关结构)
    - [信号量的相关函数](#信号量的相关函数)
  - [5.6 共享存储](#56-共享存储)
- [6. 网络IPC](#6-网络ipc)

# 0. 前言

- **程序**，一个存储在磁盘某个目录中的可执行文件。内核使用exec函数将程序读入内存
- **进程**，程序的执行实例。每个进程都有一个唯一的数字标志符，称为进程ID
- 有三个用于进程控制的主要函数：fork,exec,waitpid

# 1. 进程环境

## 1.1 命令行参数和环境表

```c
int main(int argc, char* argv[]);
extern char **environ;
```

- C程序总是从main函数开始执行的
- 命令行参数
  - argc是命令行参数的数目，argv是指向参数的各个指针构成的数组
  - ISOC和POSIX都要求argv[argc]是一个空指针
- 环境表
  - 全局变量environ是`环境指针`，指向`环境表`，环境表是一个字符指针数组，每个指针包含一个以null结束的C字符串地址（称为`环境字符串`），同时该数组的最后一项也是null
  - 环境字符串的形式通常为：`name=value`  
  - 环境表和环境字符串通常存放在进程存储空间的顶部（栈的上方）


### 获取和设置环境变量

```c
#include <stdlib.h>
char* getenv(const char *name);
int putenv(char *str);
int setenv(const char* name, const char *value, int rewrite);
int unsetenv(const char *name);
```

- getenv返回与name关联的value的指针，指向name=value字符串中的value
- putenv添加环境变量，将其放入环境表中。`str`为`name=value`形式的环境变量。如果已经存在，则先删除原有的定义
- `setenv` ：修改环境变量。如果环境变量已经存在，有下列2种可能：
    - 若`rewrite`非0，则先删除其现有定义，然后添加新定义
    - 若`rewrite`为0，则不删除其现有定义，并且不将`name`修改为新值`value`，而且也不出错
- `unsetenv` ：删除环境变量，即删除`name`的定义。即使不存在这种定义也不算出错
- 只更改当前环境和后面生成的子进程的环境，不能影响父进程的环境
- putenv不会分配存储空间，而setenv会，因为要依据其参数创建环境字符串，如果将存放在栈中的字符串作为参数传递给putenv，可能会发生错误，因为函数返回时其栈占用的存储区可能将被重用  
- 环境表占用的空间在进程地址空间的顶部，无法向高地址扩展，同时也不能移动在它之下的栈，所以也无法向低地址扩展。因此该空间的长度无法增加，这就导致：  
  - 如果修改一个现有的name,新value的长度大于原长度时，必须调用malloc为新字符串分配空间，将新字符串复制到该空间中，并使环境表中对name的指针指向新分配区。
  - 如果新增加一个name时。首先必须调用malloc为name=value字符串分配空间，将该字符串复制到此空间中，随后
    - 如果是第一次增加一个新name，还需要调用malloc为新的指针表分配空间，接着将原来的环境表复制到新分配区，并将指向新name=value字符串的指针存放在新指针表的表尾，然后将一个空指针存放在其后，最后使environ指向新指针表。（但是大部分指针仍指向栈顶上的字符串）
    - 如果不是第一次增加一个新的name，只用调用realloc多分配一个指针的空间。并将新的`name=value`字符串的指针存放到该指针表的表尾，然后将一个空指针存放在其后

## 1.2 C程序的存储空间布局

![内存管理](../pic/C++内存模型.png)
- 从低地址往高地址分别为：
- text segment(正文段):包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。
  - 通常正文段是可以共享的。一个程序可以同时执行`N`次，但是该程序的正文段在内存中只需要有一份而不是`N`份
  - 通常正文段是只读的，以防止程序由于意外而修改其指令
- data segment(初始化数据段)：存储程序中已初始化的非0全局变量和静态变量
- bss segment(未初始化数据段)：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0。这个段其实并不占用物理空间。
- heap（堆）：通常在堆中进行动态存储分配
  - 当进程未调用malloc时是没有堆段的，只有调用malloc时采用分配一个堆，并且在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。分配小内存时使用该区域。 
  - 堆的起始地址由mm_struct 结构体中的start_brk标识，结束地址由brk标识。
- memory mapping segment(映射区):存储动态链接库等文件映射、申请大内存（malloc时调用mmap函数）
- stack（栈）：自动变量以及每次函数调用时所需要保存的信息都存放在此段中，使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。
  - 在创建进程时会有一个最大栈大小，Linux可以通过ulimit命令指定。
- 存放命令行参数和环境变量

## 1.3 共享库

- 大多数UNIX系统支持共享库
- 共享库的优点
    - 使得可执行文件中不再需要包含公用的库函数，而只需在所有进程都可引用的存储区中保存这种库例程的一个副本。程序第一次执行或者第一次调用某个库函数时，用动态链接方法将程序与共享库函数相链接，减少了每个可执行文件的长度
    - 可以用库函数的新版本代替老版本而无需对使用该库的程序重新链接编辑（假定参数的数目和类型都没有改变）
- 共享库的缺点
    - 动态链接增加了一些运行时开销。这种时间开销发生在该程序第一次被执行时，或者每个共享库函数第一次被调用时
    - 
### 静态链接库与动态链接库

链接库按是否被编译到程序内部而分成动态与静态链接库

- **静态链接库**
    - 扩展名为`.a`，通常命名为`libxxx.a`
    - 整合到可执行文件中，因此会导致可执行文件体积增大
    - 可独立执行，而不需要再向外部要求读取链接库的内容
    - 链接库升级时，需要重新编译生成可执行文件
- **动态链接库**
    - 扩展名为`.so`，通常命名为`libxxx.so`
    - 动态链接库的内容并没有整合到可执行文件中，需要使用时才去读取链接库，因此可执行文件体积较小
    - 不能独立执行，链接库必须存在
    - 链接库升级时，通常不需要重新编译
- 为了加速动态链接库的访问效率，一般需要将动态链接库载入内存中，从而避免读取磁盘。加载到高速缓存中的动态链接库所在的目录在文件`/etc/ld.so.conf`中指定，可以使用命令`ldconfig`将该文件中指定目录下的动态库读入缓存中
- 如果在编译时指定了动态链接库及库的路径，但是`/etc/ld.so.conf`文件中没有包含该路径，即这个动态链接库没有载入内存，那么运行生成的可执行文件会报错
- `ldd`命令可以查看某个可执行的二进制文件含有什么动态链接库，对于前面的问题，如果某个动态链接库没有载入内存，即动态链接库的路径没有包含在文件`/etc/ld.so.conf`中。使用ldd查看时，这个库会显示“not found”
  
## 1.4 堆空间分配

- 堆上空间分配和释放核心都是通过调整**program break**来实现的，malloc和free维护空闲空间链表，以减少调整**program break**的系统调用的调用次数

### 底层函数

- heap的起始地址并不是bss segment的结束地址，而是随机分配的
- bss和heap是不相邻的，并且同一个程序bss的结束地址是固定的，而heap的起始地址在每次运行的时候都会改变
- program break指向堆的结束位置
- 可以通过brk函数和sbrk函数改变进程的program break位置，从而分配或释放内存。

```c
#include <unistd.h>
int brk(void *end_data_segment);
void *sbrk(intptr_t increment);
```
- **brk**：将**program break**设置为参数指定的位置
    - 虚拟内存以页为单位进行分配，所以`end_data_segment`实际会四舍五入到下一个内存页的边界处
    - 当试图将`end_data_segment`设置为一个**低于**其初始值（&end）的位置时，可能导致无法预知的行为
- **sbrk**：将**program break**在原有地址上增加参数`increment`大小（`intptr_t`为整形类型），该函数成功时返回前一**program break**的地址
- **sbrk(0)**将返回**program break**的当前位置，可以用于跟踪堆的大小，或是监视内存分配函数的行为


### malloc库函数

```c
#include <stdlib.h>
void* malloc(size_t size);
void* calloc(size_t nobj, size_t size);
void* realloc(void *ptr, size_t newsize);
//成功返回非空指针，失败返回Null
void free(void *ptr);

```

- malloc分配指定字节数的存储区，初始值不确定
- calloc为指定数量指定长度的对象分配存储空间，每一位会被初始化为0
- realloc增加或减少以前分配区的长度。如果增加了长度，新增区域的初始值是不确定的
  -  函数调用前后可能是不同的存储区，所以调用前不应该有指针指向这段存储区，不然修改后，可能该指针会非法访问
  -  应该使用另一个指针保存`realloc`的返回值，因为如果使用传入的实参保存返回值，那么一旦`realloc`失败，则会传回NULL，原来的动态内存区再也无法访问，从而发生内存泄露
- free释放ptr指向的存储空间
  -  一般情况下，free并不降低program break的位置，而是将这块内存增加到空闲内存列表中，供后续的malloc循环使用
  -  被释放的内存块通常会位于堆的中间，而非堆的顶部，因为降低**program break**是不可能的
  - 它最大限度地减少了程序必须执行的`sbrk`调用次数
  - 在大多数情况下，降低**program break**不会对那些分配大量内存的程序有多少帮助，因为它们通常倾向于持有已分配内存或是反复释放和重新分配内存，而非释放所有内存后再持续运行一段时间
- 返回的指针是对齐的
- 大多数实现所分配的存储空间会比所要求的要稍大一些。额外的空间用于记录管理信息(分配块的长度，指向下一个分配块的指针等)。因此，如果在超过一个已分配区的尾端或者在已分配区起始位置之前进行写操作，可能会破坏另一块的管理记录信息
- 内存泄漏：调用了malloc函数却忘记调用free函数
- free错误：释放已经释放了的块，释放不是动态分配的指针

### malloc和free的实现

- 大部分我们使用的是malloc和free函数来分配和释放内存。这样能够提高程序的性能，不是每次分配内存都调用brk或sbrk，而是重用前面空闲的内存空间。brk和sbrk分配的堆空间类似于缓冲池，每次malloc从缓冲池获得内存，如果缓冲池不够了，再调用brk或sbrk扩充缓冲池，直到达到缓冲池大小的上限，free则将应用程序使用的内存空间归还给缓冲池。
- **malloc的实现**
  1. 首先会扫描（不同实现扫描策略可能不同）之前由free释放的空闲内存块列表，试图找到尺寸大小**大于或等于**要求的一块空闲内存
    * 如果一内存块的尺寸恰好符合要求，那么直接返回给调用者
    * 如果内存块较大，那么进行分割，将一块大小相当的内存返回给调用者，剩余内存块保留在空闲列表
  2. 如果空闲内存列表中根本找不到足够大的空闲内存块（**如首次调用malloc时**），那么malloc会调用**sbrk**以分配更多的内存（为了减少对**sbrk**的调用次数，malloc并不是严格按所需字节数来分配内存，而是以更大幅度来增加**program break**，并将超出部分置于空闲内存列表）
  - 当malloc分配内存块时，会额外分配几个字节来存放**记录这块内存大小的整数值**。该整数位于内存块的起始处，而实际返回给调用者的内存地址恰好位于 这一长度记录字节之后：
- **free的实现**
  1. free会使用内存块本身的空间来存放链表指针(保存有指向前一个空闲内存块的指针和后一个空闲内存块的指针)，将自身添加到列表中
  2. 随着对内存不断地释放和重新分配，空闲列表中的空闲内存会和已分配的在用内存混杂在一起

## 1.5 setjmp和longjmp

- goto语句不能跨越函数，实行跨越函数的跳转需要用setjmp和longjmp，能有效处理发生在深层嵌套函数调用中的出错情况
- 能在栈上跳过若干调用帧，返回到当前函数调用路径上的某一个函数中

```c
#include <setjmp.h>
//若直接调用返回0，若从longjmp返回，则为非0。
int setjmp(jmp_buf env);
//val指定setjmp返回的值
void longjmp(jmp_buf env, int val);


//一般使用模板为
if(setjump(jmpbuffer)!=0)
{
  ...//longjump返回后需要的操作
}
```

- 在希望返回到的位置调用setjmp
- jmp_buf env是某种形式的数组，其中存放着调用longjmp时能用来恢复栈状态的所有信息，因为需要在另一个函数中引用env，所以通常将env变量定义为全局变量
- 不同类型变量在longjmp前后的变化情况
  - 全局变化,静态变量和易失变量(volatile)在执行longjmp前后保持不变，是最近所呈现的值
  - 自动变量和寄存器变量的值是不确定的
  - 某个系统中，存放在存储器中的变量将具有longjump时的值，而在cpu和浮点寄存器中的变量则会恢复为调用setjump时的值
    - 不进行任何优化的编译，5种变量都存放在存储器中
    - 进行了优化后，自动变量和寄存器变量都存放在寄存器中
  - 如果要编写一个使用非局部跳转的可移植程序，必须使用volatile属性
- violate变量，易变的
  - 该变量是容易更改的，因此不能被编译优化，也不存储在寄存器（每个线程都有自己独立的寄存器）
  - 每次取这种变量的值都不是从缓存中取，而是从真正对应的内存地址中取.
- register变量
  - 当某一变量需要被频繁使用，为了存取变量值少花些时间，则将该变量直接放在寄存器中，需要时直接从寄存器读取参与运算，而不需要从内存中读取。寄存器读取速度远大于内存访问速度，这种变量被成为寄存器变量
  - 只有局部自动变量和形式参数可以作为寄存器变量，全局变量不行；
  - 计算机系统中寄存器数目有限，不能定义任意多个寄存器变量；
  - 局部静态变量不能定义为寄存器变量，存储在静态变量区，在编译时提前分配好内存；
  - 寄存器变量必须是单一变量，长度小于整型变量
  

## 1.6 进程资源限制

- 每个进程都有一组资源限制，其中一些可以用getrlimit和setrlimit函数查询和更改：
- 进程的资源限制通常是在系统初始化时由0进程建立的，然后由后续进程继承。每种实现都可以用自己的方法对资源限制做出调整

```c
#include <sys/resource.h>
int getrlimit(int resource, struct limit *rpltr);
int setrlimit(int resource, const struct limit *rpltr);
//成功返回0，出错返回非0
struct rlimit
{
    rlimit_t rlim_cur;//软限制，现在的限制
    rlimit_t rlim_max;//硬限制，rlim_cur可以取到的最大值
};
```

- 查询和更改进程的资源限制
- 任何一个进程都可将一个软限制值更改为小于等于其硬限制值
- 任何一个进程都可降低其硬限制值，但它必须大于或等于其软限制值，这种降低对于普通用户而言是不可逆的
- 只有超级用户可以提高硬限制值
- 如果读取和设置的rlimit中的值为RLIM_INFINITY宏，那么表示是无限制。
- resource的可选参数有
  - RLIMIT_AS/RLIMIT_VMEM: 这两个资源表示的是同一个含义，都是只address space限制，可用内存用户地址空间最大长度，会影响到sbrk和mmap函数。
  - LIMIT_STACK：栈的长度，默认一般是8K
  - RLIMIT_CORE：程序crash后生成的core dump文件的大小，如果为0将不生成对应的core文件。
  - RLIMIT_NOFILE：进程能够打开的最多文件数目，此限制会影响到sysconf的_SC_OPEN_MAX的返回值。
  - RLIMIT_NPROC：每个用户ID能够拥有的最大子进程数目，此限制会影响到sysconf的_SC_CHILD_MAX的返回值。
  - RLIMIT_NICE:对应进程的优先级nice值。
  - RLIMIT_SWAP：进程能够消耗的最大swap空间。
  - RLIMIT_CPU：CPU时间的最大值（秒单位），超过此限制后会发送SIGXCPU信号给进程。
  - RLIMIT_DATA：数据段的最大长度。默认为unlimited
  - RLIMIT_FSIZE：创建文件的最大字节长度。默认为ulimited
  - RLIMIT_MSGQUEUE：为posix消息队列可分配的最大存储字节数
  - RLIMIT_SIGPENDING：可排队的信号最大数量
  - RLIMIT_NPTS：可同时打开的伪终端数目
  - RLIMIT_RSS：最大可驻内存字节长度
  - RLIMIT_SBSIZE：单个用户所有套接字缓冲区的最大长度
  - RLIMIT_MEMLOCK：一个进程使用mlock能够锁定存储空间中的最大字节长度

##  1.7 Core Dump

- Core Dump是一个文件，它记录了程序运行过程中异常终止或崩溃时的内存映像
- 当程序运行的过程中异常终止或崩溃，操作系统会将程序当时的内存状态记录下来，保存在一个文件中，这种行为就叫做Core Dump（中文有的翻译成“核心转储”)。可以认为 core dump 是“内存快照”，但实际上，除了内存信息之外，还有些关键的程序运行状态也会同时 dump 下来，例如寄存器信息（包括程序指针、栈指针等）、内存管理信息、其他处理器和操作系统状态和信息
- core dump 对于编程人员诊断和调试程序是非常有帮助的，因为对于有些程序错误是很难重现的，例如指针异常，而 core dump 文件可以再现程序出错时的情景

### 产生Core Dump
- `ulimit -c`可以查看shell进程产生的core dump文件大小，默认情况下为0，即不产生core dump文件，
- 若要产生，使用`ulimit -c unlimited`开启core dump功能（也可以改成为某一值，注意这种修改方式只会对当前终端环境生效）
- 以下列出几种会产生Core Dump的信号（不仅限于这几种）：

|  信号   |   动作    |        说明         |
| :-----: | :-------: | :-----------------: |
| SIGQUIT | 终止+core | 终端退出符(ctrl+\\) |
| SIGILL  | 终止+core |    非法硬件指令     |
| SIGABRT | 终止+core |   异常终止(abort)   |
| SIGSEGV | 终止+core |    无效内存引用     |
| SIGTRAP | 终止+core |      硬件故障       |
# 2. 进程控制

**用fork创建新进程，用exec函数执行新的程序，用exit和wait处理终止和等待终止**

## 2.1 进程标识

- 每个进程都有一个非负整型表示的唯一进程ID
- 进程ID是可复用的。但采用延时复用算法，使得赋予新建进程的ID不同于最近终止进程所使用的ID。防止将新进程误认为是使用同一ID的某个已终止的先前进程。
- 系统中保留的ID值：
  - 0：调度进程，也被称为交换进程，并不执行磁盘上的程序，是内核中的系统进程
  - 1：init进程，在自举过程结束后由内核调用，该进程的程序文件在unix早期版本中是/etc/init，在较新版本中是/sbin/init，负责在自举内核后启动Unix系统。进行系统的初始化，将系统引导到一个状态，该进程绝不会终止，是一个普通的用户进程，但是以超级用户特权运行，是所有孤儿进程的父进程
  - 2: 在有些UNIX的虚拟存储器实现中，2号进程ID是页守护进程，负责支持虚拟存储器系统的分页操作

```c
#include <unistd.h>
pid_t getpid(void);  //进程ID
pid_t getppid(void); //父进程ID
uid_t getuid(void);  //实际用户ID
uid_t geteuid(void); //有效用户ID
gid_t getgid(void);  //实际组ID
gid_t getegid(void); //有效组ID
//没有出错返回
```

### 更改用户ID和更改组ID

- 特权以及访问控制是基于用户ID和组ID的
  - 当程序需要增加特权或者需要访问当前并不允许访问的资源时，需要更换自己的用户ID或组ID,使新ID具有合适的特权或访问权限
  - 当程序需要降低特权，或阻止对某些资源的访问时，也需要更换用户ID或组ID，新ID不具有相应特权或访问这些资源的能力
- 最小特权模型：程序应该只具有为完成给定任务所需的最小特权

```c
#include <unistd.h>
int setuid(uid_t uid); //设置用户ID
int setgid(gid_t gid); //设置组ID
//成功返回0，失败返回-1
```

- 若进程拥有超级用户特权，则setuid函数将实际用户ID,有效用户ID以及保存的设置用户ID设置为uid
- 若进程没有超级用户特权，但是uid等于实际用户ID或保存的设置用户ID,则setuid只能将有效用户ID设置为uid，不更改实际用户ID和保存的设置用户ID
- 若上述两个条件都不满足，则出错返回-1，并将errno设置为EPERM


- **只有超级用户进程可以更改`实际用户ID`**。通常，`实际用户ID`是在用户登录时，由`login(1)`程序设置的，而且绝不会改变它。因为`login`是一个超级用户进程，当它调用`setuid`时，设置所有3个`用户ID`
- **仅当对程序文件设置了`设置用户ID位`时，`exec`函数才设置`有效用户ID`**。如果`设置用户ID位`没有设置，则`exec`函数不会改变`有效用户ID`，而是维持其现有值
    - 任何时候都可以调用`setuid`将`有效用户ID`设置为`实际用户ID`或者`保存的设置用户ID`
    - 调用`setuid`时，`有效用户ID`不能随意取值，只能从`实际用户ID`或者`保存的设置用户ID`中取得
- **`保存的设置用户ID`是由`exec`复制`有效用户ID`而得到**。如果设置了文件的`设置用户ID位`，则`exec`根据文件的`用户ID`设置了进程的`有效用户ID`之后，这个副本就保存起来


### 用户标识

```c
#include <unistd.h>
char* getlogin(void);
// 成功返回指向登录名字符串的指针，失败返回`NULL`
```
- 如果调用此函数的进程没有连接到用户登录时所用的终端，则函数会失败。比如守护进程
  
## 2.2 创建新进程

### fork函数

```c
#include <unistd.h>
pid_t fork(void);
//子进程返回0,父进程返回子进程ID,出错返回-1
```

- fork的使用用途
  - 一个父进程希望复制自己，使父进程和子进程同时执行不同的代码片段
  - 一个进程要执行一个不同的程序，子进程从fork返回后立即调用exec
- 由fork创建的新进程被称为子进程，fork函数被调用一次但是返回两次
  - 父进程返回子进程ID：原因是，一个进程的子进程可以有多个，并且没有一个函数使一个进程可以获得其所有子进程的进程ID
  - 子进程返回0：原因是，子进程总是可以调用`getppid`获得父进程的ID（0号进程总是由内核交换进程使用，所以一个子进程的进程ID不可能为0）
- 子进程和父进程继续执行fork调用后的指令，但是谁先执行是不确定的
- fork失败的原因
  - 系统已经有了太多的进程
  - 实际用户的进程总数超过了系统的限制（`CHILD_MAX`规定了每个实际用户在任一时刻拥有的最大进程数）
  
#### 子进程和父进程的数据共享

- 子进程获得父进程的**数据段**、**栈**和**堆**的完全副本。现在都使用**写时复制技术**。一开始这些区域由子进程和父进程共享，只有其中任意一个试图修改这些区域时，才会真正的复制出一个副本
- fork会使父进程的所有打开的文件描述符都被复制到子进程，父进程和子进程每个相同的打开描述符共享一个文件表项，也即共享文件偏移量，文件状态位置和节点指针。这就导致如果子进程和父进程同时写同一描述符指向的文件，如果没有确定形式的同步，输出是会相互混合的。常见处理方式是：
  - 父进程等待子进程完成后再运行
  - 父进程和子进程各自执行不同的程序段
- fork与标准IO函数。如果在fork前，有数据写到缓冲区且并未冲洗，fork之后子进程和父进程都会写入该数据一次。因为缓冲区中的数据也会被复制到子进程中。
- 子进程继承的父进程属性
  - 实际用户ID,有效用户ID,实际组ID,有效组ID
  - 附属组ID
  - 进程组ID
  - 会话ID
  - 控制终端
  - 设置用户ID标志和设置组ID标志
  - 当前工作目录
  - 根目录
  - 文件模式创建屏蔽字
  - 信号屏蔽和安排
  - 对任一打开文件描述符的执行时关闭标志，close on exec
  - 环境
  - 连接的共享存储段
  - 存储印象
  - 资源限制
- 父进程和子进程的不同
  - fork返回的值不同
  - 进程ID不同
  - tms_utime,tms_stime,tms_cutime,tms_ustime被设置为0
  - 不继承父进程设置的文件锁
  - 未处理闹钟被清除
  - 未处理信号集设置为空集


### vfork函数

- 不建议在可移植的应用程序中使用这个函数
- 目的是用于创建一个新进程，而该新进程的目的是exec一个新程序
- 和fork区别
  - vfork并不复制父进程的地址空间，因为认为子进程会立即调用exec，因此在子进程调用exec之前，它在父进程的空间中运行，如果这时子进程修改数据、进行函数调用等会造成未知的后果
  - vfork会保证子进程先运行，当子进程调用exec或exit后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖父进程的进一步动作，会导致死锁。

### 竞争条件

**竞争条件是多个进程企图对共享数据进程某种处理，最终结果取决于进程运行的顺序**

- 如果fork之后的某种逻辑显示或隐式地依赖于在fork之后是父进程先运行还是子进程先运行，那么fork就会是竞争条件活跃的滋生地
- 防止竞争条件最简单的手段：
  - 父进程可以通过`wait`等待子进程先运行完
  -  子进程可以通过下列方式等待父进程先运行结束，但是这种轮询方式会大量浪费CPU浪费
    ```
    while(getppid() != 1)
        sleep(1);
    ```
- 好的办法是使用信号进行通信，或者使用IPC

### exec函数

- 用fork创建新进程，用exec函数执行新的程序，用exit和wait处理终止和等待终止
- 调用exec函数后，进程执行的程序被完全替换成新程序，并从其main函数开始执行
- 并不是创建新进程，所以**前后的进程ID并未改变**，只是用一个新程序替换了当前进程的正文段，数据段，堆和栈

```c
#include <unistd.h>
int execl(const char *pathname, const char *arg0, ..., (char *)0);
int execv(const char *pathname, char * const argv[]);
int execle(const char* pathname,const char *arg0, ..., (char *)0, char* const envp[]);
int execve(const char *pathname, char * const argv[],char* const envp[]);
int execlp(const char *filename,const char *arg0, ..., (char *)0);
int execvp(const char *filename, char *const argv[]);
int fexecve(int fd, char *const argv[], char *const envp[]);
//出错返回-1，成功不返回
```

- 共有7种函数，前4个取路径名为参数，后两个取文件名作为参数（p结尾），最后一个取文件描述符作为参数（f开头）
- 用文件名作为参数时：
  - 如果filename中包含/，就将其视为路径名
  - 否则就按PATH环境变量，在它所指定的各目录中搜寻指定的可执行文件，即在PATH环境变量中查找第一个包含filename的可执行文件的路径前缀。
  > PATH变量包含了一张目录表,称为路径前缀，目录之间用冒号分隔。零长前缀也表示当前目录。
  > PATH为name=value的格式
- l表示List, execl, execlp和execle，要求将新程序的每个命令行参数都说明为一个单独的参数，并以空指针结尾
  - 如果用常量0来表示一个空指针，则必须转换成（char *）0, 否则会被解释成整型参数
- v表示vector,execv,execvp,execve,execve则应先构造一个指向各参数的指针数组，然后将该数组地址作为这四个函数的参数
- e表示环境表，以e结尾的execve,execle,fexecve可以传递一个指向环境字符串指针数组的指针。其他4个函数则使用调用进程中的environ变量为新程序复制现有的环境
- 只有execve是内核的系统调用，其他6个只是库函数，最终都要调用execve
  - fexecve使用/proc把文件描述符参数转换成路径名
- 执行`exec`后，进程ID没有改变。新程序从调用进程继承了下列属性：
  - 进程ID和父进程ID
  - 实际用户ID和实际组ID
  * 附属组ID
  * 进程组ID
  * 会话ID
  * 控制终端
  * 闹钟尚余留的时间
  * 当前工作目录
  * 根目录
  * 文件模式创建屏蔽字
  * 文件锁
  * 进程信号屏蔽
  * 未处理信号
  * 资源限制
  * nice值
  * tms_utime、tms_stime、tms_cutime以及tms_cstime值
- 进程中每个打开的文件描述符都有一个执行时关闭标志(FD_CLOEXEC)。若设置了此标志，则执行`exec`时会关闭该文件描述符；否则该文件描述符仍然保持打开。**系统默认行为是不设置执行时关闭标志**
- 进程的 `实际用户ID` 和 `实际组ID` 不变，`有效用户ID` 和 `有效组ID` 是否改变取决于所执行程序文件的`设置用户ID位`和`设置组ID位`是否设置
  - 1）若新程序的`设置用户ID位`已设置，则`有效用户ID`变成`程序文件所有者的ID`；2）否则`有效用户ID`不变
  - 2）若新程序的`设置组ID位`已设置，则`有效组ID`变成`程序文件所有组的ID`；2）否则`有效组ID`不变
  
## 2.3 进程终止

- 有8种方式可导致进程终止，其中5种为正常终止，分别为  
  1. 从main返回，执行return，等效于调用exit
  2. 调用exit，调用各终止处理程序，然后关闭所有标准IO流
  3. 调用_exit或_Exit，直接终止，不运行终止处理程序，也不冲洗标准IO流
  4. 最后一个线程从其启动例程返回[详情](./线程.md/#终止线程)，这种情况下进程的终止状态总是为0
  5. 从最后一个线程调用pthread_exit，同样这种情况下进程的终止状态总是为0
- 还有3种为异常终止，分别为  
  1. 调用abort，产生SIGABRT信号  
  2. 接到一个信号，信号可由进程自身，其他进程或内核产生  
  3. 最后一个线程对取消请求做出响应，详细说明见  
- **父进程在子进程之前终止**: 该进程的所有子进程会变成**孤儿进程**，同时子进程的父进程会被改变为init进程。操作过程是：在一个进程终止时，内核逐个检查所有的活动进程，判断它是否是正要终止进程的子进程，如果是，就将该进程的父进程ID改为1，保证每个进程都有一个父进程
- **子进程在父进程之前终止**: 内核会为每个终止子进程保存一定量的信息，当其父进程调用wait或waitpid时，可以获得这些信息，包括进程ID,进程的终止状态以及该进程使用的CPU时间总量。一个已经终止，但父进程尚未对其进行梳理的进程被称为僵死进程，ps命令将僵死进程的状态打印为Z
- **init进程收养的进程**: 不会变成僵死进程，init无论何时只要有一个子进程终止，就会调用一个wait函数取得其终止状态
- 如果一个进程fork一个子进程，但不要它等待子进程终止，也不希望子进程处于僵死状态直到父进程终止。实现这一要求的方法是调用fork两次，让第一个子进程调用第二次fork后exit。

### exit函数

```c
#include <stdlib.h>
void exit(int status);
void _Exit(int status);
#include <unistd.h>
void _exit(int status);
```

- _exit和_Exit不执行标准IO的缓冲区冲洗操作，立即进入内核
- exit会冲洗缓冲区，并关闭IO流，对所有打开流调用fclose函数，然后进入内核
- status是程序终止状态，在shell中用`echo $? `查看程序终止状态,同时该终止进程的父进程都能用wait或waitpid函数取得其终止状态
  - 下列情况的终止状态是未定义的
    - 调用这三个函数时不带终止状态
    - main函数执行了一个无返回值的return语句
    - main没有声明返回类型为整型
  - 若main的返回类型是整型，并且main执行到最后一条语句时返回，那么终止状态为0
  - 在LINUX中，退出状态码最高是255，一般自定义的代码值为0~255，如果超出255，则返回取模后的值
- 子进程可通过传入退出状态通知其父进程它是如何终止的，父进程可用wait和waitpid获得子进程的退出状态

### 终止处理程序

- 按照ISO C的规定，一个进程可以登记最多32个函数（通常操作系统会提供多于32个的限制。可以用`sysconf`函数查询这个限制值），这些函数将由`exit`函数自动调用。这些函数称作终止处理程序
```c
#include <stdlib.h>
int atexit(void (*func)(void));
//成功返回0，出错返回非0
```
- 登记函数的终止处理程序，参数是函数指针，参数类型和返回类型都是void
- 进程调用exit后，exit会先调用这些终止处理程序，调用的顺序和登记时候的顺序相反，随后关闭所有的打开流（fclose)。
- 如果同一个终止处理程序被登记多次，则它也会被调用多次
- 调用了_exit或_Exit后会清除所有已安装的终止处理程序

### wait函数

* 当一个进程终止时，内核会向其父进程发送SIGCHLD信号。父进程可以忽略该信号，也可以提供一个信号处理程序。系统的默认动作的忽略它。

```c
#include <sys/wait.h>
pid_t wait (int *stat)；
pid_t waitpid(pid_t pid, int *stat, int option);
//成功返回进程ID,出错返回0或-1
int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
//成功返回0，出错返回-1
```

- 终止进程的终止状态存放在stat指向的地址中，如果不关心终止状态，可以将stat指定为空指针，可用宏来判断stat来得到进程终止的原因
  - `WIFEXITED(stat)`,若为正常终止则为真，并可以用`WEXITSTATUS(stat)`获得子进程传递给exit参数的低8位
  - `WIFSIGNALED(stat)`, 若为异常终止则为真，并可用`WTERMSIG(stat)`获得使子进程终止的信号编号
  - `WCOREDUMP(stat)`, 若产生了core文件则为真
  - `WIFSTOPPED(stat)`，若为当前暂停子进程的返回状态，则为真,并可用`WSTOPSIG(stat)`获得使子进程暂停的信号编号
  - `WIFCONTINUED(stat)`，若为在作业控制暂停后已经继续进程的子进程返回了状态，则为真
- waitpid中pid的取值
  - pid==-1，等待任一子进程，等同于wait
  - pid>0，等待进程ID与pid相等的子进程
  - pid==0，等待组ID等于调用进程组ID的任一子进程
  - pid<-1，等待组ID等于pid绝对值的任一子进程
  - 当指定的进程或进程组不存在，或者不是调用进程的子进程时，会出错
- option控制着waitpid的操作，取值为 0或下列常量 按位或运算的结果
  - `WCONTINUED`,若实现支持作业控制，那么由pid指定的任一子进程在停止后已经继续，但其状态尚未报告，则返回其状态
  - `WNOHANG`, 当由pid指定的子进程并不是立即可用时，不阻塞，直接返回0
  - `WUNTRACED`,若实现支持作业控制，那么由pid指定的任一子进程已处以停止状态，并且其状态自停止以来还未报告过，则返回其状态。
- 调用函数可能出现的状态
  - 如果其所有子进程都还在运行，则阻塞，直到一个子进程终止
  - 如果有一个子进程已终止，则取得该子进程的终止状态后返回
  - 如果没有任何子进程，则立即出错返回
- waitid中参数的可能取值
  - idtype的值控制着id的参数的含义
    - P_PID，等待一特定进程：id包含要等待子进程的进程ID
    - P_PGID，等待一特定进程组中的任一子进程：id包含要等待子进程的进程组ID
    - P_ALL，等待任一子进程，忽略id
  - options参数是下列标志的按位或运算(前三个常量必须包含一个)
    - `WCONTINUED`,等待一进程，它以前曾被停止，此后又已继续，但其状态尚未报告
    - `WEXITED`，等待已退出的进程
    - `WSTOPPED`,等待一进程，它已经停止，但其状态尚未报告
    - `WNOHANG`，如无可用的子进程退出状态，立即返回而非阻塞
    - `WNOWAIT`，不破坏子进程的退出状态，该子进程的退出状态可由后续的wait系列函数取得
  - infop参数包含了造成子进程状态改变有关信号的详细信息

```c
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/time.h>
#include <sys/resource.h>

pid_t wait3(int *statloc, int options, struct rusage *resuage);
pid_t wait4(pid_t pid, int *statloc, int options, struct rusage *rusage);
// 成功返回进程ID,出错返回-1
```

- 可以返回由终止进程及其子进程使用的资源概况
- 资源统计信息包括有用户CPU时间总量，系统CPU时间总量，缺页次数，接收到信号的次数等

## 2.4 解释器文件

- 是一个文本文件，其起始行是 `#! pathname[optional_argument]`，感叹号和pathname之间的空格是可选的，例如`#! /bin/sh`
- pathname通常是绝对路径名
- 内核使调用exec函数的进程执行的并不是该解释器文件，而是在该解释器文件第一行中pathname所指定的文件
  - 解释器文件
  - 解释器，由解释器文件第一行中的pathname指定的文件
- 用exec函数执行一个解释器文件时，argv[0]是该解释器的pathname，argv[1]是解释器文件中的可选参数，argv[2]是exec函数中的pathname/filename,最后是exec第2个参数之后的所有参数（第一个参数被忽略）
  - 用exec函数中的pathname/filename而不用第一个参数的原因是，一般而言pathname/filename包含了比第一个参数更多的信息

## 2.5 system函数

- `system`用于将一个字符串作为命令来执行(在shell中执行)，调用/bin/sh执行字符串
```c
#include <stdlib.h>
int system(const char* cmdstring);
```
- `cmdstring`：命令字符串（在`shell`中执行），如 `"ps -aux"`（如果`cmdstring`为空指针，则如果`system`返回 0 表示该操作系统不支持`system`函数；否则支持）
- `system`等同于同时调用了`fork、exec、waitpid`，有3种返回值：
  - `fork`失败或者`waitpid`返回除`EINTR`之外的错误，则`system`返回 -1，并且设置`errno`以指示错误类型
    - 如果waitpid被一个捕捉到的信号中断，则会返回EINTER,但是没有可用的策略的能让应用程序冲这种错误类型中恢复
  - 如果`exec`失败(表示不能执行`shell`)，则其返回值如同`shell`执行了`exit(127)`一样
  - 如果三个函数都执行成功，则`system`返回值是`shell`的终止状态，其格式在`waitpid`中说明
- `system` VS `fork + exec`：
  - **优点**：`system`进行了所需的各种出错处理以及各种信号处理
  - **缺点**：一旦调用`system`的进程具有超级用户权限，则`system`执行的命令也具有超级用户权限。因为`system`的实现过程中并没有更改`有效用户ID`和`实际用户ID`的操作
    - 因此如果一个进程以特殊的权限运行，而它又想生成另一个进程执行另外一个程序，则它应该直接使用`fork + exec`并且在`fork`之后，`exec`之前改回普通权限
    - 设置用户`ID`和设置组`ID`程序绝不应该调用`system`函数
    - 有些实现通过更改/bin/sh，当有效用户id与实际用户id不匹配时，将有效用户id设置为实际用户id
    - 
## 2.6 进程会计

## 2.7 进程调度

- 进程可以通过调整`nice`值选择以更低优先级运行，只有特权进程允许提高调度权限
  - `nice`值的范围在`0~(2*NZERO)-1`之间，有些实现支持`0~2*NZERO`（`NZERO`是系统默认的`nice`值）
  - `nice`值越低，优先级越高
```c
#include <unistd.h>
int nice(int incr);
#include <sys/resource.h>
int getpriority(int which,id_t who);
int setpriority(int which, id_t who, int value);
```
- 进程可以通过`nice`函数**获取或更改**它的`nice`值，进程只能影响自己的`nice`值，不能影响任何其他进程的`nice`值：
  - `incr`：`nice`值的增量。如果太小或太大，系统会修改到边界值（为0时，`nice`值不变，因此可以用以获取当前`nice`值）
  - 成功返回新的nice值，出错会返回-1。但是正常返回也可能是-1，所以调用前要清除errno，并在返回值为-1时检查errno是否为0
- `getpriority`函数可以像`nice`函数那样用于获取进程的`nice`值，但是它还可以获取一组相关进程的`nice`值
  - `which`：控制`who`参数是如何解释的。可以取三个值之一：
    - `PRIO_PROCESS`：表示进程
    - `PRIO_PGRP`:表示进程组
    - `PRIO_USER`表示用户`ID`
  - `who`：选择感兴趣的一个或者多个进程
    - 如果`who`为0，`which`为`PRIO_PROCESS`，返回当前进程的`nice`值
    - 如果`who`为0，`which`为`PRIO_PGRP`，则返回进程组中最小的`nice`值
    - 如果`who`为0，`which`为`PRIO_USER`，则返回调用进程的实际用户`ID`拥有的那些进程中最小的`nice`值
- `setpriority`函数可用于为进程、进程组和属于特定用户ID的所有进程设置优先级
  - `which`和`who`与getpriority函数中相同
  - `value`：nice值的增量
  
## 2.7 进程时间

- 任一进程可调用`times`函数获得它自己以及已终止子进程的**墙上时钟时间**、**用户CPU时间**、**系统CPU时间**
```c
#include <sys/times.h>
clock_t times(struct tms *buf);
struct tms{
    clock_t tms_utime;  /* 用户CPU时间 */
    clock_t tms_stime;  /* 系统CPU时间 */
    clock_t tms_cutime; /* 已终止子进程的用户CPU时间 */
    clock_t tms_cstime; /* 已终止子进程的系统CPU时间 */
};
```

- 成功返回流逝的墙上时钟时间,以时间滴答数为单位，若出错，返回-1
  - 这个值是相对于过去的某一时刻度量的，所以不能用其绝对值而必须使用相对值。例如，调用`times`，保存其返回值。在以后某个时间再次调用`times`，从新返回的值中减去以前返回的值，此差值就是墙上时钟时间（一个长期运行的进程可能其墙上时钟时间会溢出，当然这种可能性极小）
- 同时填写由`buf`指向的`tms`结构
  - 结构中两个针对子进程的字段包含了此进程用`wait`函数族已等待到的各子进程的值
- 所有由此函数返回的`clock_t`值都可先用`sysconf(_SC_CLK_TCK)`获得每秒时钟滴答数然后除以该值转换成秒数
  
# 3. 进程关系

## 3.1 终端登录 

## 3.2 网络登录

## 3.3 进程组

- 进程组是一个或多个进程的集合，这些进程通常是在同一作业中结合起来的，同一进程组中的各进程接受来自同一终端的信号。
- 每个进程组都有一个唯一的进程组ID,是一个正整数，可存放在pid_t数据类型中
- 每个进程组有一个组长进程，组长进程的进程ID等于进程组ID
- 进程组的生命期从进程组创建开始到其中最后一个进程离开，组长进程的存在与否并不关系到进程组的存在与否，

```c
#include <unistd.h>
pid_t getpgrp(void); //返回调用进程的进程组ID
pid_t getpgid(pid_t pid); //成功返回pid进程的进程组ID，pid为0时返回调用进程的进程组ID,出错返回-1
int setpgid(pid_t pid, pid_t pgid); //加入一个现有的进程组或者创建一个新进程组，成功返回0，出错返回-1

```
- setpgid函数将pid进程的进程组ID设置为pgid
  - 如果这两个参数相等，则由pid指定的进程变成进程组组长
  - 如果pid是0，则使用调用者的进程ID
  - 如果pgid是0，则由pid指定的进程ID用作进程组ID
- 一个进程只能为它自己或它的子进程设置进程组ID,并且在它的子进程调用exec后，它就不能再更改该子进程的进程组ID了
- 一般在实际应用中，在fork后，父进程和子进程都会调用setpgid函数设置一下子进程的进程组ID，因为父进程和子进程运行的先后顺序不一样，在两个进程都设置才能保证成功

## 3.4 会话

- 会话(session)是一个或多个进程组的集合，这些进程组共享一个控制终端，而这个控制终端通常是创建第一个进程的登录终端
- 会话首进程的ID被视为会话ID（会话首进程是创建该会话的进程）

```c
#include <unistd.h>
pid_t setsid(void); //成功返回进程组ID,出错返回-1
pid_t getsid(pid_t pid);

```

- 进程调用setsid函数建立一个新会话
  - 如果调用setsid的进程不是一个进程组的组长，则此函数会创建一个新会话，发生以下步骤
    - 该进程变成新会话的会话首进程，此时该进程是新会话中的唯一进程
    - 该进程称为一个新进程组的组长进程，新进程组ID就是该调用进程的进程ID
    - 该进程没有控制终端，如果在调用setsid之前该进程有一个控制终端，那么这种联系也被切断。
      - 但是在某些系统中，当会话首进程打开一个尚未与任何会话相关联的终端设备时，此设备会自动作为控制终端分配给该会话。
  - 如果是一个进程组的组长，则调用setsid会返回出错。
    - 为了避免这种状况，通常是先调用fork,然后使其父进程终止，在子进程中调用这个函数。因为子进程继承了父进程的进程组ID,而其新进程ID是新分配的，两者不可能相等，保证了子进程不是一个进程组的组长
- getsid返回会话首进程的进程组ID
  - 如果pid是0，返回调用进程的会话首进程的进程组ID
  - 如果pid并不属于调用者所在的会话，则返回出错，返回-1
  
## 3.5 控制终端

- 一个会话可以有一个**控制终端**，这通常是终端设备或者伪终端设备（在网络登录的情况下）
- 建立与控制终端连接的会话首进程被称为**控制进程**
- 一个会话中的几个进程组可被分为一个**前台进程组**和若干个**后台进程组**
  - 如果一个会话有一个控制终端，则它有一个前台进程组，其他进程组为后台进程组
  - 键入终端的中断键(通常是Delete或Ctrl+C)，会发生中断信号到前台进程组的所有进程
  - 键入终端的退出键(通常是Ctrl+\\)，会发送退出信号到前台进程组的所有进程
  - 如果终端接口检测到调制解调器（或网络）断开连接，会发送挂断信号给控制进程(会话首进程)
- 分配控制终端的两种方式
  - 当会话首进程打开第一个尚未与一个会话相关联的终端设备时，只要在调用open时没有指定O_NOCTTY标志，就会将此作为控制终端分配给此会话
  - 用TIOCSCTTY作为request参数（第三个参数是空指针）调用ioctl时，会为会话分配控制终端
    - 为此调用成功，此会话不能已经有一个控制终端，因此ioctl通常在setsid之后立即调用

```c
#include <unistd.h>
pid_t tcgetpgrp(int fd);
int tcsetpgrp(int fd, pid_t pgrpid);
#include <termios.h>
pid_t tcgetsid(int fd);
// 出错返回-1
```
- tcgetpgrp返回前台进程组ID,它与在fd上打开的终端相关联
- 如果进程有一个控制终端，则该进程可以调用tcsetpgrp将前台进程组ID设置为pgrpid
  - pgrpid应该是在同一会话中的一个进程组ID
  - fd必须引用该会话的控制终端
- 大多数应用程序不直接调用这两个函数，通常由作业控制shell调用
- 给出控制TTY的文件描述符，通过tcgetsid函数可以获得会话首进程的进程组ID

## 3.6 作业控制

- 允许在一个终端上启动多个作业（进程组），控制哪一个作业可以访问该终端以及哪些作业在后台运行
- 控制作业要求以下三种形式的支持
  - 支持作业控制的shell
  - 内核中的终端驱动程序必须支持作业控制
  - 内核必须提供对某些作业控制信号的支持


## 3.7 shell执行程序





# 4. 守护进程

## 4.1 守护进程的特征

* 后台运行
* 没有控制终端
* 生存期长，常常在系统引导装入时启动，仅在系统关闭时终止
* 周期性地执行某项任务或等待某些发生地事件

## 4.2 守护进程的编程规则

1. 调用umask将文件模式创建屏蔽字设置为一个已知值(通常是0)
   - 由继承而来的文件模式创建屏蔽字可能会被设置为拒绝某些权限，如果守护进程要创建文件，那么它可能要设置特定的权限
2. 调用fork，然后使父进程exit。这样做实现了以下几点
   - 如果该守护进程是作为一条简单的shell命令启动的，那么父进程终止会让shell认为这条命令已经执行完毕
   - 子进程继承了父进程的进程组ID,但获得了一个新的进程ID,保证了子进程不是一个进程组的组长进程，是下面调用setsid的先决条件
3. 调用setsid创建一个新会话。使调用进程成为新会话的首进程，成为新进程组的组长进程并且没有控制终端。
   - 但是在某些系统中，当会话首进程打开一个尚未与任何会话相关联的终端设备时，此设备会自动作为控制终端分配给该会话。这种情况下，可以再次调用fork,终止子进程，在孙子进程中创建守护进程，保证该守护进程不是会话首进程，防止它取得控制终端。
   - 还需要注意在会话首进程退出时，会对其所在会话的所有进程发送SIGHUP信号，而SIGHUP信号的默认处理函数结束进程。因此在孙子进程中需要忽略这一信号。
   - 还有一种方法是无论何时打开一个终端设备都一定要指定O_NOCTTY。
4. 将当前工作目录更改为根目录
   - 从父进程处继承过来的当前工作目录可能在一个挂载的文件系统中，因为守护进程通常在系统再引导之前是一直存在的，所以如果守护进程的当前工作目录在一个挂载文件系统中，那么该文件系统就不能被卸载。
5. 关闭不再需要的文件描述符。使守护进程不再持有从其父进程继承来的任何文件描述符
   - 可以用open_max函数或者getrlimit函数来判断最高文件描述符值，并关闭直到该值的所有描述符
6. 打开/dev/null使其具有文件描述符0、1、2，这样任何一个试图读标准输入、写标准输出或标准错误的库例程都不会产生任何效果
   - 不希望在终端上见到守护进程的输出
   - 也不希望在终端上的输入被守护进程读取







# 5. 进程间通信IPC

IPC(InterProcess Communication)

## 5.1 管道

1. 历史上，是**半双工**（即数据只能在一个方向上流动）的。虽然现在某些系统提供全双工管道，但是为了最佳移植性，不应预先假定系统支持全双工管道
2. 管道**只能在具有公共祖先的两个进程间使用**（通常，一个管道由一个进程创建，在进程调用fork之后，这个管道就能在父进程和子进程之间使用了

尽管有上述局限，半双工管道仍是最常用的IPC形式。每当在管道中键入一个命令序列，让shell执行时，shell都会为每一条命令单独创建一个进程，然后用管道将前一条命令进程的标准输出与后一条命令的标准输入相连接

```c
#include <unistd.h>
int pipe(int fd[2]);
//成功返回0，出错返回-1
```

- 通过参数fd返回两个文件描述符
  - fd[0]为读而打开，对其调用read,从fd[0]中读出数据
  - fd[1]为写而打开，对其调用write，往fd[1]中写数据
  - fd[1]的输出是fd[0]的输入，数据从fd[1]流入fd[0]
  - 对于支持全双工管道的实现，fd[0]和fd[1]以读/写方式打开
- 应用场景通常是：进程先调用pipe,接着调用fork,从而创建从父进程到子进程的IPC通道
  - 对于从父进程到子进程的管道，父进程关闭管道的读端(fd[0]),子进程关闭管道的写端(fd[1])
  - 对于从子进程到父进程的管道，父进程关闭管道的写端(fd[1]),子进程关闭管道的读端(fd[0])
- 读一个写端已关闭的管道时，在所有数据读取后，read返回0，表示文件结束
  - 从技术上讲，如果管道的写端还有进程，就不会产生文件的结束。
  - 可以复制一个管道的描述符，使得有多个进程对它具有写打开文件描述符。但是，通常一个管道只有一个读进程和一个写进程
- 写一个读端已关闭的管道时，会产生信号SIGPIPE,write会返回-1，errno设置为EPIPE
- 常量PIPE_BUF规定了内核的管道缓冲区的大小，写管道时写的字节应该小于等于这个值（FIFO也适用于这个规则）
  - 如果对管道调用write。而且要求写的字节数小于等于`PIPE_BUG`，则此操作不会与其他进程对同一管道的write操作交叉进行。
  - 但是，若有多个进程同时写一个管道，而且我们要求写的字节数超过`PIPE_BUF`，那么所写的数据可能会与其他进程所写的数据相互交叉。
  - 用`pathconf`或`fpathconf`函数可以确定`PIPE_BUF


```c
#include <stdio.h>
// 成功返回文件指针，出错返回NULL
FILE *popen(const char *cmdstring, const char *type);
// 成功返回cmdstring的终止状态，出错返回-1
int pclose(FILE *fp);
```

- 标准IO库提供的管道函数，所以用FILE结构
- `popen`：先执行fork，然后调用exec执行cmdstring，并且返回一个标准I/O文件指针
  - type只能是r或w
  - 如果type是`r`：返回的文件指针是可读的，即文件指针连接到cmdstring的标准输出
  - 如果type是`w`：返回的文件指针是可写的，即文件指针连接到cmdstring的标准输入
- `pclose`：关闭标准I/O流，等待命令终止，然后返回shell的终止状态
  - 如果shell不能被执行，则返回的终止状态与shell已执行exit(127)一样
- cmdstring由shell以`sh -c cmdstring`的方式执行，表示shell将扩展cmdstring中的任何特殊字符
  - 例如：fp=popen("ls *.c","r");,fp=fopen("cmd 2>&1","r");
- popen绝不应由设置用户ID或设置组ID程序调用，可能会使得shell能以设置ID文件模式所授予的提升了的权限以非预期的方式执行命令
- popen特别适用于执行简单的过滤器程序，变换运行命令的输入或输出

### 协同进程

- UNIX系统过滤程序从标准输入读取数据，向标准输出写数据。几个过滤程序通常在shell管道中线性连接。**当一个过滤程序既产生某个过滤程序的输入，又读取该过滤程序的输出时，它就变成了协同进程**
  - `popen`只提供连接到另一个进程的标准输入或标准输出的一个单向管道
  - 而协同进程则有连接到另一个进程的两个单向管道：一个连接到其标准输入，另一个则来自其标准输出。我们想将数据写到其标准输入，经其处理后，再从标准输出读取数据
- 
## 5.2 FIFO

- FIFO有时候被称为**命名管道**，和管道不同的是，它可以在不相关的进程间使用，不必具有继承关系
- `FIFO`是一种文件类型，通过`stat`结构的`st_mode`成员的编码可以知道文件是否是`FIFO`类型。可以用`S_ISFIFO`宏对此进行测试
- FIFO有以下2个**用途**：
  - shell命令使用FIFO将数据从一条管道传送到另一条时，无需创建中间临时文件
    - 管道只能用于两个进程之间的线性连接，而FIFO是有名字的，可以用于非线性连接
  - 客户进程-服务器进程应用程序中，FIFO用作汇聚点（多个客户进程向服务器同一个众所周知的FIFO写），在客户进程和服务器进程二者之间传递数据
```c
#include <sys/stat.h>
int mkfifo(const char *path, mode_t mode);
int mkfifoat(int fd, const char *path, mode_t mode);
// 成功返回0，出错返回-1
```
- 创建FIFO类似于创建文件。FIFO的路径名存在于文件系统中
- mkfifo中mode参数的规格说明与open函数中mode的相同
- `mkfifoat`：和`mkfifo`函数相似，但是该函数可以被用来在`fd`文件描述符表示的目录相关的位置创建一个FIFO
  - 如果指定的是绝对路径名，则`fd`参数会被忽略掉，并且`mkfifoat`函数的行为和`mkfifo`类似
  - 如果指定的是相对路径名，则`fd`参数是一个打开目录的有效文件描述符，路径名和路径有关
  - 如果指定的是相对路径名，并且`fd`参数有一个特殊值`AT_FDCWD`，则路径名以当前目录开始，`mkfifoat`和`mkfifo`类似
- 使用这两个函数创建FIFO时，要用`open`来打开它
  -  一般情况下，没有指定`O_NONBLOCK`时，只读`open`要阻塞到某个其它进程为写而打开这个FIFO为止。类似地，只写`open`要阻塞到某个其它进程为读而打开它为止
  -  如果指定了`O_NONBLOCK`，则只读`open`立即返回。但是，如果没有进程为读而打开一个FIFO，那么只写`open`将返回-1，并将`errno`设置成`ENXIO`
- 若`write`一个尚无进程为读而打开的FIFO，则产生信号`SIGPIPE`
- 若某个FIFO的最后一个写进程关闭了该FIFO，则将为该FIFO的读进程产生一个文件结束标志
- 一个给定的FIFO有多个写进程是常见的。这意味着，如果不希望多个进程所写的数据交叉，则必须考虑原子写操作。和管道一样，常量`PIPE_BUF`说明了可被原子地写到FIFO的最大数据量


## 5.3 XSI　IPC

- 有3种称作XSI IPC的IPC：**消息队列**、**信号量**、**共享存储**。
  
### 标识符和键

- 每个内核中的IPC结构（消息队列、信号量或共享内存）都用一个非负整数的**标识符**加以引用
- 与文件描述符不同，**IPC标识符**不是小的整数。当一个IPC结构被创建，然后又被删除时，与这种结构相关的标识符连续加1，直至到达一个整形数的最大正值，然后又回转到0
- **标识符是IPC对象的内部名**。为使多个合作进程能够在同一IPC对象上汇聚，需要提供一个外部命名方案。为此，**每个IPC对象都与一个键相关联，将这个键作为该对象的外部名**
  - 无论何时创建IPC结构时，应指定一个键
  - **键的类型是基本系统数据类型`key_t`**，通常在`<sys/types.h>`中被定义为长整形。这个键由内核变换成标识符

```c
#include <sys/ipc.h>
key_t ftok(const char *path, int id);
// 成功返回键，出错返回-1
```
### 权限结构

- 每个IPC结构关联了一个`ipc_perm`结构（`<sys/ipc.h>`），规定了权限和所有者，至少包括以下成员：
```c
struct ipc_perm{
    uid_t uid;      /* 拥有者的有效用户ID */
    gid_t gid;      /* 拥有者的有效组ID */
    uid_t cuid;     /* 创建者的有效用户ID */
    gid_t cgid;     /* 创建者的有效组ID */
    mode_t mode;    /* 访问模式 */
    ...
};
```

- 创建IPC结构时，对所有字段都赋初值
- IPC结构的创建者或超级用户可以调用`msgctl`、`semctl`或`shmctl`修改`uid`、`gid`和`mode`字段。
- 对于任何IPC结构都不存在执行权限
- 消息队列和共享内存使用术语”读“和”写“，信号量则用”读“和”更改“
- mode的可取值有
  - 用户读(0400)，用户写(0200)
  - 组读(0040)，组写(0020)
  - 其他读(0004)，其他写(0002)

### 优缺点

- **XSI IPC结构是在系统范围内起作用的，没有引用计数**
  - 不会因为最后一个使用IPC结构的进程终止而删除，它们会一直留在系统中直至一些删除事件发生
  - 作为对比，最后一个引用管道的进程终止时，管道就被完全删除了；对FIFO而言，最后一个引用的进程终止时，虽然FIFO的名字仍保留在系统中，直至被显示删除，但是留在FIFO中的数据已被删除了


## 5.4 消息队列

- 消息队列是消息的链接表，存储在内核中，由消息队列标识符标识
- 后文把消息队列简称为“队列”，把标识符简称为"队列ID"
  
- 每个队列都有一个`msqid_ds`结构与其关联，这个结构定义了队列的当前状态
```c
struct msqid_ds{
    struct ipc_perm    msg_perm;    /* 前文描述的IPC权限结构 */
    msgqnum_t          msg_qnum;    /* 队列中的消息数 */
    msglen_t           msg_qbytes;  /* 队列中消息的字节 */
    pid_t              msg_lspid;   /* 最后调用msgsnd()的进程ID */
    pid_t              msg_lrpid;   /* 最后调用msgrcv()的进程ID */
    time_t             msg_stime;   /* 最后调用msgsnd()的时间 */ 
    time_t             msg_rtime;   /* 最后调用msgrcv()的时间 */
    time_t             msg_ctime;   /* 最后一次修改队列的时间 */
    ...
};
```

```c
#include <sys/msg.h>
int msgget(key_t key, int flag);
```


### 与消息队列相关的函数

## 5.5 信号量

- 信号量是一个**计数器**，用于为多个进程提供对**共享数据对象**的访问
- 使用信号量时，为了获得共享资源，进程需执行下列操作
  - 测试控制该资源的信号量
  - 若此信号量的值为正，则进程可以使用该资源，并将信号量值减1，表示它使用了一个资源单位
  - 若此信号量的值为0，则进程进入休眠状态，直至信号量大于0
- 为了正确实现信号量，信号量值的测试及减1操作应当是原子操作。为此，信号量通常是在内核中实现的
- 常用的信号量形式被称为二元信号量，它控制单个资源，其初始值为1。但是一般而言，信号量的初值可以是任意一个正值，该值表明有多少个共享资源单位可供共享应用
- 下面的特性使得XSI信号量更复杂
  - 信号量并非是单个非负值，而必须定义为含有一个或多个信号量值的集合。当创建信号量时，要指定集合中信号量值的数量
  - 信号量的创建是独立于它的初始化的。这是一个致命缺点。因此不能原子地创建一个信号量集合，并且对该集合中的各个信号量赋初值
  - 即使没有进程正在使用各种形式的XSI IPC，他们仍然是存在的。有的程序在终止时并没有释放已经分配给它的信号量，我们不得不为这种程序担心
  
### 信号量的相关结构

- 内核为每个**信号量集合**维护着一个`semid_ds`结构

```c
struct semid_ds{
    struct ipc_perm sem_perm;   /* 前文描述的IPC权限结构 */
    unsigned short  sem_nsems;  /* 集合中的信号量数目 */
    time_t          sem_otime;  /* 最后一次调用semop()的时间 */
    time_t          sem_ctime;  /* 最后一次改变的时间 */
    ...
};
```

- **每个信号量**由一个无名结构表示，它至少包含下列成员：

```c
struct{
    unsigned short  semval;     /* 信号量的值，总是>=0 */
    pid_t           sempid;     /* 最后一个操作信号量的进程ID */
    unsigned short  semncnt;    /* 等待 semval>curval 的进程数 */
    unsigned short  semzcnt;    /* 等待 semval==0 的进程数 */
    ...
};
```

### 信号量的相关函数

```c
#include <sys/sem.h>
int semget(key_t key, int nsems, int flag);
int semctl(int semid, int semnum, int cmd, ..., union semun arg);
union semun{
  int             val;    /* for SETVAL */
  struct semid_ds *buf;   /* for ICP_STAT and IPC_SET */
  unsigned short  *array; /* for GETALL and SETALL */
};
int semop(int semid, struct sembuf semoparray[],size_t nops);
struct sembuf{
  unsigned short  sem_num;    /* 信号量集合中的某个信号量 */
  short           sem_op;     /* 操作 */
  short           sem_flg;    /* IPC_NOWAIT，SEM_UNDO */
};
```

- 调用semget获得一个信号量ID
  - `key`：创建IPC结构时需要指定一个键，作为IPC对象的外部名。键由内核转变成标识符
  - `nsems`：该信号量集合中的信号量数
    - 如果是创建新集合（一般在服务器进程中），则必须指定`nsems`
    - 如果是引用现有集合（一个客户进程），则将`nsems`指定为0
  -`flag`：权限位
  - 创建一个新集合时，需要初始化`semid_ds`结构的下列成员：
    - `ipc_perm`结构初始化。结构中的`mode`成员被设置为`flag`中的相应权限位
    - `sem_otime`设置为0
    - `sem_ctime`设置为当前时间
    - `sem_nsems`设置为`nsems`
- semctl包含了多种信号量操作
  - `semid`：信号量集合
  - `semnum`：信号量集合中的某一信号量，semnum的值在0和nsems-1之间，包括0和nsems-1
  - `cmd`：命令
        + `IPC_STAT`：获取信号量集合的`semid_ds`结构，存储在arg.buf指向的结构中
        + `IPC_SET`：按arg.buf指向的结构中的值设置集合`semid_ds`结构中的sem_perm.uid、sem_perm.gid和sem_perm.mode字段（此命令只能由下列2种进程执行：1）其有效ID等于sem_perm.cuid或sem_perm.uid；2）具有超级用户特权的进程；）
        + `IPC_RMID`：从系统中删除该信号量集合。这种删除是立即发生的。删除时仍在使用这一信号量集合的其它进程在他们下一次试图对此信号量集合进行操作时，将得到`EIDRM`错误（此命令只能由下列2种进程执行：1）其有效ID等于sem_perm.cuid或sem_perm.uid；2）具有超级用户特权的进程；）
        + `GETVAL`：返回`semnum`指定信号量的值
        + `SETVAL`：设置`semnum`指定信号量的值
        + `GETPID`：返回`semnum`指定信号量的`sempid`（最后一个操作信号量的进程ID）
        + `GETNCNT`：返回`semnum`指定信号量的`semncnt`
        + `GETZCNT`：返回`semnum`指定信号量的`semzcnt`
        + `GETALL`：取该集合中所有的信号量值。这些值存储在arg.array指向的数组中
        + `SETALL`：将该集合中所有的信号量值设置成arg.array指向的数组中的值
  - `semun`：可选参数，是否使用取决于命令`cmd`，如果使用则类型是联合结构`semun`
- 函数`semop`自动执行信号量集合上的操作数组






## 5.6 共享存储




# 6. 网络IPC