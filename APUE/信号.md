信号

-------------------------------------

- [1. 信号基本概念](#1-信号基本概念)
  - [1.1 信号的产生条件](#11-信号的产生条件)
  - [1.2 信号的处理方式](#12-信号的处理方式)
  - [1.3 信号的阻塞，可靠性](#13-信号的阻塞可靠性)
  - [1.4 常见的信号介绍](#14-常见的信号介绍)
- [2. 信号处理函数](#2-信号处理函数)
  - [2.1 signal函数](#21-signal函数)
    - [信号集及其相关函数](#信号集及其相关函数)
      - [信号屏蔽字](#信号屏蔽字)
    - [sigaction函数](#sigaction函数)
  - [能产生或发送信号的函数](#能产生或发送信号的函数)
    - [kill和raise函数](#kill和raise函数)
    - [alarm和pause函数](#alarm和pause函数)

# 1. 信号基本概念

- 信号是软件中断，提供了一种处理异步事件的方法
- 信号的名字都以SIG开头，在头文件<signal.h>中被定义为正整数常量
- 不存在信号位0的信号，kill函数对信号编号0有特殊的应用
  
## 1.1 信号的产生条件

1. 终端产生信号，例如Ctrl+c会产生中断信号SIGINT
2. 硬件异常产生信号，例如除数为0，无效的内存引用
3. 进程调用kill函数可将任意信号发送给另一个进程或进程组，接收信号进程和发送信号进程的所有者必须相同，或发送信号进程的所有者必须是超级用户
4. 用户可用kill命令将信号发送给其他进程
5. 当检测到某种软件条件发生，并应将其通知给有关进程时也会产生信号，例如SIGPIPE，在管道的读进程终止后，一个进程写此管道会产生

## 1.2 信号的处理方式

- 产生信号的时间对于进程而言是随机出现的，进程不能简单地测试一个变量来判断是否发生了一个信号，而是必须告诉内核“在此信号发生时，请执行下列操作”
- 有三种处理方式
  - 忽略信号。除了SIGKILL和SIGSTOP(这两信号向内核提供了使进程终止或停止的可靠方法)，其他信号都可以被忽略。此外如果忽略某些由硬件异常产生的信号，则进程的运行行为是未定义的
  - 捕捉信号。通知内核在某种信号发生时，调用一个用户函数，在函数中对这个事件进行处理。不能捕捉SIGKILL和SIGSTOP信号。
  - 执行系统默认动作。对大多数信号的系统默认动作是终止该进程

## 1.3 信号的阻塞，可靠性

- 一个信号的"生命周期"为：产生(generation)、未决(pending)、递送(delivery)
- 如果将信号设置为阻塞，那么，在信号产生和递送之间的时间间隔内，称信号是未决的(pending)。
- 如果信号被设置成阻塞，且该信号的动作是系统默认动作或捕获该信号，当该信号产生后，则进程将此信号的状态保持为未决(pending)状态,直到对该信号解除了阻塞或将该信号的动作改为忽略
- 内核在递送一个原来被阻塞的信号给进程时(而不是在产生该信号时)，才决定对它的处理方式，那么进程在信号递送给它之前仍可改变对该信号的动作
- 如果在进程解除对某个信号的阻塞之前，信号发送了多次，大多数unix系统不会信号排队，只递送该信号一次
- 如果有多种信号要递送给一个进程，则这些信号的递送顺序是不定的

## 1.4 常见的信号介绍

- 默认动作中的“终止+core”表示在进程当前工作目录的core文件中复制了该进程的内存映像。在调试程序时可以使用core文件检查进程终止时的状态。在下列条件下不产生core文件
  - 进程是设置用户ID的,而且当前用户并非程序文件的所有者
  - 进程是设置组ID的，而且当前用户并非该程序文件的组所有者
  - 用户没有写当前工作目录的权限
  - 文件已存在，用户对该文件没有写权限
  - 文件太大。

|名字|说明|默认动作|
|:----:|:---:|:---:|
**SIGABRT**|调用abort函数产生|终止+core
**SIGALRM**|调用alarm函数设置的定时器超时或setitimer函数设置的间隔事件超时|终止
SIGBUS|指示一个实现定义的硬件故障，出现某种类型的内存故障时产生|终止+core
SIGCANCEL|线程内部使用的信号|忽略
**SIGCHLD**|进程终止或停止时，发送给其父进程|忽略
SIGCONT|用于唤醒需要继续运行但当前处于停止状态的进程。如果接收到此信号的进程处于停止状态，则系统默认动作是使该进程继续运行，否则忽略它|
SIGEMT|指示一个实现定义的硬件故障|
SIGFPE|表示一个算数运算异常，例如除以0，浮点溢出|
SIGFREEZE|通知进程在冻结系统状态之前需要采取特定动作|
**SIGHUP**|（1）如果终端接口检测到一个连接断开，且终端的CLOCAL标志没有被设置，则发送给与该终端相关的控制进程（会话首进程）（2）如果会话首进程终止，也产生这个信号，发送给前台进程组中的每一个进程|
SIGILL|进程已执行一条非法硬件指令|
SIGINFO|当用户按状态键（一般为Ctrl+T）时。终端驱动程序会把这个信号发送到前台进程组中的每一个进程，会造成在终端上显示前台进程组中各进程的状态信息|
SIGINT|用户按中断键时(Delete或Ctrl+C)，终端驱动程序会把这个信号发送到前台进程组中的每一个进程|终止
SIGIO|指示一个异步IO事件|
SIGIOT|一个实现定义的硬件故障|
SIGJVM1|为Java虚拟机预留的一个信号|
SIGJVM2|为Java虚拟机预留的另一个信号|
**SIGKILL**|提供一种可以杀死任一进程的可靠方法|
**SIGPIPE**|（1）在管道的读进程已终止时写管道（2）当类型为SOCK_STREAM的套接字已不在连接时，进程写该套接字也产生此信号|

# 2. 信号处理函数

## 2.1 signal函数

  >因为signal函数的语义与实现有关，最好使用sigaction函数代替signal函数

```c
#include <signal.h>
void (*signal(int signo, void (*func)(int)))(int);
// 成功返回以前的信号处理配置，出错返回SIG_ERR
//或者简便写法
typedef void Sigfunc(int);
Sigfunc *signal (int, Sigfunc *);

#define SIGERR (void (*)()) -1
#define SIGDFL (void (*)()) 0
#define SIGIGN (void (*)()) 1
```

- signal函数有两个参数，返回一个函数指针，第一个参数是signo，表示信号名，第二个参数是函数指针，指向一个void(int)类型的函数。返回的函数指针也是void(int)类型。
- 当用signal设置信号处理程序时，第二个参数是指向信号处理程序的指针，返回的是之前的信号处理程序的指针。
  >所以用signal函数，在不改变信号的处理方式的情况下无法确定信号当前的处理方式
- func除了指向信号处理程序外，还可以是两个常量, SIG_IGN，表示忽略此信号,以及SIG_DFL，表示采用系统默认作用
- 子进程会继承父进程的信号处理方式，因为子进程在开始时会复制父进程内存映像，所以信号捕捉函数的地址在子进程中是有意义的

>exec函数会将原来设置为要捕捉的信号都更改为默认动作，其他信号的状态则不变（因为信号捕捉函数的地址很可能在新的程序文件中已无意义）。  
>所以执行一个程序时，所有信号的状态都是系统默认或忽略。通常所有信号都被设置为它们的默认动作，除非调用exec的进程忽略该信号。例如shell启动后台进程时，会自动将后台进程对中断和退出信号的处理方式设置为忽略

### 信号集及其相关函数

* 用结构体sigset_t表示一个信号集，能同时表示多个信号
* 在使用信号集之前，需要调用sigemptyset或sigfillset一次

```c
#include <signal.h>
int sigemptyset(sigset_t *set);
//初始化由set指向的信号集，清除其中所有信号
int sigfillset(sigset_t *set);
//初始化由set指向的信号集，使其包含所有信号
int sigaddset(sigset_t *set, int signo);
//添加一个信号
int sigdelset(sigset_t *set, int signo);
//删除一个信号
//以上四个函数成功返回0，出错返回-1
int sigmember(const sigset_t *set, int signo)
//检查信号集中是否包含signo信号
//若真返回-1，假返回0
```

#### 信号屏蔽字

* 规定了当前阻塞而不能传递给该进程的信号集

```c
#include <signal.h>
int sigprocmask(int how, const sigset_t *restrict set, sigset_t * restrict oset);//检测或更改信号屏蔽字
int sigpending(sigset_t *set);//set返回在阻塞期间接收到阻塞信号的集合
//成功返回0，出错返回-1
int sigsuspend(const sigset_t * sigmask);
```

* sigprocmask函数
  * 若oset非空，则进程的当前信号屏蔽字通过oset返回
  * 若set非空，则how的取值指示如何修改当前信号屏蔽字
    * SIG_BLOCK，set是希望阻塞的附加信号
    * SIG_UNBLOCK，set是希望解除阻塞的信号
    * SIG_SETMASK，该进程新的信号屏蔽字是set指向的值
  * 如果set是空指针，则不改变该进程的信号屏蔽字，how的取值无意义
* sigsuspend函数

### sigaction函数

- 修改或检查指定信号的处理动作，用于取代signal

```c
#include<signal.h>
int sigaction(int signo, const srtuct sigaction *restrict act, strcut sigaction *restrict oact);
//成功返回0，出错返回-1
struct sigaction{
    void (*sa_handler)(int);
    sigset_t sa_mask;
    int sa_flags;
    void (*sa_sigaction)(int, siginfo_t*, void *);
};
// sa_handler和sa_sigaction可能使用同一存储区，只能一次使用这两个字段中的一个
```

* 函数sigaction中参数signo表示要检测或修改其距离动作的信号编号。若act指针非空，则要修改其动作，若oact指针非空，则oact返回该信号的上一个动作
* 如果sigaciton结构体中的sa_handler字段包含一个信号捕捉函数的地址(不是常量SIG_IGN或SIG_DEL)，则sa_mask说明了一个信号集。在调用该信号捕捉函数之前，这一信号集要加到进程的信号屏蔽字中，当信号捕捉函数返回时，再将进程的信号屏蔽字恢复为原线值。这样的目的是
  * 在调用信号处理程序时阻塞某些信号
  * 在信号处理程序倍调用时，新的信号屏蔽字会包括正在递送的信号，保证了在处理一个给定的信号时，如果这种信号再次发生，会被阻塞到对前一个信号的处理结束为止
* 一旦对给定的信号设置了一个动作，那么在调用sigaction显示地改变它之前，该设置一直有效
* sigaction中的sa_flags字段指定对信号进程处理的各个选项，包括有
  * SA_INTERRUPT
  * SA_NOCLDSTOP
  * SA_NOCLDWAIT
  * SA_NODEFER
  * SA_ONSTACK
  * SA_RESETHAND
  * SA_RESTART
  * SA_SIGINFO, 信号处理程序具有附加信息
* 最后sa_sigaction是一个替代的信号处理程序，sa_flags字段包含SA_SIGINFO时,使用该信号处理程序。

```c
struct siginfo{
    int si_signo;   //信号编号
    int si_errno;   //
    int si_code;    //
    pid_t si_pid;   //进程ID
    uid_t si_uid;   //进程实际用户ID
    void *si_addr;  //发生错误的地址
    int si_status;  //退出状态
    union sigval si_value;
};
union sigval{
    int sival_int;
    void *sival_ptr;
};

```

## 能产生或发送信号的函数

* 发送信号需要的权限
  * 超级用户可以将信号发送给任意进程
  * 非超级用户：发送者的实际用户ID或有效用户ID必须等于接收者的实际用户ID或有效用户ID
  * SIGCONT信号可倍发送给属于同一会话的任一其他进程

### kill和raise函数

* kill函数将信号发送给进程或进程组
* raise函数允许进程向自身发送信号

```c
#include <signal.h>

int kill(pid_t pid, int signo);
int raise(int signo);
//等价于 kill(getpid(),signo);
```

* pid参数
  * pid>0，发送信号给进程ID为pid的进程
  * pid==0，发送信号给同一进程组的所有进程，需要具有权限，且不包括实现定义的系统进程集(内核进程和init)
  * pid<-1，发送信号给进程组等于pid的所有进程，需要具有权限，且不包括实现定义的系统进程集(内核进程和init)
  * pid==-1,发送给发送进程有权限向它们发送信号的所有进程，同样不包括系统进程集

### alarm和pause函数

- alarm函数可以设置一个定时器，在将来的某个时刻该定时器会超时，产生SIGALRM信号。默认动作是终止调用该函数的进程
- pause函数使调用进程挂起直至捕捉到一个信号

```c
#include <unistd.h>
unsigned int alarm(unsigned int seconds);
int pause(void);//返回-1，并且errno设置为EINTR
```

- seconds是产生信号SIGALRM需要经过的秒数。但实际由于进程调度的延迟，进程得到控制从而能够处理该信号还需要一个时间间隔
- 每个进程只能由一个闹钟时间。如果调用alarm时，之前已为该进程注册的闹钟时间还没有超时，则该闹钟时间的余留值作为本次调用的返回值。以前注册的闹钟时间则被新值取代

