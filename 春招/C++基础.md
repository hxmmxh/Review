
- [语言特性](#语言特性)
  - [C和C++的区别](#c和c的区别)
  - [面对对象和面对过程](#面对对象和面对过程)
  - [面向对象三大特性](#面向对象三大特性)
  - [c++11 新特性](#c11-新特性)
  - [C++ 20 新特性](#c-20-新特性)
  - [原码、反码、补码](#原码反码补码)
  - [大端小端](#大端小端)
  - [左值和右值](#左值和右值)
  - [右值引用](#右值引用)
  - [完美转发](#完美转发)
  - [C++的异常处理](#c的异常处理)
  - [RAII](#raii)
  - [智能指针的用法](#智能指针的用法)
  - [shared_ptr实现原理](#shared_ptr实现原理)
  - [make_shared和shared_ptr的区别](#make_shared和shared_ptr的区别)
  - [命名空间](#命名空间)
  - [运算符重载](#运算符重载)
  - [类型安全](#类型安全)
- [2. 函数相关](#2-函数相关)
  - [2.1 在main执行之前和之后执行的代码可能是什么？](#21-在main执行之前和之后执行的代码可能是什么)
  - [2.2 int main(int argc, char ** argv)](#22-int-mainint-argc-char--argv)
  - [2.3 函数指针和指针函数](#23-函数指针和指针函数)
  - [2.4 形参与实参的区别](#24-形参与实参的区别)
  - [2.5 值传递、指针传递、引用传递](#25-值传递指针传递引用传递)
  - [2.6 函数调用的过程](#26-函数调用的过程)
  - [内联函数](#内联函数)
  - [调试程序的方法，程序异常退出如何排查](#调试程序的方法程序异常退出如何排查)
  - [遇到coredump要怎么调试（问过）](#遇到coredump要怎么调试问过)
  - [Denug和release的区别](#denug和release的区别)
  - [回调函数](#回调函数)
  - [含可变形参的函数](#含可变形参的函数)
  - [可调用对象](#可调用对象)
    - [1. Lambda表达式](#1-lambda表达式)
      - [捕获外部变量](#捕获外部变量)
      - [形参列表](#形参列表)
      - [返回类型](#返回类型)
      - [用例](#用例)
    - [2. 标准库定义的函数对象](#2-标准库定义的函数对象)
    - [3. 标准库function](#3-标准库function)
    - [4. bind](#4-bind)
  - [可变参数模板](#可变参数模板)
- [3. 空间分配，内存管理](#3-空间分配内存管理)
  - [文件的编译过程](#文件的编译过程)
  - [静态链接和动态链接](#静态链接和动态链接)
  - [C的内存模型](#c的内存模型)
  - [C++的内存模型](#c的内存模型-1)
  - [C++中的作用域](#c中的作用域)
  - [全局变量、局部变量、静态全局变量、静态局部变量的区别](#全局变量局部变量静态全局变量静态局部变量的区别)
  - [常见内存分配方式](#常见内存分配方式)
  - [限制对象只能建立在堆上](#限制对象只能建立在堆上)
  - [限制对象只能建立在栈上](#限制对象只能建立在栈上)
  - [内存对齐](#内存对齐)
  - [malloc和new的区别](#malloc和new的区别)
    - [new的实现原理](#new的实现原理)
    - [重载new](#重载new)
  - [malloc,calloc,realloc](#malloccallocrealloc)
  - [malloc的实现原理](#malloc的实现原理)
  - [realloc流程](#realloc流程)
  - [std::allocator](#stdallocator)
  - [堆和栈的区别](#堆和栈的区别)
  - [栈溢出,stack overflow](#栈溢出stack-overflow)
  - [内存分配的常见错误和解决方法](#内存分配的常见错误和解决方法)
    - [段错误](#段错误)
    - [内存溢出](#内存溢出)
    - [内存泄漏](#内存泄漏)
    - [防止内存泄漏的方法](#防止内存泄漏的方法)
    - [valgrind内存泄漏检测](#valgrind内存泄漏检测)
    - [mtrace检测内存泄露](#mtrace检测内存泄露)
  - [原子操作如何实现](#原子操作如何实现)
- [4. 指针，引用，数组](#4-指针引用数组)
  - [4.1 引用和指针的区别](#41-引用和指针的区别)
  - [4.2 指针的作用](#42-指针的作用)
  - [4.3 野指针](#43-野指针)
  - [4.4 悬空指针](#44-悬空指针)
  - [4.5 使用指针需要注意什么](#45-使用指针需要注意什么)
  - [4.6 字符数组和指针的区别](#46-字符数组和指针的区别)
- [5. C++关键字](#5-c关键字)
  - [5.1 变量声明和定义区别](#51-变量声明和定义区别)
  - [5.2 全局变量和局部变量](#52-全局变量和局部变量)
  - [5.3 static的作用](#53-static的作用)
  - [C和C++，static的区别](#c和cstatic的区别)
  - [volatile关键字](#volatile关键字)
  - [restrict关键字](#restrict关键字)
  - [寄存器变量，register](#寄存器变量register)
  - [四个cast转换关键字](#四个cast转换关键字)
  - [const作用及用法](#const作用及用法)
  - [顶层const和底层const](#顶层const和底层const)
  - [const和constexpr](#const和constexpr)
  - [const和#define区别](#const和define区别)
  - [entern](#entern)
  - [extern "C"](#extern-c)
  - [struct 和 class 的区别](#struct-和-class-的区别)
  - [C++和C的struct区别](#c和c的struct区别)
  - [strlen 和 sizeof区别](#strlen-和-sizeof区别)
  - [NULL和nullptr](#null和nullptr)
  - [auto、decltype和decltype(auto)的用法](#autodecltype和decltypeauto的用法)
  - [define 和 typedef 的区别](#define-和-typedef-的区别)
  - [为什么要少使用宏？C++有什么解决方案？](#为什么要少使用宏c有什么解决方案)
  - [goto](#goto)
  - [noexcept](#noexcept)
  - [__attribute__ 机制](#attribute-机制)
  - [https://blog.csdn.net/weaiken/article/details/88085360](#httpsblogcsdnnetweaikenarticledetails88085360)
- [6. 类相关问题](#6-类相关问题)
  - [C++结构体和C结构体的区别](#c结构体和c结构体的区别)
  - [结构体和共用体的区别](#结构体和共用体的区别)
  - [匿名的union](#匿名的union)
  - [获取类的成员相对于类的起始位置的偏移](#获取类的成员相对于类的起始位置的偏移)
  - [struct 和 class 的区别](#struct-和-class-的区别-1)
  - [嵌套类](#嵌套类)
  - [组合和继承](#组合和继承)
  - [对象复用](#对象复用)
  - [零拷贝](#零拷贝)
  - [C++空类有哪些成员函数](#c空类有哪些成员函数)
  - [类大小的计算](#类大小的计算)
  - [友元](#友元)
  - [有哪几种构造函数](#有哪几种构造函数)
  - [为什么用成员初始化列表会快一些](#为什么用成员初始化列表会快一些)
  - [构造函数和析构函数调用时机](#构造函数和析构函数调用时机)
  - [构造函数、析构函数、虚函数可否声明为内联函数](#构造函数析构函数虚函数可否声明为内联函数)
  - [构造与析构的顺序](#构造与析构的顺序)
  - [类什么时候会析构](#类什么时候会析构)
  - [explict](#explict)
  - [构造函数与析构函数不能被继承](#构造函数与析构函数不能被继承)
  - [this指针](#this指针)
  - [nullptr能否调用成员函数](#nullptr能否调用成员函数)
  - [拷贝构造函数和赋值运算符重载的区别](#拷贝构造函数和赋值运算符重载的区别)
  - [类的静态成员](#类的静态成员)
  - [类的初始值](#类的初始值)
  - [类的const成员](#类的const成员)
  - [mutable](#mutable)
  - [delete this](#delete-this)
  - [合成默认构造函数](#合成默认构造函数)
  - [拷贝构造函数](#拷贝构造函数)
  - [移动构造函数](#移动构造函数)
  - [深拷贝和浅拷贝的区别](#深拷贝和浅拷贝的区别)
  - [哪几种情况必须用到初始化成员列表](#哪几种情况必须用到初始化成员列表)
  - [什么是类的继承](#什么是类的继承)
  - [public，protected和private访问和继承权限/public/protected/private的区别？](#publicprotected和private访问和继承权限publicprotectedprivate的区别)
  - [重载，重写（覆盖）和隐藏](#重载重写覆盖和隐藏)
  - [虚函数和多态](#虚函数和多态)
  - [虚函数的实现机制](#虚函数的实现机制)
  - [不同类继承情况下的虚函数表结构](#不同类继承情况下的虚函数表结构)
  - [override和final](#override和final)
  - [构造函数和析构函数能否为虚函数](#构造函数和析构函数能否为虚函数)
  - [哪些函数不能是虚函数](#哪些函数不能是虚函数)
  - [构造函数或者析构函数中调用虚函数](#构造函数或者析构函数中调用虚函数)
  - [动态绑定和静态绑定](#动态绑定和静态绑定)
  - [纯虚函数和抽象类](#纯虚函数和抽象类)
  - [纯虚析构函数](#纯虚析构函数)
  - [多重继承](#多重继承)
  - [虚继承](#虚继承)
  - [类成员指针](#类成员指针)
  - [把成员函数转换成可调用对象](#把成员函数转换成可调用对象)
- [7. STL](#7-stl)
  - [STL六大组件](#stl六大组件)
  - [allocator的分配原理](#allocator的分配原理)
  - [特性萃取](#特性萃取)
  - [常见容器](#常见容器)
  - [容器内部删除一个元素](#容器内部删除一个元素)
  - [vector和list的区别](#vector和list的区别)
  - [vector 的实现](#vector-的实现)
  - [vectoc的size和capacity](#vectoc的size和capacity)
  - [vector的resize和reserve](#vector的resize和reserve)
  - [push_back()和emplace_back()](#push_back和emplace_back)
  - [list的实现](#list的实现)
  - [deque的实现](#deque的实现)
  - [迭代器和指针的区别](#迭代器和指针的区别)
  - [迭代器分类](#迭代器分类)
  - [vector迭代器失效](#vector迭代器失效)
  - [deque迭代器失效](#deque迭代器失效)
  - [hash 表的实现](#hash-表的实现)
  - [unordered_map 和 map 的区别](#unordered_map-和-map-的区别)
  - [hash表的扩容](#hash表的扩容)
  - [红黑树](#红黑树)
  - [map的实现](#map的实现)
  - [set的实现](#set的实现)
  - [unordered_map和map的区别和应用场景](#unordered_map和map的区别和应用场景)
- [模板](#模板)
  - [模板的特例化](#模板的特例化)
  - [模板的编译](#模板的编译)
  - [std::enable_if](#stdenable_if)
  - [std::is_same](#stdis_same)
  - [std::is_convertible](#stdis_convertible)
  - [类模板和友元](#类模板和友元)


----------------------------------------------------------------------
https://www.cnblogs.com/blogxjc/p/11130843.html
# 语言特性

## C和C++的区别

- C是面向过程的语言，而C++是面向对象的语言
- 应用的领域
  - C语言主要用于嵌入式领域，驱动开发等与硬件直接打交道的领域
  - C++可以用于应用层开发，用户界面开发等与操作系统打交道的领域。
- C和C++动态管理内存的方法不一样，C是使用malloc/free函数，而C++除此之外还有new/delete关键字
- C++支持函数重载，而C不支持函数重载，而C++支持重载的依仗就在于C++的名字修饰与C不同，例如在C++中函数int fun(int ,int)经过名字修饰之后变为_fun_int_int ,而C是 _fun，一般是这样的，所以C++才会支持不同的参数调用不同的函数；
- C++中有引用，而C没有
- 增加了泛型编程,模板，标准模板库STL
- 异常处理
- 还增加了命名空间，避免了命名冲突
- lamda表达式，范围for，右值引用

## 面对对象和面对过程
- 面向过程的思路
  - 编程分析解决问题所需的步骤，用函数把这些步骤依次实现，在一步一步的具体步骤中按顺序调用函数
- 面向对象的思路
  - 把构成问题的事务分解为各个对象，
  - 每个对象都有自己的属性和行为，通过对象和对象之间的交互来解决问题
  - 建立对象的目的，不是完成一个步骤，而是描述某个事务在解决整个问题步骤中的行为。
  - 在分析和解决问题的时候，将涉及到的数据和数据的操作封装在类中，通过类可以创建对象，以事件或消息来驱动对象执行处理

## 面向对象三大特性
- 封装性
    - 数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。
    - 优点:
        - 减少耦合：可以独立地开发、测试、优化、使用、理解和修改
        - 减轻维护的负担：可以更容易被程序员理解，并且在调试的时候可以不影响其他模块
        - 有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能
        - 提高软件的可重用性,程序更模块化，更易读易写
        - 降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的
- 继承性
    - 让某种类型对象获得另一个类型对象的属性和方法。
    - 达到了重用代码功能和提高执行时间的效果。当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。
- 多态性
    - 同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为（重载实现编译时多态，虚函数实现运行时多态）
    - C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。
    - 分类
        - 静态多态，函数重载和模板
        - 动态多态，在程序运行时根据基类的引用（指针）指向的对象来确定自己具体该调用哪一个类的虚函数。 
            - 基类中必须包含虚函数，并且派生类中一定要对基类中的虚函数进行重写。 
            - 通过基类对象的指针或者引用调用虚函数。

## c++11 新特性

- nullptr;
- auto和decltype，实现了类型推导
- 区间迭代，范围for，`for(auto i : num)`
- `{}`的初始化列表
- lamda表达式
- 新增了容器，std::array(数据保存在栈内存中)，std::forward_list，unordered_map/set
- 右值引用和移动语义
- 委托构造函数
- 类函数的delete, default
- 引入了线程库,thread,还有原子操作
  
## C++ 20 新特性

- 协程

## 原码、反码、补码
- 整型数值在计算机的存储里，最左边的一位代表符号位，0代表正数，1代表负数。
- 原码：为二进制的数，如：10 原码为0000 1010
- 反码
  - 正数的反码与原码相同：如：10 原码为0000 1010，反码为0000 1010
  - 负数为原码0变1，1变0，（符号位不变）：如：-10 原码为1000 1010，反码为1111 0101
- 补码
  - 正数的补码与原码相同：如：10 原码为0000 1010，补码为0000 1010
  - 负数的补码为反码加1：如：-10 反码为1111 0101，补码为1111 0110
- 2的补码就是最方便的方式。它的便利体现在，所有的加法运算可以使用同一种电路完成


## 大端小端
- 大端存储：数据的高字节存储在低地址中
- 小端存储：数据的低字节存储在低地址中
- 判断方法
  - 强制类型转换，例如把一个 unsigned short转换成 unsigned char
  - union,联合体union的存放顺序是所有成员都从低地址开始存放

```cpp
unsigned short test = 0x1122;
if (*((unsigned char *)&test) == 0x11)
    cout << "da";
else
    cout << "xiao";

int checkCPUendian()
{
    union
    {
        unsigned int a;
        unsigned char b;
    } c;
    c.a = 1;
    return (c.b == 1);

} /*return 1 : little-endian, return 0:big-endian*/
```


## 左值和右值

- 一般来说一个左值表示的是一个对象的身份，一个右值表示的是对象的值。
- 左值（lvalue）：左值可以出现在赋值号的左边或右边,可以取地址
- 右值（rvalue）：只能在赋值号的右边，不能出现在赋值号的左边，不能取地址
  - 纯右值
  - 将亡值：生命周期将要结束的对象

## 右值引用

- 只能绑定到一个将要销毁的对象，通过`&&`而不是`&`来获得
- 一般来说一个左值表示的是一个对象的身份，一个右值表示的是对象的值。
- 返回左值引用的函数，赋值，下标，解引用，前置递增递减运算符，返回左值表达式，可以绑定左值引用
- 返回非引用类型的函数，算术，关系，位，后置递增递减运算符，生成右值，可以绑定const的左值引用和右值引用
- `std::move`，将左值绑定在右值引用上`int &&r=std::move(i)`,调用move意味着承诺除了对i进行赋值或销毁外，将不再使用它。
  - 可以销毁一个移后源对象，或者赋予它新值，但不能使用一个移后源对象的值
  - 使用move的代码应该使用`std::move`
- 作用
  - 函数传参
  - 移动构造函数
  - 完美转发
- 移动构造函数与拷贝构造不同，它并不是重新分配一块新的空间同时将要拷贝的对象复制过来，而是"拿"了过来，将自己的指针指向别人的资源，然后将别人的指针修改为nullptr


## 完美转发

- 在函数模板中，完全依照模板的参数的类型，将参数传递给函数模板中调用的另一个函数
  - 如果相应实参是左值，它就应该被转发为左值；如果相应实参是右值，它就应该被转发为右值
- 用右值引用和forward实现
```cpp
template<typename T>
//完美转发:t是左值---->传给Fun函数，t应该也是左值
//		   t如果是右值--->传给Fun函数，t应该是右值
void PerfectForward(T &&t)
{ 
	Fun(std::forward<T>(t)); //forward把t转化为右值。
}
```

## C++的异常处理

- 一个异常安全的函数，在有异常抛出时不应泄露任何资源，且不能使任何对象进入非法状态。
- 为实现异常安全的编程，应尽量确保析构函数不抛掷异常
- 常见的异常有：
  - 数组下标越界
  - 除法计算时除数为0
  - 动态分配空间时空间不足
  - 打开文件读取时，文件不存在
- 异常处理方法
  - 可以是给出错误提示信息，然后让程序沿一条不会出错的路径继续执行
  - 也可能是不得不结束程序，但在结束前做一些必要的工作，如将内存中的数据写入文件、关闭打开的文件、释放动态分配的内存空间等
- C++的异常处理机制
  - 函数 A 在执行过程中发现异常时可以不加处理，而只是“拋出一个异常”给 A 的调用者，假定为函数 B
  - 拋出异常而不加处理会导致函数 A 立即中止，在这种情况下，函数 B 可以选择捕获 A 拋出的异常进行处理，也可以选择置之不理。如果置之不理，这个异常就会被拋给 B 的调用者，以此类推。
  - 如果一层层的函数都不处理异常，异常最终会被拋给最外层的 main 函数。main 函数应该处理异常。如果main函数也不处理异常，那么程序就会立即异常地中止。
- try、throw和catch关键字
  - 异常处理流程
    - 先执行try包裹的语句块，如果执行过程中没有异常发生，则不会进入任何catch包裹的语句块
    - 如果发生异常，则使用throw进行异常抛出，再由catch进行捕获
    - throw可以抛出各种数据类型的信息，catch根据throw抛出的数据类型进行精确捕获（不会出现类型转换）
    - 立即跳转到第一个“异常类型”和拋出的异常类型匹配的 catch 块中执行
    - 如果匹配不到就直接报错，程序就会立即中止，可以使用catch(...)的方式捕获任何异常（不要将它写在其他 catch 块前面）
    - 如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以在catch里面再throw异常,（简单的加一个throw;表示抛出捕获的异常）
```cpp
#include <iostream>
using namespace std;
int main()
{
    double m = 1, n = 0;
    try {
        cout << "before dividing." << endl;
        if (n == 0)
            throw - 1;  //抛出int型异常
        else if (m == 0)
            throw - 1.0;  //拋出 double 型异常
        else
            cout << m / n << endl;
        cout << "after dividing." << endl;
    }
    catch (double d) {
        cout << "catch (double)" << d << endl;
    }
    catch (...) {
        cout << "catch (...)" << endl;
    }
    cout << "finished" << endl;
    return 0;
}
//运行结果
//before dividing.
//catch (...)
//finished
```
- 函数的异常声明列表
  - 在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常的列表
  - `int fun() throw(int,double,A,B,C){...};`,表名函数可能会抛出int,double型或者A、B、C三种类型的异常
  - 如果throw中为空，表明不会抛出任何异常，如果没有throw则可能抛出任何异常
- C++标准异常类 exception
  - 使用这些异常类需要包含头文件 stdexcept。
  - bad_typeid、bad_cast、bad_alloc、ios_base::failure、out_of_range 都是 exception 类的派生类。
    - bad_typeid
      - 使用 typeid 运算符时，如果其操作数是一个多态类的指针，而该指针的值为 NULL，则会拋出此异常。
    - bad_cast
      - 在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常。
    - bad_alloc
      - 在用 new 运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常
    - out_of_range
      - 用 vector 或 string 的 at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常
      - at 成员函数会检测下标越界并拋出异常，而 operator[] 则不会。operator [] 相比 at 的好处就是不用判断下标是否越界，因此执行速度更快
  - C++ 程序在碰到某些异常时，即使程序中没有写 throw 语句，也会自动拋出上述异常类的对象
  - 这些异常类还都有名为 what 的成员函数，返回字符串形式的异常描述信息
```cpp
// bad_typeid
A *a = NULL;
try
{
    cout << typeid(*a).name() << endl; // Error condition
}
catch (bad_typeid)
{
    cout << "Object is NULL" << endl;
}
// bad_cast
class Base
{
    virtual void func() {}
};
class Derived : public Base
{
public:
    void Print() {}
};
void PrintObj(Base &b)
{
    try
    {
        Derived &rd = dynamic_cast<Derived &>(b);
        //此转换若不安全，会拋出 bad_cast 异常
        rd.Print();
    }
    catch (bad_cast &e)
    {
        cerr << e.what() << endl;
    }
}
// bad_alloc
try
{
    char *p = new char[0x7fffffff]; //无法分配这么多空间，会抛出异常
}
catch (bad_alloc &e)
{
    cerr << e.what() << endl;
}
// out-of_range
vector<int> v(10);
try
{
    v.at(100) = 100; //拋出 out_of_range 异常
}
catch (out_of_range &e)
{
    cerr << e.what() << endl;
}
string s = "hello";
try
{
    char c = s.at(100); //拋出 out_of_range 异常
}
catch (out_of_range &e)
{
    cerr << e.what() << endl;
}
```


## RAII

- Resource Acquisition is Initialization,资源获取即初始化
- 在构造函数中申请分配资源，在析构函数中释放资源
- 为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定

## 智能指针的用法

- 智能指针是一个模板类，可以更简单更安全地管理动态分配的内存，会自动释放所指向的对象，防止内存泄漏
- 智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。    
- C++里面的三个智能指针: shared_ptr, weak_ptr, unique_ptr。
- shared_ptr,共享指针 
  - shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放
  - 它使用计数机制来表明资源被几个指针共享。
  - 常用的成员函数
    - 默认初始化的智能指针保存着一个空指针
    - 最安全用make_shared初始化
    - 也可以用new返回的指针来初始化
    - use_count()来查看资源的所有者个数
    - release() 释放资源的所有权
- unique_ptr，独占指针
  - unique_ptr拥有它所指向的对象，保证同一时间内只有一个智能指针可以指向该对象。
  - 通常不能拷贝构造和赋值
    - 必须使用直接初始化，定义时要将其绑定在一个new返回的地址
    - 可以进行移动构造和移动赋值构造
    - 可以拷贝或赋值一个将要被销毁的unique_ptr，在函数返回时最常见
    - 通过release和reset。`u.release()`放弃对指针的控制权，并返回该指针。`u.reset(p)`释放u当前指向的对象，并指向p
```cpp
make_shared<T>(args);//返回一个shared_ptr，会在动态内存中分配一个对象并初始化，用args初始化
unique_ptr<string> p2(p1.release());
unique_ptr<string> p3.reset(p2.release());
p.get()//返回内置指针，shared_ptr和unqiue_ptr都可以
```
- weak_ptr，弱指针 
  - weak_ptr 不控制对象生命周期的智能指针, 它指向一个shared_ptr管理的对象. 进行该对象的内存管理的是那个强引用的shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。
  - 构造和析构不会引起引用记数的增加或减少
  - 用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放
  - 由于对象可能不存在，不能通过weak_ptr直接访问对象，在访问所引用的对象前必须先转化为 shared_ptr（调用lock)
```cpp
w.use_count();
w.expire();
w.lock();//存在则指向一个返回共享对象的shared_ptr，否则返回空的shared_ptr
```
- 循环引用
  - 两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放
  - 令环中的指针之一为弱指针可以避免该情况

## shared_ptr实现原理
```cpp
template <typename T>
class SmartPointer
{
public:
    //构造函数
    SmartPointer(T *p = 0) : _ptr(p), _reference_count(new atomic<size_t>)
    {
        _ref
    }
    //拷贝构造函数
    SmartPointer(const SmartPointer &src)
    {
        if (this != &src)
        {
            _ptr = src._ptr;
            _reference_count = src._reference_count;
            (*_reference_count)++;
        }
    }
    //重载赋值操作符
    SmartPointer &operator=(const SmartPointer &src)
    {
        if (_ptr == src._ptr)
        {
            return *this;
        }
        releaseCount();
        _ptr = src._ptr;
        _reference_count = src._reference_count;
        (*_reference_count)++;
        return *this;
    }

    //重载操作符
    T &operator*()
    {
        if (ptr)
        {
            return *_ptr;
        }
        //throw exception
    }
    //重载操作符
    T *operator->()
    {
        if (ptr)
        {
            return _ptr;
        }
        //throw exception
    }
    //析构函数
    ~SmartPointer()
    {
        if (--(*_reference_count) == 0)
        {
            delete _ptr;
            delete _reference_count;
        }
    }

private:
    mutex* _mutex;
    T *_ptr;
    size_t *_reference_count;
    void releaseCount()
    {
        if (_ptr)
        {
            (*_reference_count)--;
            if ((*_reference_count) == 0)
            {
                delete _ptr;
                delete _reference_count;
            }
        }
    }
};
```

## make_shared和shared_ptr的区别

- std::shared_ptr在实现的时候使用的refcount技术，因此内部会有一个计数器（控制块，用来管理数据）和一个指针，指向数据
- 在执行`std::shared_ptr<A> p2(new A)`的时候，首先会申请数据的内存，然后申请内控制块，因此是两次内存申请
- 而`std::make_shared<A>()`则是只执行一次内存申请，将数据和控制块的申请放到一起
- make_shared的缺点
  - 因为make_shared只申请一次内存，因此控制块和数据块在一起，只有当控制块中不再使用时，内存才会释放，但是weak_ptr却使得控制块一直在使用。

## 命名空间
- 为防止名字冲突提供了更加可供的机制
- 使用方法
  - 只要能出现在全局作用域中的声明就能置于命名空间内
    - 类，变量(及其初始化)，函数(及其定义)，模板，其他命名空间
  - 不能定义在函数或类的内部
  - 命名空间结束后无须分号
  - 命名空间可以是不连续的
- 内联的命名空间
  - 在namespace前添加关键字inline，必须出现在命名空间第一次定义的地方，之后可写可不写
  - 内联命名空间中的名字可以被外层命名空间直接使用
- 未命名的命名空间使用
  - 未命名的命名空间中定义的变量拥有静态生命周期，在第一次使用前创建，并且直到程序结束才销毁，类似static关键字
  - 一个未命名的命名空间可以在某个给定的文件内不连续，但是不能跨越多个文件
  - 如果一个头文件定义了未命名的命名空间，则该命名空间中定义的名字将在每个包含了该头文件的文件中对应不同的实体
  - 未命名的命名空间中定义的名字的作用域与该命名空间所在的所用域相同，名字可以直接使用

## 运算符重载

- 不能重载的运算符（只有5个）：
  - . 成员访问运算符 ，保证访问成员的功能不能被改变
  - .* ->* 成员指针访问运算符，保证访问成员的功能不能被改变
  - :: 域运算符，运算对象是类型而不是变量
  - sizeof 长度运算符，运算对象是类型而不是变量或一般表达式，不具备重载特征
  - ?: 条件运算符，运算对象是类型而不是变量或一般表达式，不具备重载特征
- 部分运算符不建议被重载（4个）
  - `&&`, `||` , 重载版本无法保留短路求值顺序
  - 逗号和取地址运算符已经定义了用于类类型对象的特殊含义
- 运算符重载有两种方式
  - 一种是类内重载（运算符重载函数作为类的成员函数）
    - 成员函数声明必须在类的内部，定义可以在类的内部也可以在外部
  - 另一种是类外重载（运算符重载函数作为类的友元函数）
    - 非成员函数声明和定义都在类的外部
  - 把运算符定义为成员函数时，左侧运算对象必须是类
- 赋值（=），下标（[]），调用(())，箭头(->)，类型转换运算符必须是成员
- 输入输出必须是非成员
- 复合赋值一般来说是成员，但非必须
- 改变对象状态的运算符一般是成员
  - 例如递增，递减，解引用
- 具有对称性的运算符（可以转换任意一端的运算对象）一般是非成员
  - 例如算术，相等性，比较


## 类型安全

- 类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。
- C++提供了一些新的机制保障类型安全：
  - 操作符new返回的指针类型严格与对象匹配，而不是void*
  - C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的
  - 引入const关键字代替#define constants，它是有类型、有作用域的，而#define constants只是简单的文本替换
  - 一些#define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全
  - C++提供了dynamic_cast关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。

# 2. 函数相关

## 2.1 在main执行之前和之后执行的代码可能是什么？
- main函数执行之前，主要就是初始化系统相关资源：
  - 设置栈指针
  - 初始化静态static变量和global全局变量，即.data段的内容
  - 将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL等等，即.bss段的内容
  - 全局对象初始化，在main之前调用构造函数，这是可能会执行前的一些代码
  - 将main函数的参数argc，argv等传递给main函数，然后才真正运行main函数
- main函数执行之后：
  - 全局对象的析构函数会在main函数之后执行；
  - 可以用atexit注册一个函数，它会在main之后执行;

## 2.2 int main(int argc, char ** argv)

- 参数argc,用来统计程序运行时发送给main函数的命令行参数的个数。
- argv,字符串数组，用来存放指向的字符串参数的指针数组，每一个元素指向一个参数。各成员含义如下：
  - argv[0]指向程序运行的全路径名
  - argv[1]指向在DOS命令行中执行程序名后的第一个字符串
  - argv[2]指向执行程序名后的第二个字符串
  - argv[argc]为NULL

## 2.3 函数指针和指针函数

- 函数指针（指向函数的指针）：
  - 本质上是一个指针，只不过这个指针指向了一个函数，保存的是这个函数的地址（函数名）。
  - `int (*p)(int, int)`,表示所指向的函数返回值是int型，参数是两个int型
- 指针函数（函数的返回值是指针）
  - 本质上是一个函数，只不过返回值是指针类型。
  - `int* fun(int x, int y){}`,这个fun函数的返回值是指针类型

## 2.4 形参与实参的区别

- 形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只有在函数内部有效。函数调用结束返回主调函数后则不能再使用该形参变量。
- 实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。因此应预先用赋值，输入等办法使实参获得确定值，会产生一个临时变量。
- 实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。
- 函数调用只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。
- 当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。

## 2.5 值传递、指针传递、引用传递

- 值传递
  - 有一个实参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象或是大的结构体对象，将耗费一定的时间和空间。（传值）
  - 在函数调用过程中，形参的值发生改实参中的值不会变化
- 指针传递
  - 同样有一个实参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为4字节的地址。（传值，传递的是地址值）
- 引用传递
  - 同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。（传地址）
- 效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰。

## 2.6 函数调用的过程

- 调用者函数把被调函数所需要的参数按照与被调函数的形参顺序相反的顺序压入栈中,即:从右向左依次把被调函数所需要的参数压入栈
- 调用者函数使用call指令调用被调函数,并把call指令的下一条指令的地址当成返回地址压入栈中(这个压栈操作隐含在call指令中); 
- 在被调函数中,被调函数会先保存调用者函数的栈底地址(push ebp),然后再保存调用者函数的栈顶地址,即:当前被调函数的栈底地址(mov ebp,esp)
- 在被调函数中,从ebp的位置处开始存放被调函数中的局部变量和临时变量,并且这些变量的地址按照定义时的顺序依次减小,即:这些变量的地址是按照栈的延伸方向排列的,先定义的变量先入栈,后定义的变量后入栈;
- return一个值
- 出栈，恢复调用者函数的栈结构
- 返回到调用者函数

## 内联函数
- 内联(inline)函数和普通函数相比可以加快程序运行的速度，因为不需要中断调用，以省去函数调用的开销来提高执行效率
- 像普通函数一样被调用，但是在调用时并不通过函数调用的机制而是直接在调用点处展开，这样可以大大减少由函数调用带来的开销，从而提高程序的运行效率
- 取舍
  - 内联函数体内代码执行时间相比函数调用开销较大，则没有太大的意义；
  - 另一方面每一处内联函数的调用都要复制代码，消耗更多的内存空间
  - 因此以下情况不宜使用内联函数：
    - 函数体内的代码比较长，将导致内存消耗代价
    - 函数体内有循环，函数执行时间要比函数调用开销大
- 和宏定义的区别
  - 内联函数在编译时展开，宏在预编译时展开
  - 内联函数直接嵌入到目标代码中，宏是简单的做文本替换
  - 内联函数有类型检测、语法判断等功能，而宏没有
- 常见的内联函数
  - 类内定义成员函数默认是内联函数
  - 类外定义成员函数，若想定义为内联函数，需用关键字声明。inline在声明和定义处只要出现了一次就行，都出现也行

## 调试程序的方法，程序异常退出如何排查
https://blog.csdn.net/zhu2695/article/details/51512138
- IDE设置断点进行调试
- Linux中没有IDE，可以打印log
- 打印中间结果
- 生成core文件
  
## 遇到coredump要怎么调试（问过）

- 打开生成core文件的开关`ulimit -c unlimited`
- 输入`gdb core文件名 core`
- 输入`where`命令，可以找到错误的根源

## Denug和release的区别

- 调试版本
  - 包含调试信息，所以容量比Release大很多，
  - 并且不进行任何优化（优化会使调试复杂化，因为源代码和生成的指令间关系会更复杂），便于程序员调试。
- 发布版本
  - 不对源代码进行调试，编译时对应用程序的速度进行优化，使得程序在代码大小和运行速度上都是最优的

## 回调函数

- 当发生某种事件时，系统或其他函数将会自动调用你定义的一段函数
- 一个通过函数指针调用的函数。
- 相当于一个中断处理函数，由系统在符合你设定的条件时自动调用

## 含可变形参的函数

- C语言中用省略符形参
- 如果所有的实参类型相同，可以传递一个initializer_list的标准库类型
- initializer_list对象中的元素永远是常量值

```cpp
#include <initializer_list>
initializer_list<T> lst;//默认初始化，T类型元素的空列表
initializer_list<T> lst{a,b,c};//lst的元素数量和初始值一样多，列表元素是const的
lst2(lst);lst2=lst;//拷贝或赋值不会拷贝列表中的元素，原始列表和副本共享元素
lst.size()//列表的元素数量
lst.begin(),lst.end();//首元素和尾后元素
```


## 可调用对象

- 对于一个对象或一个表达式，如果可以对其使用调用运算符，就是可调用的
- 包含有函数、函数指针、lambda表达式、bind创建的对象、函数对象

### 1. Lambda表达式

- 用于定义并创建匿名的函数对象，以简化编程工作
- 语法：`[capture list] (params list) mutable exception-> return type { function body }`
  - capture list：捕获外部变量列表
  - params list：形参列表
  - mutable指示符：用来说用是否可以修改捕获的变量
  - exception：异常设定
  - return type：返回类型
  - function body：函数体
- 可以省略参数列表和返回类型，但必须永远包含捕获列表和函数体
- [参考资料](https://www.cnblogs.com/DswCnblog/p/5629165.html)  
  
#### 捕获外部变量

- 捕获列表只用于局部的非static变量，lambda表达式可以直接使用局部static变量和它所在的函数之外声明的名字
- 值捕获
  - 前提是变量可以被拷贝
  - 被捕获的变量的值在Lambda表达式**创建时**通过值拷贝的方式传入，因此随后对该变量的修改不会影响Lambda表达式中该变量的值。
  - 在Lambda表达式中，如果以传值方式捕获外部变量，则函数体中不能修改该外部变量，否则会引发编译错误
    - 使用**mutable**关键字，说明表达式体内的代码可以修改值捕获的变量
- 引用捕获
  - 使用引用捕获一个外部变量，只需要在捕获列表变量前面加上一个引用说明符&
  - 必须保证被引用的对象在lambda执行的时候是存在的
- 隐式捕获
  - 让编译器根据函数体中的代码来推断需要捕获哪些变量
  - 有两种方式，分别是[=]和[&]。[=]表示以值捕获的方式捕获外部变量，[&]表示以引用捕获的方式捕获外部变量
- 常见捕获列表
  - [] 不捕获任何变量
  - [&] 以引用方式捕获所有变量
  - [=] 用值的方式捕获所有变量（可能被编译器优化为const &)
  - [=, &foo] 以引用捕获foo, 但其余变量都靠值捕获
  - [&, foo] 以值捕获foo, 但其余变量都靠引用捕获
  - [bar] 以值方式捕获bar; 不捕获其它变量
  - [this] 捕获所在类的this指针,只能按值捕获

#### 形参列表

- 参数列表中不能有默认参数
- 不支持可变参数
- 所有参数必须有参数名

#### 返回类型

- 默认情况下，如果一个lambda体包含return之外的任何语句，则编译器假定此lambda返回void
- 如果不是返回void，就需要显式地指定返回类型

#### 用例
```cpp
[] (int x, int y) { return x + y; } // 隐式返回类型
[] (int& x) { ++x;  } // 没有 return 语句 -> Lambda 函数的返回类型是 'void'
[] () { ++global_x;  } // 没有参数，仅访问某个全局变量
[] { ++global_x; } // 与上一个相同，省略了 (操作符重载函数参数)

std::vector<int> some_list;
int total = 0;
for (int i = 0; i < 5; ++i) some_list.push_back(i);
std::for_each(begin(some_list), end(some_list), [&total](int x)
{
    total += x;
});

auto lam =[]() -> int { cout << "Hello, World!"; return 1; };
auto ret = lam();
auto lam2 =[]() -> string { cout << "Hello, World!"; return "test"; };
auto ret1 = lam2();

int a=1,b=2,c=3;
auto lam2  =[&,a](){ cout << a<<b<<c<<endl;};//b，c以引用捕获，a以值捕获。
lam2();
```
### 2. 标准库定义的函数对象

- 标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的模板类
```cpp
#include <functional>
plus<Type>
minus<Type>
multiplies<Type>
divides<Type>
modulus<Type>
negate<Type>

equal_to<Type>
not_equal_to<Type>
greater<Type>
greater_equal<Type>
less<Type>
less_equal<Type>

logical_and<Type>
logical_not<Type>
logical_or<Type>
```
- 可以用来替换算法中的默认运算符（需要传入一个可调用对象）
  - `sort(a.begin(),a.end(),greater<int>())`

### 3. 标准库function

- 调用形式指明了调用返回的类型以及传递给调用的实参类型
  - 例如`int(int,int)`,接受两个int,返回一个int
- 不同的可调用对象可以共享同一种调用形式
- functional头文件中
  - 下列的T表示函数类型
  - `function<T> f`,f是一个用来存储可调用对象的空function
  - `function<T> f(nullptr)`,显示构造一个空的function
  - `funciont<T> f(obj)`,在f中存储可调用对象obj的副本
  - `f`,将f作为条件，f含有一个可调用对象时为真
  - `f(args)`,调用f中的对象，参数是args
  - f中包含以下几个成员
    - result_type，该function类型的可调用对象返回的类型
    - argument_type，参数的类型
    - first_argument_type
    - second_argument_type
- 不能直接将重载函数的名字存入function类型的对象中
  - 可以通过传递函数指针而不是函数的名字解决
```cpp
int add(int i, int j) { return i + j; }
auto mod = [](int i, int j) { return i % j; };
struct divide
{
    int operator()(int i, int j)
    {
        return i / j;
    }
};

function<int(int, int)> f1 = add;
function<int(int, int)> f2 = divide();
function<int(int, int)> f3 = mod;
function<int(int, int)> f4 = [](int i, int j) { return i * j; };
function<int(int, int)> f3 = std::minus<int>();
```

### 4. bind

- 定义在头文件functional中
- 可以看作一个通用的函数适配器，接受一个可调用对象，生成一个新的可调用对象
- `auto newCallable= bind(callable, arg_list)`
  - arg_list是一个逗号分隔的参数列表，对应给callable的参数
  - 调用newCallable时，会调用callable，并传递给它arg_list中的参数
- arg_list中的参数会包括形如_n的名字，其中n是一个整数，这些参数是占位符
  - 数值n表示newCallable中参数的位置
  - 定义在std::placeholders命名空间中
  - 例如：_1为newCallable的第一个参数，`using std::placeholders::_1`
  - 可以利用占位符重排参数顺序
- 默认情况下，那些不是占位符的参数被拷贝到可调用对象中
  - 如果要用引用，不拷贝
  - 需要用ref函数，ref返回一个对象，包含给定的引用，还有cref，返回const引用
  - 也定义在头文件functional中
  - `bind(print, ref(os),_1,' ')`
```cpp
void f(int,int,int,int,int);//f是一个有5个参数的可调用对象
auto g=bind(f,a,b,_2,c,_1);
//生成的g有两个参数
// 第一个参数绑定到_1,传递给f的第五个参数
// 第二个参数绑定到_2,传递给f的第三个参数
// g(X,Y)等于f(a,b,Y,c,X)
```


## 可变参数模板



# 3. 空间分配，内存管理

## 文件的编译过程

- **预编译**，主要处理源代码文件中的以“#”开头的预编译指令,**生成xxx.i文件** 
  - 删除所有的#define，展开所有的宏定义。 
  - 处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。 
  - 处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。 
  - 删除所有的注释，“//”和“/**/”。 
  - 保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。 
  - 添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。 
- **编译，优化**，把预编译之后得到的文件进行一系列词法分析、语法分析、语义分析及优化后，生成相应的**汇编代码xxx.s文件**。 
  - 词法分析：把源代码的字符序列分割成一系列的记号。 
  - 语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。 
  - 语义分析：对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。 
  - 优化：源代码级别的一个优化过程。 
  - 目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。 
  - 目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。 
- **汇编**，将汇编代码转变成机器可以执行的指令(机器码文件)。 **产生目标文件xxx.o**
   - 根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。
- **链接**，将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序
  - 将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来
  - 例如A文件中的函数引用了B文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序


- 目标文件
  - 可执行目标文件：可以直接在内存中执行；
  - 可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；
  - 共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；

## 静态链接和动态链接
- **静态链接**   
  - 在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算去把静态库删除也不会影响可执行程序的执行
  - 这里所说的静态库就是对多个目标文件（.o）文件的打包，通常静态链接的包名为lib****.a。
  - 特点
    - 空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本； 
    - 更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。 
    - 运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。 
- **动态链接**  
  - 在链接的时候没有把调用的函数代码链接进去，在程序运行时才将它们链接在一起形成一个完整的程序
  - 文件名格式为lib + 动态库名 + .so后缀。
  - 特点 
    - 共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本； 
    - 更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。 
    - 性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。
- **动态编译与静态编译**
  - 静态编译，编译器在编译可执行文件时，把需要用到的对应动态链接库中的部分提取出来，连接到可执行文件中去，使可执行文件在运行时不需要依赖于动态链接库
  - 动态编译的可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态链接库的命令。
    - 其优点一方面是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省了系统资源。
    - 缺点是哪怕是很简单的程序，只用到了链接库的一两条命令，也需要附带一个相对庞大的链接库；二是如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行。


## C的内存模型

- 从低地址往高地址分别为：
- text segment(正文段,代码段):包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。
  - 通常正文段是可以共享的。一个程序可以同时执行`N`次，但是该程序的正文段在内存中只需要有一份而不是`N`份
  - 通常正文段是只读的，以防止程序由于意外而修改其指令
- data segment(初始化数据段)：存储程序中已初始化的非0全局变量和静态变量
- bss segment(未初始化数据段)：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0。这个段其实并不占用物理空间。
- heap（堆）：通常在堆中进行动态存储分配
  - 当进程未调用malloc时是没有堆段的，只有调用malloc时采用分配一个堆，并且在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。分配小内存时使用该区域。 
  - 堆的起始地址由mm_struct 结构体中的start_brk标识，结束地址由brk标识。
- memory mapping segment(映射区):存储动态链接库等文件映射、申请大内存（malloc时调用mmap函数）
- stack（栈）：自动变量以及每次函数调用时所需要保存的信息都存放在此段中，使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。
  - 在创建进程时会有一个最大栈大小，Linux可以通过ulimit命令指定。
- 存放命令行参数和环境变量

## C++的内存模型

- 在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。
- 栈：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
- 堆：就是那些由 new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个 delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。
- 自由存储区：就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。
- 全局/静态存储区：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。
- 常量存储区：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。常量字符串就在这
- 程序代码区：存放函数体的二进制代码。

## C++中的作用域

- 全局作用域
- 局部作用域
- 语句作用域
- 类作用域
- 命名空间作用域
- 文件作用域

## 全局变量、局部变量、静态全局变量、静态局部变量的区别

- 从作用域看：
  - 全局变量：具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用 extern 关键字再次声明这个全局变量。
  - 静态全局变量：具有文件作用域。它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被 static 关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。
  - 局部变量：具有局部作用域。它是自动对象（auto），在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。
  - 静态局部变量：具有局部作用域。它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。
- 从分配内存空间看：
  - 静态存储区：全局变量，静态局部变量，静态全局变量。
  - 栈：局部变量。

## 常见内存分配方式

- 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。
- 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
- 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。

## 限制对象只能建立在堆上

- **将构造函数设为私有是不可行的**
  - new 创建对象时，底层也会调用类的构造函数，将构造函数设置为私有后，那就无法在类的外部使用 new 创建对象了
- 方法一：**将析构函数设置为私有**
  - 静态对象建立在栈上，是由编译器分配和释放内存空间，编译器为对象分配内存空间时，会对类的非静态函数进行检查，即编译器会检查析构函数的访问性。当析构函数设为私有时，编译器创建的对象就无法通过访问析构函数来释放对象的内存空间，因此，编译器不会在栈上为对象分配内存。
  - 要自己提供一个释放资源的共有函数
```cpp
class A
{
public:
    A() {}
    void destory()
    {
        delete this;
    }

private:
    ~A()
    {
    }
};
```
- 方法二：**将构造函数设置为 protected，并提供一个 public 的静态函数来完成构造**，而不是在类的外部使用 new 构造；将析构函数设置为 protected。
- 原因：类似于单例模式，也保证了在派生类中能够访问析构函数。通过调用 create() 函数在堆上创建对象。
```cpp
class A
{
protected:
    A() {}
    ~A() {}

public:
    static A *create()
    {
        return new A();
    }
    void destory()
    {
        delete this;
    }
};
```

## 限制对象只能建立在栈上

- 将 operator new() 设置为私有。
- 原因：当对象建立在堆上时，是采用 new 的方式进行建立，其底层会调用 operator new() 函数，因此只要对该函数加以限制，就能够防止对象建立在堆上。

```cpp
class A
{
private:
    void *operator new(size_t t) {}    // 注意函数的第一个参数和返回值都是固定的
    void operator delete(void *ptr) {} // 重载了 new 就需要重载 delete
public:
    A() {}
    ~A() {}
};
```

## 内存对齐
- 为了使CPU能够对变量进行快速的访问，变量的起始地址应该具有某些特性，即所谓的“对齐
- 规则
  - 每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍，不是整数倍空出内存，直到偏移量是整数倍为止
  - 整个结构体的大小必须是里面变量类型最大值的整数倍
  - 结构体变量的首地址能够被其最宽基本类型成员的大小所整除
- 添加了#pragma pack(n)后
  - 偏移量要是n和当前变量大小中较小值的整数倍
  - 整体大小要是n和最大变量大小中较小值的整数倍
  - 结构首地址也是n和最大变量大小中较小值的整数倍
  - n值必须为1,2,4,8…，为其他值时就按照默认的分配规则
- 原因
  - 不是所有的硬件平台都能访问任意地址上的任意数据的；
  - 某些硬件设备不能保证在存取非对齐数据的时候的操作是原子操作
  - 为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。
- 优点
  - 便于在不同的平台之间进行移植，因为有些硬件平台不能够支持任意地址的数据访问，只能在某些地址处取某些特定的数据，否则会抛出异常；
  - 提高内存的访问效率，因为 CPU 在读取内存时，是一块一块的读取。

## malloc和new的区别
- 都用于内存的生态申请和释放
- 不同点
  - new是一个操作符，可以重载，malloc是一个库函数。 
  - new分配内存按照数据类型进行分配，自动计算要分配的空间大小，malloc分配内存按照指定的大小分配； 
  - new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化。 
  - new不仅分配一段内存，而且会调用构造函数，malloc不会。 
  - new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候会调用对象的析构函数，而free则不会。 
  - new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。 
  - 申请数组时：new[] 一次分配所有内存，多次调用构造函数，搭配使用delete[] ，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int) * n。

### new的实现原理

- new操作针对数据类型的处理，分为两种情况：
    - 简单数据类型（包括基本数据类型和不需要构造函数的类型）
        - 简单类型直接调用operator new分配内存；
    - 复杂数据类型（需要由构造函数初始化对象
        - 先调用operator new，然后在分配的内存上调用构造函数。
    - 可以通过new_handler来处理new失败的情况；
    - operator new实际调用了malloc
- delete也分为两种情况：
    - 简单数据类型（包括基本数据类型和不需要析构函数的类型
        - 简单的调用operator delete。
    - 复杂数据类型（需要由析构函数销毁对象）
        - 先调用析构函数再调用operator delete。
    - operator delete实际调用了free
- new[]也分为两种情况：
    - 简单数据类型（包括基本数据类型和不需要析构函数的类型）。
        - new[] 调用的是operator new[]，计算出数组总大小之后调用operator new。
    - 复杂数据类型（需要由析构函数销毁对象）
        - 针对复杂类型，new[]会额外存储数组大小。
        - new[]先调用operator new[]分配内存，然后在p的前四个字节写入数组大小
- delete[]也分为两种情况：
    - 简单数据类型（包括基本数据类型和不需要析构函数的类型）。
        - delete和delete[]效果一样
    - 复杂数据类型（需要由析构函数销毁对象）
        - 释放内存之前会先调用每个对象的析构函数。
        - new[] 分配的内存只能由delete[]释放。如果由delete释放会崩溃，为什么会崩溃呢？
        - 假设指针p指向new[] 分配的内存。因为要4字节存储数组大小，实际分配的内存地址为[ p-4]，系统记录的也是这个地址。delete[]实际释放的就是p-4指向的内存。而delete会直接释放p指向的内存，这个内存根本没有被系统记录，所以会崩溃。

### 重载new

- 重载operator new和operator delete就行
- 可以对单个类的new 和 delete操作符重载 
```cpp
void * operator new(size_t size){
    void *p = malloc(size);
    return (p);
}
void operator delete(void *p){
    free(p);
}

class TestClass {
    public:
    void *operator new(size_t size);
    void operator delete(void *p);
    void *operator new[](size_t size);
    void operator delete[](void *p);
    // .. other members here ...
};

```

## malloc,calloc,realloc

```cpp
// 分配足够的内存给大小为size的对象, 并返回指向所分配区域的第一个字节的指针
// 若内存不够,则返回NULL. 不对分配的空间进行初始化.
void *malloc(size_t size);
// 分配足够的内存给nobj个大小为size的对象组成的数组, 并返回指向所分配区域的第一个字节的指针;
// 若内存不够,则返回NULL. 该空间的初始化大小为0字节.
void *calloc(size_t nobj, size_t size);
// 将p所指向的对象的大小改为size个字节.
// 如果新分配的内存比原内存大, 那么原内存的内容保持不变, 增加的空间不进行初始化.
// 如果新分配的内存比原内存小, 那么新内存保持原内存的内容, 缩小的那一部分的内容会丢失
// realloc 并不保证调整后的内存空间和原来的内存空间保持同一内存地址。相反，realloc 返回的指针很可能指向一个新的地址
void *realloc(void *p, size_t size);
```
## malloc的实现原理

- 有一个将可用的内存块连接为一个长长的列表的所谓空闲链表
- 调用malloc函数时，沿连接表寻找一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二（一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节）。
- 接下来，将分配给用户的那块内存传给用户，并将剩下的那块（如果有的话）返回到连接表上
- 调用free函数时，它将用户释放的内存块连接到空闲链上

## realloc流程

- 对ptr进行判断，如果ptr为NULL，则函数相当于malloc(new_size)，试着分配一块大小为new_size的内存，如果成功将地址返回，否则返回NULL。如果ptr不为NULL，则进入2。
- 查看ptr是不是在堆中，如果不是的话会抛出realloc invalid pointer异常。
- 如果ptr在堆中，则查看new_size大小，如果new_size大小为0，则相当于free(ptr)，将ptr指向的内存空间释放掉，返回NULL。
- 如果new_size小于原大小，则ptr中的数据可能会丢失，只有new_size大小的数据会保存；
- 如果size等于原大小，等于什么都没有做；
- 如果size大于原大小，则查看ptr指向的位置还有没有足够的连续内存空间，如果有的话，分配更多的空间，返回的地址和ptr相同，如果没有的话，在更大的空间内查找，如果找到size大小的空间，将旧的内容拷贝到新的内存中，把旧的内存释放掉，则返回新地址，否则返回NULL。

## std::allocator

- allocator类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力，分配的内存是原始的、未构造的
  - new有一些灵活性上的局限，在它将内存分配和对象构造组合在了一起。可能会导致不必要的浪费
  - 分配单个对象时，通常希望将内存分配和对象初始化组合在一起。因为在���种情况下，我们几乎肯定知道对象应有什么值
  - 当分配一大块内存时，我们通常计划在这块内存上按需构造对象。在此情况下，我们希望将内存分配和对象构造分离
- 当一个allocator对象分配内存时，它会根据给定的对象类型来确定恰当的内存大小和对齐位置

```cpp
allocator<T> a;//定义一个allocator对象，可以为类型为T的对象分配内存
a.allocate(n);//分配一段原始的、未构造的内存，保存了n个类型未T的对象
a.deallocate(p,n);//释放内存，p必须是allocator返回的指针，且n必须是p创建时所要求的大小
a.construct(p,args);// 在p指向的内存中构造一个对象
a.destory(p);//析构p指向的内存
```



## 堆和栈的区别

- 申请方式和效率不同。
  - 栈由系统自动分配，速度快，申请效率高，不会有碎片。
  - 堆由程序员手动分配，速度慢，效率低，且会有碎片。
- 申请大小限制不同。
  - 栈顶和栈底是之前预设好的，大小固定，在内存中是连续的一块空间（向低地址扩展），可以通过ulimit -a查看，由ulimit -s修改。
  - 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。
- 存放的内容
  - 栈中存放的是局部变量，函数的参数；
  - 堆中存放的内容由程序员控制
- 申请后系统响应
  - 分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出
  - 申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上

## 栈溢出,stack overflow

- 

## 内存分配的常见错误和解决方法

- 内存分配未成功，却使用了它。
  - 在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行检查。如果是用malloc或new来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。
- 内存分配虽然成功，但是尚未初始化就引用它。
  - 犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。
- 内存分配成功并且已经初始化，但操作越过了内存的边界。
  - 例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。
- 忘记了释放内存，造成内存泄露。
  - 含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然挂掉，系统出现提示：内存耗尽。动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new/delete同理）。
- 释放了内存却继续使用它。常见于以下有三种情况：
  - 程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。
  - 函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。
  - 使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”

### 段错误

- 段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况： 
  - 访问了不存在的内存地址
  - 访问了系统保护的内存地址
  - 修改只读的内存地址(试图修改字符串常量的内容 )
  - 栈溢出
-   - 使用野指针 
  - 

### 内存溢出
- Out Of Memory
- 程序申请内存时，没有足够的内存供申请者使用
- 产生原因
  - 内存中加载的数据量过于庞大，如一次从数据库取出过多数据 
  - 代码中存在死循环或循环产生过多重复的对象实体 
  - 启动参数内存值设定的过小

### 内存泄漏 
- 内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。申请了一块内存空间，使用完毕后没有释放掉 
- 出现原因
  - 堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak. 
  - 系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。 
  - 没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。 
- 分类
  -  常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。
  -  偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。
  -  一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。
  -  隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。

### 防止内存泄漏的方法

- 内部封装：将内存的分配和释放封装到类中，在构造的时候申请内存，析构的时候释放内存。
  - 需要增加计数机制
- 智能指针


###  valgrind内存泄漏检测
- valgrind是个开源的工具，包含下列工具
    - **memcheck**:一个重量级的内存检查器，能够发现开发中绝大多数内存错误使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等。
    * callgrind:它主要用来检查程序中函数调用过程中出现的问题。
    * cachegrind:它主要用来检查程序中缓存使用出现的问题。
    * helgrind: 它主要用来检查多线程程序中出现的竞争问题。
    * massif: 它主要用来检查程序中堆栈使用中出现的问题。
    * extension: 可以利用core提供的功能，自己编写特定的内存调试工具
- memcheck

|                    内容                    |                                描述                                |
| :----------------------------------------: | :----------------------------------------------------------------: |
|             使用未初始化的内存             |                    Use of uninitialised memory                     |
|            使用已经释放了的内存            |          Reading/writing memory after it has been free’d           |
|       使用超过 malloc分配的内存空间        |           Reading/writing off the end of malloc’d blocks           |
|              对堆栈的非法访问              |          Reading/writing inappropriate areas on the stack          |
|            申请的空间是否有释放            | Memory leaks – where pointers to malloc’d blocks are lost forever  |
| malloc/free/new/delete申请和释放内存的匹配 |    Mismatched use of malloc/new/new [] vs free/delete/delete []    |
|               src和dst的重叠               | Overlapping src and dst pointers in memcpy() and related functions |

- 使用操作
    - gcc 编译时加上-g，保留调试信息
    - valgrind工具使用: `valgrind --tool=tool_name program_name`
    - memcheck工具使用: `valgrind --tool=memcheck --leak-check=full --show-reachable=yes --trace-children=yes`
        - 其中–leak-check=full 指的是完全检查内存泄漏，
        - –show-reachable=yes是显示内存泄漏的地点，
        - –trace-children=yes是跟入子进程。
        - 根据需要添加
    - 当程序正常退出的时候valgrind自然会输出内存泄漏的信息原理
        - Memcheck将内存泄露分为两种，一种是可能的内存泄露（Possibly lost），另外一种是确定的内存泄露（Definitely lost）。
        - Possibly lost 是指仍然存在某个指针能够访问某块内存，但该指针指向的已经不是该内存首地址。
        - Definitely lost 是指已经不能够访问这块内存。而Definitely lost又分为两种：直接的（direct）和间接的（indirect）。直接和间接的区别就是，直接是没有任何指针指向该内存，间接是指指向该内存的指针都位于内存泄露处

### mtrace检测内存泄露
- mtrace是GNU扩展函数，是Linux自带工具，用来跟踪malloc。
- mtrace为内存分配函数（malloc, realloc, memalign, free）安装hook函数。这些hook函数记录内存的申请和释放的trace信息。
- 当调用mtrace，mtrace会检查环境变量MALLOC_TRACE。该环境变量应该包含记录trace信息的文件路径。如果文件可以被成功打开，它的大小被截断为0。* 如果MALLOC_TRACE没有设置，或者设置的文件不可用或者不可写，那么将不会安装hook函数，mtrace不生效。
- 使用操作
    - 在程序的起始处包含头文件 `#include <mcheck.h>`
    - 更改环境变量：`setenv("MALLOC_TRACE", "mtrace.out", 1)` mtrace.out是文件名可修改
    - 调用函数mtrace()
    - 编译程序带上 -g 选项
    - 运行程序一次，尽量调用所有程序内的函数。这时调试信息就已经被写入我们指定的mtrace.out文件中
    - `mtrace a.out  mtrace.out` 查看内存监测情况

## 原子操作如何实现

- 原子操作的定义
  - 由多步操作组成的一个操作。如果该操作不能原子地执行，则要么执行完所有步骤，要么一步也不执行，不可能只执行所有步骤的一个子集。
- 处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址
- 处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性
- 总线锁
  - 使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。
  - 在同一时刻，我们只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，
- 缓存锁
  - 频繁使用的内存会缓存在处理器的L1、L2和L3高速缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁

# 4. 指针，引用，数组

- 数组：数组是用于储存多个相同类型数据的集合。数组名是首元素的地址。
- 指针：指针相当于一个变量，但存放的是其它变量在内存中的地址。指针名指向了内存的首地址。
- 引用：相当于变量的别名

## 4.1 引用和指针的区别

- 指针本身在内存中占有内存空间，引用相当于变量的别名，在内存中不额外占内存空间
- 使用sizeof看一个指针的大小是4/8，而引用则是被引用对象的大小； 
- 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用
- 指针在初始化后可以改变指向，而引用在初始化之后不可再改变
- 可以有const指针，但是没有const引用； 
- 指针可以有多级指针（**p），而引用只有一级； 
- 从汇编层次来看，引用是通过指针来实现的。

## 4.2 指针的作用

- 允许以更简洁的方式引用大的数据结构
  - 数据传递时，如果数据块较大（比如说数据缓冲区或比较大的结构），这时就可以使用指针传递地址而不是实际数据，即提高传输速度，又节省大量内存
- 使程序的不同部分能够共享数据 
- 可以进行动态内存分配
- 通过指针被调用函数可以向调用函数处返回除正常的返回值之外的其他数据，从而实现两者间的双向通信。

## 4.3 野指针

- 不确定其指向的指针，没有被初始化过的指针
- 产生原因及解决办法：
    - 指针变量未及时初始化 => 定义指针变量及时初始化，要么置空。

## 4.4 悬空指针

- 指针最初指向的内存已经被释放了的一种指针
- 产生原因及解决办法：
  - 指针free或delete之后没有及时置空 => 释放操作后立即置空。

## 4.5 使用指针需要注意什么

- 定义指针时，先初始化为NULL。
- 用malloc申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。在现行C++标准中，如C++11，使用new申请内存后不用判空，因为发生错误将抛出异常。
- 不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。
- 避免数字或指针的下标越界，特别要当心发生“多1”或者“少1”操作
- 动态内存的申请与释放必须配对，防止内存泄漏
- 用free或delete释放了内存之后，立即将指针设置为NULL，防止“悬空指针”

## 4.6 字符数组和指针的区别
- 字符指针
  - 可以看成是指向常量字符串的指针，如果不加const编译时会有警告
  - 指向的是一个字符串常量的首地址，位于常量存储区
  - 所以不能改变所指向的内容
  - 但可以++，--，或者指向另一个字符串常量
- 字符串数组
  - 字符数组之间不能赋值，不能直接用比较运算符直接比较，若进行赋值调用 strcpy() 函数，若进行比较调用 strcmp() 函数
  - 可以看成是常量指针，不能++，--，但可以修改数组的内容
- 运算符 sizeof 可以计算出字符数组的容量，但是计算字符指针时，得到的是指针变量所占用的空间，而不是指针所指向空间的大小。
- 当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。
- c/c++把常量字符串放到单独的一个内存空间（代码段的字符串常量区）。因此当几个指针赋值给相同的常量字符串时，它们实际上会指向相同的内存地址
```cpp
int main()
{
    // string1和string2的地址不一样
    char string1[] = "hello world";
    char string2[] = "hello world";
    // str1个str1的地址一样
    const char* str1 = "hello world";  // 不加const会有警告
    const char* str2 = "hello world";
    // 下面是可以操作的语句
    str1++;
    str1="new hello world";
    str1=str2;
    strcpy(string1,"new hello world");
    strcmp(string1, string2);
    string1[0]='2';
    // 下面是报错的语句
    string1++;
    string1=string2;
    string1="new";
    str1[0]='2';
}
```
------------------------

# 5. C++关键字

## 5.1 变量声明和定义区别

- 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。
- 相同变量可以在多处声明（外部变量extern），但只能在一处定义。

## 5.2 全局变量和局部变量

- 生命周期不同
  - 全局变量随主程序创建和创建，随主程序销毁而销毁；
  - 局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；
- 使用方式不同
  - 通过声明后全局变量在程序的各个部分都可以用到；
  - 局部变量分配在堆栈区，只能在局部使用。
- 内存存储方式不同
  - 全局变量分配在全局数据段并且在程序开始运行的时候被加载。
  - 局部变量则分配在堆栈里面 。

## 5.3 static的作用

- **限制作用域**
  - 针对全局变量和函数
  - 当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性
  - 加了static的静态函数和全局静态变量只在声明他的文件当中可见，不能被其他文件所用
  - 不要在头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰
- **改变生命期**
  - 针对局部变量
  - 本来存储在栈上，离开作用域就会销毁。
  - 局部静态变量存储在静态存储区，离开作用域后，并没有销毁，再次调用函数时保持上一次的值
- **默认初始化为0**
- **类的静态成员**
  - 被static修饰的类成员变量和成员函数，它们是属于类的，被类的所有对象共享，而不是某个对象的成员

## C和C++，static的区别

- 在c++中，不仅支持传统C语言中static的特性，如：全局静态函数，局部静态变量，静态函数等
- 还对static进行了扩展，支持静态数据成员，静态函数成员，静态对象等。

## volatile关键字
- volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去内存重新读取这个变量的值，而不是读寄存器内的备份。
- 多线程中被几个任务共享的变量需要定义为volatile类型。

## restrict关键字
- 用于告诉编译器，对象已经被指针所引用，不能通过除该指针外所有其他直接或间接的方式修改该对象的内容

## 寄存器变量，register

- 如果幸运的话，寄存器变量储存在 CPU 的寄存器中，或者概括地说，储存在最快的可用内存中。
- 与普通变量相比，访问和处理这些变量的速度更快。
- 由于寄存器变量储存在寄存器而非内存中，所以无法获取寄存器变量的地址

## 四个cast转换关键字 
- C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast   
- const_cast 
  - 用于将底层const变量转为非const 
  - 不能用于去掉变量的常量性，只能用于去除指针或引用的常量性，将常量指针转化为非常量指针或者将常量引用转化为非常量引用
- static_cast 
  - 用于各种隐式转换，比如顶层非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知； 
- dynamic_cast
  - 用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。   
  - 向上转换：指的是派生类向基类的转换   
  - 向下转换：指的是基类向派生类类的转换   
  - 它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。  
  - 其他三种都是编译时完成的，动态类型转换是在程序运行时处理的，运行时会进行类型检查。
  - 在向上进行转换时，即派生类类的指针转换成基类类的指针和 static_cast 效果是一样的 
- reinterpret_cast 
  - 几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用； 
- 为什么不使用C的强制转换？ 
  - C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。 

## const作用及用法
- const修饰普通类型的变量，告诉编译器某值是保持不变的。
- const类型变量定义的时候必须进行初始化
- const修饰指针变量
  - 指向常量的指针：指针指向一个常量对象，目的是防止使用该指针来修改指向的值。
  - 常指针：将指针本身声明为常量，这样可以防止改变指针指向的位置。
  - 指向常量的常指针：一个常量指针指向一个常量对象。
- const修饰函数形参
  - 值传递的 const 修饰传递，一般这种情况不需要 const 修饰
  - 当 const 参数为指针时，可以防止指针被意外篡改。
  - 自定义类型的参数传递，需要临时对象复制参数，对于临时对象的构造，需要调用构造函数，比较浪费时间，因此我们采取 const 外加引用传递的方法。
- const修饰函数返回值
  - const 修饰内置类型的返回值，修饰与不修饰返回值作用一样。
  - const 修饰自定义类型的作为返回值，此时返回的值不能作为左值使用，既不能被赋值，也不能被修改。
  - const 修饰返回的指针或者引用，是否返回一个指向 const 的指针，取决于我们想让用户干什么。
- const修饰成员函数
  - const 修饰类成员函数，其目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为 const 成员函数

## 顶层const和底层const

- 顶层const：指的是const修饰的变量本身是一个常量，无法修改，指的是指针，就是 * 号的右边
- 底层const：指的是const修饰的变量所指向的对象是一个常量，指的是所指变量，就是 * 号的左边
- 执行对象拷贝时有限制，常量的底层const不能赋值给非常量的底层const(但反过来可以)
- 使用命名的强制类型转换函数const_cast时，只能改变运算对象的底层const
  
```cpp
int a = 10;
int* const b1 = &a;        //顶层const，b1本身是一个常量
const int* b2 = &a;        //底层const，b2本身可变，所指的对象是常量
const int b3 = 20;         //顶层const，b3是常量不可变
const int* const b4 = &a;  //前一个const为底层，后一个为顶层，b4不可变
const int& b5 = a;         //用于声明引用变量，都是底层const
```

## const和constexpr

- 常量表达式constexpr,值不会发生改变并且在编译器就能得到计算结果的表达式
  - const并未区分出编译期常量和运行期常量
  - constexpr限定在了编译期常量
  - constexpr指针必须为nullptr或者固定地址的值，可以用定义于函数体之外的对象初始化
  - constexpr仅对指针有效，对指针所指的对象无关，只能加顶层的const
- 原本的const有两种用途：只读，常量。后来把常量的含义给了constexpr
  - “只读”不意味着其不能被修改
  - “只读”只是无法通过变量自身去修改自己的值。可以借助其它变量间接改变
- 一个值是否是常量，可以通过它能否用来初始化array容器判断
- constexpr修饰的函数，简单的来说，如果其传入的参数可以在编译时期计算出来，那么这个函数就会产生编译时期的值。但是，传入的参数如果不能在编译时期计算出来，那么constexpr修饰的函数就和普通函数一样了
- 总的来说在 C++ 11 标准中，const 用于为修饰的变量添加“只读”属性；而 constexpr 关键字则用于指明其后是一个常量（或者常量表达式），编译器在编译程序时可以顺带将其结果计算出来，而无需等到程序运行阶段，这样的优化极大地提高了程序的执行效率
```cpp
void dis_1(const int x){
    //错误，x是只读的变量
    array <int,x> myarr{1,2,3,4,5};
    cout << myarr[1] << endl;
}
void dis_2(){
    const int x = 5;// 没有错，但标准的写法应该是 constexpr int x=5;
    array <int,x> myarr{1,2,3,4,5};// 成功
    cout << myarr[1] << endl;
}
// con_b是只读的，但它的值通过a改变了
{
    int a = 10;
    const int & con_b = a;
    cout << con_b << endl;
    a = 20;
    cout << con_b << endl;
}
// constexpr函数的用法
constexpr int sqr1(int arg){
    return arg*arg;
}
const int sqr2(int arg){
    return arg*arg;
}
int main()
{
    int i=10;
    array<int,sqr1(10)> mylist1;//可以，因为sqr1时constexpr函数i
    array<int,sqr2(10)> mylist1;//不可以，因为sqr2不是constexpr函数
    array<int,sqr1(i)> mylist1;//不可以，无法在编译期得到值
    return 0;
}
```

## const和#define区别

- 编译阶段。define 是在编译预处理阶段进行替换，const 是在编译阶段确定其值。
- 安全性。define 定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全的检查；const 定义的常量是有类型的，是要进行判断的，可以避免一些低级的错误。
- 内存占用。define 定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份，占用的是代码段的空间；const 定义的常量占用静态存储区的空间，程序运行过程中只有一份。
- 调试。define 定义的宏常量不能调试，因为在预编译阶段就已经进行替换了；const 定义的常量可以进行调试。
- define预处理后，占用代码段空间，const占用数据段空间；
- const不能重定义，而define可以通过#undef取消某个符号的定义，进行重定义；
- define独特功能，比如可以用来防止文件重复引用。

## entern

- 用于变量和函数的声明
  - a.c需要引用b.c中变量int v，就可以在a.c中声明extern int v，
- extern "C"

## extern "C"
- 在程序中加上extern "C"后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++
- 在C++中调用C库函数，就需要在C++程序中用extern “C”声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。
- 主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同。
  - 由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；
  - 而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。

## struct 和 class 的区别
- struct 和 class 都可以自定义数据类型，也支持继承操作
  - struct 中默认的访问级别是 public，默认的继承级别也是 public
  - class 中默认的访问级别是 private，默认的继承级别也是 private

## C++和C的struct区别

- C语言中：struct是用户自定义数据类型（UDT）；C++中struct是抽象数据类型（ADT），支持成员函数的定义，（C++中的struct能继承，能实现多态）
- C中struct是没有权限的设置的，且struct中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员不可以是函数
- C++中，struct增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为public（为了与C兼容）
- struct作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在C中必须在结构标记前加上struct，才能做结构类型名（除：typedef struct class{};）;C++中结构体标记（结构体名）可以直接作为结构体类型名使用

## strlen 和 sizeof区别

- sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数（头文件 <cstring>） 。
- sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是'\0'的字符串。
- 因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。
- 对字符指针得到的结果不同
  - sizeof得到的是指针的大小
  - strlen得到的是字符串的长度

## NULL和nullptr

- NULL来自C语言，一般由宏定义实现
  - C语言中，NULL被定义为(void*)0,而在C++语言中，NULL则被定义为整数0
  - 出现C++和C定义不一致的原因是，在C++中不允许(void*)类型进行隐式转换
  - 但将NULL定义为0带来的另一个问题是无法与整数的0区分
- nullptr 则是C++11的新增关键字
  - nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型
```cpp
#ifdef __cplusplus
#define NULL 0
#else
#define NULL ((void *)0)
#endif


const class nullptr_t//表示nullptr是一个类常量对象
{
public:
    template<class T>//为了给普通变量指针赋值为0
    inline operator T*() const
        { return 0; }
 
    template<class C, class T>// 为了给类的成员指针变量赋予空指针
    inline operator T C::*() const
        { return 0; }
 
private:
    void operator&() const;// 禁用&
} nullptr = {};
```

## auto、decltype和decltype(auto)的用法
  
- auto,自动类型推导
  - 在编译期间通过初始值推导出变量的类型
  - auto 定义的变量必须有初始值
  - 会忽略顶层const和引用
```cpp
//普通；类型
int a = 1, b = 3;
auto c = a + b;// c为int型

//const类型
const int i = 5;
auto j = i; // 变量i是顶层const, 会被忽略, 所以j的类型是int
auto k = &i; // 变量i是一个常量, 对常量取地址是一种底层const, 所以b的类型是const int*
const auto l = i; //如果希望推断出的类型是顶层const的, 那么就需要在auto前面加上cosnt

//引用和指针类型
int x = 2;
int& y = x;
auto z = y; //z是int型不是int& 型
auto& p1 = y; //p1是int&型
auto p2 = &x; //p2是指针类型int*
```

- decltype
  - 和auto的功能一样，都用来在编译时期进行自动类型推导
  - 希望从表达式中推断出要定义变量的类型，但却不想用表达式的值去初始化变量
  - 选择并返回操作数的数据类型。在此过程中，编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值。
  - 会保留顶层const和引用
```cpp
int func() {return 0};

//普通类型
decltype(func()) sum = 5; // sum的类型是函数func()的返回值的类型int, 但是这时不会实际调用函数func()
int a = 0;
decltype(a) b = 4; // a的类型是int, 所以b的类型也是int

//不论是顶层const还是底层const, decltype都会保留   
const int c = 3;
decltype(c) d = c; // d的类型和c是一样的, 都是顶层const
int e = 4;
const int* f = &e; // f是底层const
decltype(f) g = f; // g也是底层const

//引用与指针类型
//1. 如果表达式是引用类型, 那么decltype的类型也是引用
const int i = 3, &j = i;
decltype(j) k = 5; // k的类型是 const int&

//2. 如果表达式是引用类型, 但是想要得到这个引用所指向的类型, 需要修改表达式:
int i = 3, &r = i;
decltype(r + 0) t = 5; // 此时是int类型

//3. 对指针的解引用操作返回的是引用类型
int i = 3, j = 6, *p = &i;
decltype(*p) c = j; // c是int&类型, c和j绑定在一起

//4. 如果一个表达式的类型不是引用, 但是我们需要推断出引用, 那么可以加上一对括号, 就变成了引用类型了
int i = 3;
decltype((i)) j = i; // 此时j的类型是int&类型, j和i绑定在了一起
```

- decltype(auto)
  - 是C++14新增的类型指示符
  - 会将“=”号左边的表达式替换掉auto，再根据decltype的语法规则来确定类型


## define 和 typedef 的区别

- 原理
  - #define 作为预处理指令，在编译预处理时进行替换操作，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。
  - typedef 是关键字，在编译时处理，有类型检查功能，用来给一个已经存在的类型一个别名，但不能在一个函数定义里面使用 typedef 。
- 功能
  - typedef 用来定义类型的别名，方便使用。
  - #define 不仅可以为类型取别名，还可以定义常量、变量、编译开关等。
- 作用域
  - #define 没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，
  - 而 typedef 有自己的作用域。
- 指针的操作
  - typedef 和 #define 在处理指针时不完全一样
- 宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束

## 为什么要少使用宏？C++有什么解决方案？

- 由程序编译的四个过程，知道宏是在预编译阶段被展开的。在预编译阶段是不会进行语法检查、语义分析的，宏被暴力替换，正是因为如此，如果不注意细节，宏的使用很容易出现问题。比如在表达式中忘记加括号等问题。
- 不带参数的宏命令我们可以用常量const来替代，比如const int PI = 3.1415，可以起到同样的效果，而且还比宏安全，因为这条语句会在编译阶段进行语法检查。
- 而带参数的宏命令有点类似函数的功能，在C++中可以使用内联函数或模板来替代，内联函数与宏命令功能相似，是在调用函数的地方，用函数体直接替换。但是内联函数比宏命令安全，因为内联函数的替换发生在编译阶段，同样会进行语法检查、语义分析等，而宏命令发生在预编译阶段，属于暴力替换，并不安全
- typedef替换

## goto

- 功能
  - 从多重循环中直接跳出
    - break只能跳出单层的循环，return将整个函数都返回了
  - 出错时清除资源
- 缺点
  - 破坏了清晰的程序结构，使程序的可读性变差
  - 可能跳过了某些对象的构造、变量的初始化、重要的计算等语句

## noexcept

- 告诉编译器，函数中不会发生异常,会给编译器更大的优化空间
- 如果在运行时，noexecpt函数向外抛出了异常（如果函数内部捕捉了异常并完成处理，这种情况不算抛出异常），程序会直接终止，调用std::terminate()函数，该函数内部会调用std::abort()终止程序。
- 等于throw()
- 以下情形鼓励使用noexcept
  - 移动构造函数（move constructor）
  - 移动分配函数（move assignment）
  - 析构函数（destructor）

## __attribute__ 机制
https://blog.csdn.net/weaiken/article/details/88085360
-----------------------------
# 6. 类相关问题

## C++结构体和C结构体的区别

- C的叫用户自定义数据类型，C++叫抽象数据类型
- C的结构体内不允许有函数存在，C++允许有内部成员函数，且允许该函数是虚函数。
- C的结构体对内部成员变量的访问权限只能是public，而C++允许public,protected,private三种。
- C语言的结构体是不可以继承的，C++的结构体是可以从其他的结构体或者类继承过来的。
- C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用。

## 结构体和共用体的区别
- struct和union都是由多个不同的数据类型成员组成。 struct的所有成员都存在；但在任何同一时刻, union中只存放了一个被选中的成员。
- struct变量的总长度等于所有成员长度之和。Union变量的长度等于最长的成员的长度。
- struct的不同成员赋值是互不影响的；而对于union的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了。

## 匿名的union

- 将一个 union 包括在一个结构(structure)的定义中，并且不赋予它对象(object)名称 (就是跟在花括号{}后面的名字)，这个union 就是匿名的。
- 这种情况下我们可以直接使用 union 中元素的名字来访问该元素，而不需要再在前面加 union 对象的名称。

## 获取类的成员相对于类的起始位置的偏移

- `#include <stddef.h>    size_t offsetof(structName, memberName);`
- 实现原理是`#define offsetof(s, m)   (size_t)&(((s *)0)->m)`
  - s是一个结构名，它有一个名为m的成员（s和m 是宏offsetof的形参，它实际是返回结构s的成员m的偏移地址.
  - (s *)0 是骗编译器说有一个指向类（或结构）s的指针，其地址值0 
  - &(((s *)0)->m)   是要取得类s中成员变量m的地址. 因基址为0，这时m的地址当然就是m在s中的偏移
  - 最后转换size_t 型，即unsigned int。

## struct 和 class 的区别

- struct 中默认的访问控制权限是 public 的，而 class 中默认的访问控制权限是 private 的
- 在继承关系中，struct 默认是公有继承，而 class 是私有继承
- class 关键字可以用于定义模板参数，就像 typename，而 struct 不能用于定义模板参数

## 嵌套类

- 常用于定义作为实现部分的类
- 是一个独立的类，和外层类没什么关系。没有特殊的访问权限，也不包含彼此的成员
- 必须声明在类的内部，但可以定义在类的内部或外部
- 在类外定义嵌套类的成员时，要使用外层类的名字限定嵌套类的名字

## 组合和继承

- 继承
  - 继承是Is a 的关系，比如说Student继承Person,则说明Student is a Person。
  - 继承的优点是子类可以重写父类的方法来方便地实现对父类的扩展。
  - 继承的缺点有以下几点：
    - 父类的内部细节对子类是可见的。
    - 子类从父类继承的方法在编译时就确定下来了，所以无法在运行期间改变从父类继承的方法的行为。
    - 如果对父类的方法做了修改的话（比如增加了一个参数），则子类的方法必须做出相应的修改。所以说子类与父类是一种高耦合，违背了面向对象思想。
- 组合
  - 组合也就是设计类的时候把要组合的类的对象加入到该类中作为自己的成员变量。
  - 组合的优点：
    - 当前对象只能通过所包含的那个对象去调用其方法，所以所包含的对象的内部细节对当前对象时不可见的。
    - 当前对象与包含的对象是一个低耦合关系，如果修改包含对象的类中代码不需要修改当前对象类的代码。
    - 当前对象可以在运行时动态的绑定所包含的对象。可以通过set方法给所包含对象赋值。
  - 组合的缺点
    - 容易产生过多的对象
    - 为了能组合多个对象，必须仔细对接口进行定义

## 对象复用

- 将对象存储到“对象池”中实现对象的重复利用，这样可以避免多次创建重复对象的开销，节约系统资源

## 零拷贝

- 一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。
- 零拷贝技术可以减少数据拷贝和共享总线操作的次数。

## C++空类有哪些成员函数
- 空类大小为1字节。
- 默认函数有：默认构造函数，析构函数，拷贝构造函数，赋值运算符
- 还有两个取址函数`A *operator&() { return this; }; `，和const版本

## 类大小的计算

- 类的大小遵循结构体的对齐规则
- 类的大小与普通成员函数和静态成员无关（包括：普通成员函数、静态成员函数、静态数据成员、静态常量数据成员），与普通数据成员有关
- 虚函数对类的大小有影响，是因为虚函数指针的影响
- 虚继承对类的大小有影响，是因为虚基表指针带来的影响
```cpp
class A{
    //静态成员
    static int a;
    const static int b;    
    static int fun1(){}

    //普通成员函数
    void fun(){}
};

//普通数据成员
class B{
    int a;    
};

//虚函数
class C{
    virtual int fun(){}
};

//结构体对齐原则
class D{
    int a;
    virtual int fun(){}
};

int main(){
    cout << sizeof(A) << endl;//1
    cout << sizeof(B) << endl;//4:表示一个整型变量的大小
    cout << sizeof(C) << endl;//8：虚函数表的指针的大小
    cout << sizeof(D) << endl;//16：整型变量的大小+虚函数指针的大小+对齐原则（4）
    return 0;
}
```

## 友元

- 通过友元，一个不同函数或另一个类中的成员函数可以访问类中的私有成员和保护成员。
- 包括友元函数和友元类

## 有哪几种构造函数

- 默认构造函数
- 初始化构造函数（有参数）
- 拷贝构造函数
- 移动构造函数（move和右值引用）
- 委托构造函数
- 转换构造函数

## 为什么用成员初始化列表会快一些

- 数据类型可分为内置类型和用户自定义类型（类类型），对于用户自定义类型，利用成员初始化列表效率高。
- 原因：
  - 用户自定义类型如果使用类初始化列表，直接调用该成员变量对应的构造函数即完成初始化；
  - 如果在构造函数中初始化，因为 C++ 规定，对象的成员变量的初始化动作发生在进入构造函数本体之前，那么在执行构造函数的函数体之前首先调用默认的构造函数为成员变量设初值，在进入函数体之后，调用该成员变量对应的构造函数。因此，使用列表初始化会减少调用默认的构造函数的过程，效率高。
  - 在函数体内，先额外调用一次默认构造函数


## 构造函数和析构函数调用时机

- 全局范围中的对象：构造函数在所有函数调用之前执行，在主函数执行完调用析构函数。
- 局部自动对象：建立对象时调用构造函数，离开作用域时调用析构函数。
- 动态分配的对象：建立对象时调用构造函数，调用释放时调用析构函数。
- 静态局部变量对象：建立时调用一次构造函数，主函数结束时调用析构函数。

## 构造函数、析构函数、虚函数可否声明为内联函数

- 首先，将这些函数声明为内联函数，在语法上没有错误。只是个建议，编译器并不一定真正的内联。
- 编译器并不真正对声明为inline的构造和析构函数进行内联操作
  - 编译器会在构造和析构函数中添加额外的操作（申请/释放内存，构造/析构对象等），致使构造函数/析构函数并不像看上去的那么精简
- 如果虚函数在编译器就能够决定将要调用哪个函数时，就能够内联
  - 即当用对象调用虚函数（此时不具有多态性）时
- 当是指向派生类的指针或引用（多态性）调用声明为inline的虚函数时，不会内联展开；
- 当是对象本身调用虚函数时，会内联展开，当然前提依然是函数并不复杂的情况下

## 构造与析构的顺序
- 构造顺序：基类构造函数》对象成员构造函数》子类构造函数
- 析构顺序：子类析造函数》对象成员析造函数》基类析造函数
- 从里向外构造，从外向里析构

## 类什么时候会析构

- 对象生命周期结束，被销毁时；
- delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类虚构函数是虚函数时；
- 对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。

## explict

- 避免编译器进行隐式类型转换
- 只可用于修饰单参构造函数，因为无参构造函数和多参构造函数本身就是显示调用的

## 构造函数与析构函数不能被继承

- https://www.cnblogs.com/zzdbullet/p/10470681.html

## this指针

- this指针是类的指针，指向对象的首地址。
- this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。
- 是类非静态成员函数的隐含形参
  - 函数体中对各成员的访问均通过this进行
  - 成员函数默认第一个参数为`T * const this`
  - this在成员函数的开始前构造，在成员函数的结束后清除
- 使用场景
  - 在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；
  - 当形参与成员变量名相同时用于区分，如this->n = n （不能写成n = n）

## nullptr能否调用成员函数

- 如果函数中没有需要解引用this的地方，函数运行不会出错
- 但是若用到this，因为this=nullptr，运行出错。
```cpp
class animal{
public:
    void sleep(){ cout << "animal sleep" << endl; }
    void breathe(){ cout << "animal breathe haha" << endl; }
};
class fish :public animal{
public:
    void breathe(){ cout << "fish bubble" << endl; }
};
int main(){
    animal *pAn=nullptr;
    pAn->breathe();   // 输出：animal breathe haha
    fish *pFish = nullptr;
    pFish->breathe(); // 输出：fish bubble
    return 0;
}  
```

## 拷贝构造函数和赋值运算符重载的区别
- 拷贝构造函数是函数，赋值运算符是运算符重载。
- 拷贝构造函数会生成新的类对象，赋值运算符不能。
- 拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉。

## 类的静态成员

- 静态成员
  - 静态成员是类的所有对象中共享的成员，而不是某个对象的成员，属于整个类，而不属于某个对象
  - 在类内进行声明，在类外进行初始化，在类外进行定义和初始化的时候不要出现 static 关键字和private、public、protected 访问规则
  - 只有const的静态成员可以在类内初始化，但也要在类外定义一下，类外定义不能再指定一个初始值
  - 被类的所有对象所共享，包括派生类的对象。
  - 可以作为成员函数的参数可选参数，而普通成员变量不可以
  - 静态数据成员的类型可以是所属类的类型，而普通数据成员不可以，普通数据成员只可能声明成类的指针或引用
- 静态成员函数
  - 静态成员函数不能调用非静态成员变量或者非静态成员函数，因为静态成员函数没有 this 指针。
  - 静态成员函数不能声明成虚函数（virtual）、const 函数和 volatile 函数。
    - 静态成员不属于任何类对象或类实例，所以即使加上virtual也没有任何意义
    - 静态成员函数没有this指针。调用类中的虚函数时，是通过虚表以及指向虚表的指针vptr才能完成虚函数的调用，并且只能用this指针来访问。对于静态成员函数没有this指针，无法访问vptr.
    - 当声明一个类（Test）的非静态成员函数为const时，this指针相当于Test const *，对于非const成员函数，this指针相当于Test *. 但是static成员函数没有this指针，所以用const来修饰static没有任何意义。（volatile的道理也是如此）

## 类的初始值

- 通常情况下，不应该在类内部初始化成员！！无论是否为静态、是否为常量、是否为int等！！统统不建议在类内初始化，因为本质上类只是声明，并不分配内存，而初始化会分配内存，类内初始化会将两个过程混在一起！
- 不能用`()`初始化，因为会被识别为函数
- 在类内初始化静态成员，那么就必须满足如下条件才行：
  - 静态成员必须为字面值常量类型：constexpr。
  - 给静态成员提供的初始值，必须为常量表达式
- 非静态的普通变量和常量变量都可以类内初始化

## 类的const成员

- const成员变量：
  - const成员变量只能在类内初始化，或者在构造函数初始化列表中初始化。
- const成员函数
  - 使得成员函数不能修改任何类型的成员变量（mutable 修饰的变量除外)
  - 不能调用非const成员函数，因为非const成员函数可能会修改成员变量。
- const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员；
- 非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；

## mutable

- 如果需要在const成员方法中修改一个成员变量的值，那么需要将这个成员变量修饰为mutable。
- 用mutable修饰的成员变量不受const成员方法的限制;


## delete this
- 成员函数中
  - 在类的成员函数可以调用delete this，并且delete this之后还可以调用该对象的其他成员，但是有个前提：被调用的方法不涉及这个对象的数据成员和虚函数。
  - 当一个类对象声明时，系统会为其分配内存空间。在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。
  - 当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题，即上面出现的随机值。
  - 为什么会出现这种情况？delete this之后不是释放了类对象的内存空间了么，那么这段内存应该已经还给系统，不再属于这个进程。照这个逻辑来看，应该发生指针错误，无访问权限之类的令系统崩溃的问题才对啊？这个问题牵涉到操作系统的内存管理策略。delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。当你获取数据成员，可能得到的是一串很长的未初始化的随机数；访问虚函数表，指针无效的可能性非常高，造成系统崩溃。
- 析构函数中
  - delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。


## 合成默认构造函数
- 类没有定义其他构造函数
- 并不是任何没有构造函数的类都会合成一个构造函数
- 满足以下条件
  - 含有一个成员对象，该成员对象含有默认构造函数
  - 派生自一个带有默认构造函数的基类
  - 带有虚函数的类，需要构造虚函数表指针
  - 带有一个虚基类的类，需要构造虚基表指针

## 拷贝构造函数
- **合成的拷贝构造函数**
  - 即使我们定义了其他构造函数,编译器也会为我们生成合成拷贝构造函数
  - 从给定的对象依次将每个非static成员拷贝到正在创建的对象中
  - (只要有其他构造函数定义,编译器不会帮你生成合成默认构造函数）
  - 需要满足的条件和合成默认构造函数类似
- 直接初始化:一般在 "()" 调用时发生
- 拷贝初始化不仅在我们使用 "=" 时发生,下列三种情况也会发生
  1. 将一个对象作为实参传递给非引用类型的形参时.
  2. 从一个返回类型为非引用类型的函数返回参数.
  3. 使用花括弧列表初始化一个数组中的元素或聚合类的成员

## 移动构造函数

- 移动构造函数的参数是一个右值或者将亡值的引用
- 避免了新的空间的分配，大大降低了构造的成本


## 深拷贝和浅拷贝的区别
- 如果一个类拥有资源，该类的对象进行复制时，如果资源重新分配，就是深拷贝，否则就是浅拷贝。
- 浅拷贝
  - 浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址
  - 原地址中对象被改变,浅拷贝复制出来的对象也会相应改变
  - 原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。
- 深拷贝
  - 不仅拷贝值，还开辟出一块新的空间用来存放新的值
  - 两个对象之间没有任何关系，各自成员地址不同。
  - 即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值
  
  
## 哪几种情况必须用到初始化成员列表

- 有成员类型是没有默认构造函数的类，必须显示初始化
- 初始化一个const成员。
- 初始化一个reference成员。
- 调用一个基类的构造函数，而该函数有一组参数。
- 调用一个数据成员对象的构造函数，而该函数有一组参数。

## 什么是类的继承
- 一个类继承了另一个类的属性和方法
- 子类对象可以当做父类对象使用

## public，protected和private访问和继承权限/public/protected/private的区别？

- 访问权限
  - public的变量和函数在类的内部外部都可以访问。
  - protected的变量和函数只能在类的内部和其派生类中访问。
  - private修饰的元素只能在类内访问。

## 重载，重写（覆盖）和隐藏

- 重载(overload)
  - 在同一范围定义中的同名成员函数
  - 函数名相同但参数列表不同（个数、类型或顺序)，返回值无所谓
  - 不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数
  - 调用函数时根据传递的参数列表来确定具体调用哪个函数
  - 重载和函数成员是否是虚函数无关
  - 虚函数也能重载
- 重写（覆盖）（override）
  - 在派生类中覆盖基类中的同名函数
  - 被覆盖的基类函数必须是虚函数
  - 函数名、参数列表（个数、类型和顺序）、返回值类型和父类完全相同，只有函数体有区别
  - 只能发生在类的成员函数中。
- 隐藏(hide)
  - 派生类中的函数屏蔽了基类中的同名函数
  - 这里仅要求基类和派生类函数同名即可。可以说隐藏比覆盖涵盖的范围更宽泛，毕竟参数不加限定。
  - 两个函数参数相同，但是基类函数不是虚函数。和重写的区别在于基类函数是否是虚函数
  - 两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中
- 重载与重写的区别：
  - 重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系
  - 重写要求参数列表相同，重载则要求参数列表不同，返回值不要求
  - 重写关系中，调用方法根据对象类型决定，重载根据调用时实参表与形参表的对应关系来选择函数体

## 虚函数和多态 
- 多态的实现主要分为静态多态和动态多态，
- 静态多态主要是重载，在编译的时候就已经确定
- 动态多态是用虚函数机制实现的，在运行期间动态绑定。
  - 在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据所指对象的实际类型来调用相应的函数，如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数。
  - 在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。
- 虚函数的实现
  - 在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。
  - 当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。
  - 当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；
  - 当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；
  - 当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面
  - 虚函数表只有一份，而有多少个对象，就对应多少个虚函数表指针

## 虚函数的实现机制

- 多态是由虚函数实现的，而虚函数主要是通过虚函数表（V-Table）来实现的。
- 如果一个类中包含虚函数（virtual修饰的函数），那么这个类就会包含一张虚函数表，虚函数表存储的每一项是一个虚函数的地址。
- 这个类的每一个对象都会包含一个虚指针（虚指针存在于对象实例地址的最前面，保证虚函数表有最高的性能），这个虚指针指向虚函数表。
- 对象不包含虚函数表，只有虚指针，类才包含虚函数表，派生类会生成一个兼容基类的虚函数表。
- 虚函数表存放的内容：类的虚函数的地址。
- 虚函数表建立的时间：编译阶段，即程序的编译过程中会将虚函数的地址放在虚函数表中。
- 虚表指针保存的位置：虚表指针存放在对象的内存空间中最前面的位置，这是为了保证正确取到虚函数的偏移量


## 不同类继承情况下的虚函数表结构
  - 原始基类的虚函数表  
      - 虚指针在地址的最前面，指向基类的虚函数表
  - 单继承时的虚函数（无重写基类虚函数）
      - 派生类会自己产生一个兼容基类虚函数表的属于自己的虚函数表。
      - 该函数实体的地址被拷贝到 Derive类的虚函数表，派生类新增的虚函数置于虚函数表的后面，并按声明顺序存放。
  - 单继承时的虚函数（重写基类虚函数）
      - 构建自己的虚函数表的时候，修改了基类虚函数的地址，指向自己的虚函数。
  - 多重继承时的虚函数
      - 有多个虚函数表，它的对象会有多个虚指针，指向不同的父类虚函数表,按照声明顺序排列。
      - 子类的成员函数被放到了第一个父类的表中。
  - 虚继承时的虚函数表
      - 虚继承时如果子类父类都有虚函数，那么它会重新建立一张虚表，不包含父类虚表的内容；而在普通的继承中却是在父类虚表的基础上建立一张虚表。这就意味着如果虚继承中子类父类都有各自的虚函数，在子类里面就会有两个虚函数表指针，一个指向父类的虚表，一个指向子类的虚表，而普通的继承只有一个指向子类虚表的指针
      * 一个子类虚继承自另一个基类，它不再像普通继承那样直接拥有一份基类的内存结构，而是加了一个虚表指针vbptr指向虚基类，这个虚基类在msvc中被放在的类的内存空间的最后
      * 父类A有俩个子类B和C，在菱形虚拟地址空间中，类B和C包含的东西除了子类自己创造的成员之外还有一个指针，这个指针是一个指向虚基表的指针，虚基表是一个表也可以认为是一个数组，通过虚基表指针指向的地址可以在虚基表中找出一个数，这个数其实是一个偏移量，是存放虚基表指针的地址相对于父类A成员所在地址的相对偏移量，通过这个偏移量就可以找到父类A的成员。很好的解决了数据冗余和二义性


## override和final

- override指定了子类的这个虚函数是重写的父类的
- 在类名和虚函数后添加final关键字,表明不希望某个类被继承，或不希望某个虚函数被重写

## 构造函数和析构函数能否为虚函数
- 析构函数：
  - 析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。
  - 只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。
  - 如果未将基类的析构函数定义成虚函数，会调用基类的析构函数，那么只能将基类的成员所占的空间释放掉，派生类中特有的就会无法释放内存空间导致内存泄漏。
  - 析构函数可以是纯虚函数，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。
  - C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。
- 构造函数：
  - 构造函数不能定义为虚函数
  - 在构造函数中可以调用虚函数，不过此时调用的是正在构造的类中的虚函数，而不是子类的虚函数，因为此时子类尚未构造好。
  - 构造一个对象的时候，必须知道对象的实际类型
  - 虚函数的执行依赖于虚函数表，而在构造对象期间，虚函数表还没有被初始化，将无法进行

## 哪些函数不能是虚函数

- 构造函数
  - 构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造；
  - 当有虚函数时，每一个类有一个虚表，每一个对象有一个虚表指针，虚表指针在构造函数中初始化；
- 内联函数
  - 内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定，所以内联函数不能是虚函数；
- 静态函数
  - 静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚函数没有任何意义。
- 友元函数
  - 友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。
- 普通函数
  - 普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数。


## 构造函数或者析构函数中调用虚函数
https://blog.csdn.net/henrytien/article/details/80064863
- 可以调用，程序可以运行，但是无法达到虚函数调用的效果


## 动态绑定和静态绑定
- 静态类型和动态类型：
  - 静态类型：变量在声明时的类型，是在编译期确定的。静态类型不能更改
  - 动态类型：一个指针或引用目前所指对象的类型，是在运行期确定的。动态类型可以更改
- 静态绑定和动态绑定：
  - 静态绑定是指程序在编译的过程中确定对象的类型（静态类型）
  - 动态绑定是指程序在运行期间确定对象的类型（动态类型）
- 静态绑定和动态绑定的区别：
  - 发生的时期不同：如上
  - 对象的静态类型不能更改，动态类型可以更改
  - 要想实现多态，必须进行动态绑定
  - 在继承体系中，只有虚函数是动态绑定，其他都是静态绑定


## 纯虚函数和抽象类

- 纯虚函数是在基类中声明的虚函数，它在基类中没有定义(可以定义)，但要求任何派生类都要定义自己的实现方法
- 在基类中实现纯虚函数的方法是在函数原型后加“=0”
- 使用原因
  - 在很多情况下，基类本身生成对象是不合情理的。
  - 将函数定义为纯虚函数，则编译器要求在派生类中必须予以重写以实现多态性。
- 抽象类
  - 含有纯虚函数的类，它不能生成对象
  - 继承纯虚函数的派生类，如果没有完全实现基类纯虚函数，依然是抽象类，不能实例化对象
  - 抽象类对象不能作为函数的参数，不能创建对象，不能作为函数返回类型；
  - 可以声明抽象类指针，可以声明抽象类的引用；
- 纯虚函数在基类中可以定义
  - 只能定义在类的外部
  - 但是在派生类中必须覆盖这个纯虚函数，而不能直接继承基类（抽象类）的纯虚函数，却不定义自己的
  - 可以用 基类::虚函数 的形式来访问它，提示可能需要它的内容作为前置调用

## 纯虚析构函数

- 纯虚析构函数一定得定义，因为每一个派生类析构函数会被编译器加以扩张，以静态调用的方式调用其每一个虚基类以及上一层基类的析构函数。
- 因此，缺乏任何一个基类析构函数的定义，就会导致链接失败，最好不要把虚析构函数定义为纯虚析构函数。


## 多重继承

- 指从多个直接基类中产生派生类
- 优点很明显，就是对象可以调用多个基类中的接口
- 菱形继承时会出现命名冲突和数据冗余问题
  - 解决方法1： 声明出现冲突的成员变量来源于哪个类
  - 解决方法2： 虚继承

## 虚继承

- 为了解决多重继承中命名冲突和数据冗余问题
- 保证存在命名冲突的成员变量在派生类中只保留一份
  - 使间接基类中的成员在派生类中只保留一份
  - 在菱形继承关系中，间接基类称为虚基类，直接基类和间接基类之间的继承关系称为虚继承
- 实现方式
  - 在继承方式前面加上virtual 关键字,在public前后都行
  - 直接基类继承间接基类时加
```cpp
// 间接基类，即虚基类
class Base1
{
public:
    int var1;
};

// 直接基类
class Base2 : virtual public Base1 // 虚继承
{
public:
    int var2;
};

// 直接基类
class Base3 : virtual public Base1 // 虚继承
{
public:
    int var3;
};

// 派生类
class Derive : public Base2, public Base3
{
public:
    void set_var1(int tmp) { var1 = tmp; }
    void set_var2(int tmp) { var2 = tmp; }
    void set_var3(int tmp) { var3 = tmp; }
    void set_var4(int tmp) { var4 = tmp; }

private:
    int var4;
};
```



## 类成员指针

- 指向类的非静态成员
- 成员指针的类型包括了类的类型和成员的类型，`classname::*`
- 初始化时，令其指向类的某个成员，但是不指定该成员所属的对象，使用成员指针时，才提供成员所属的对象
  - 初始化或者赋值时，指针没有指向任何数据
  - 只有解引用成员指针时才提供对象的信息,`.*,->*`，左侧是对象或对象指针，右侧是成员指针
- 成员函数
  - 在成员函数和指向该成员的指针之间不存在自动转换的规则
  - 调用运算符优先级高于指针指向成员运算符，所以解引用时需要括号
```cpp
class A
{
  public:
    int data();
    string s;
    int i;
}
// 初始化或者赋值
string A::* pstring;
ptring=&A::s;
auto pint=&A::i;
int (A::*pdata)()=&A::data;
auto pdata2=&A::data;
// 解引用
A a,*pa=&a;
string ts=a.*pstring;
string ts2=pa->*pstring;
int i=(a.*pdata)();
int ii=(pa->*pdata)();

// 破坏封装性，能通过成员指针访问私有成员
class A
{
public:
    int get()
    {
        return i;
    }
    int A::*data()
    {
        return &A::i;
    }

private:
    int i;
};

int main()
{
    A a;
    int A::*p = a.data();
    a.*p = 3;
    cout << a.get();
}

```

## 把成员函数转换成可调用对象

- 成员指针不是一个可调用对象，因为想通过它进行函数调用，必须提供一个特定的对象
- 使用function生成一个可调用对象
  - function会自动翻译
  - 必须指明传入的是指针或者引用
- 使用mem_fn
  - 可以根据成员指针的类型推断除可调用对象的类型，不需要显示指定
  - 可以通过对象调用，也能通过指针调用
- 使用bind
  - 同样既可以对象，也可以指针
```cpp
vector<string> svec;
auto fp&=string::empty;
find_if(svec.begin(),svec.end(),fp);//这是错误的，fp(*it)是不争取的
function<bool (const string&)> fcn=&string::empty;
find_if(svec.begin(),svec.end(),fcn);//会自动转换成((*it).*fcn)()
find_if(svec.begin(),svec.end(),mem_fn(&string::empty));
find_if(svec.begin(),svec.end(),bind(&string::empty,_1));
```

-------------------------------

# 7. STL

## STL六大组件
1. 容器（Containers）
    各种数据结构，如Vector,List,Deque,Set,Map,用来存放数据，STL容器是一种Class Template,就体积而言，这一部分很像冰山载海面的比率。
2. 算法（Algorithms）
    各种常用算法如Sort,Search,Copy,Erase,从实现的角度来看，STL算法是一种Function Templates。
3. 迭代器（Iterators）
    扮演容器与算法之间的胶合剂，是所谓的“泛型指针”，共有五种类型，以及其它衍生变化，从实现的角度来看，迭代器是一种将：Operators*,Operator->,Operator++,Operator--等相关操作予以重载的Class Template。所有STL容器都附带有自己专属的迭代器——是的，只有容器设计者才知道如何遍历自己的元素，原生指针（Native pointer）也是一种迭代器。
4. 仿函数（Functors）
    行为类似函数，可作为算法的某种策略（Policy）,从实现的角度来看，仿函数是一种重载了Operator()的Class 或 Class Template。一般函数指针可视为狭义的仿函数。
5. 配接器（适配器）（Adapters）
    一种用来修饰容器（Containers）或仿函数（Functors）或迭代器（Iterators）接口的东西，例如：STL提供的Queue和Stack，虽然看似容器，其实只能算是一种容器配接器，因为 它们的底部完全借助Deque，所有操作有底层的Deque供应。改变Functor接口者，称为Function Adapter;改变Container接口者，称为Container Adapter;改变Iterator接口者，称为Iterator Adapter。配接器的实现技术很难一言蔽之，必须逐一分析。
6. 分配器（Allocators）
    负责空间配置与管理，从实现的角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的Class Template。


## allocator的分配原理
- 三个头文件
  - `<stl_alloc.h>`,负责内存空间的配置和释放
  - `<stl_construct.h>`, 负责对象内容的构造和析构
  - `<stl_uninitialized.h>`,用于填充和复制大块内存的特殊函数
- allocator是一个由两级分配器构成的内存管理器
- 当申请的内存大小大于128字节时，就启动第一级分配器通过malloc直接向系统的堆空间分配
  - 其实就是malloc来分配内存，成功则直接返回，失败就调用处理函数
  - oom_malloc()
- 如果申请的内存大小小于128字节时，就启动第二级分配器
  - 每次配置一大块内存，并维护free-list
  - 16条链表，分别是0-15号链表，最小8字节，以8字节逐渐递增，最大128字节，你传入一个字节参数，表示你需要多大的内存，会自动帮你校对到第几号链表（如需要13bytes空间，我们会给它分配16bytes大小），在找到第你个链表后查看链表是否为空，如果不为空直接从对应的free_list中拔出，将已经拨出的指针向后移动一位。
  - 对应的free_list为空，先看其内存池是不是空时，如果内存池不为空：
    - 先检验它剩余空间是否够20个节点大小（即所需内存大小(提升后) * 20），若足够则直接从内存池中拿出20个节点大小空间，将其中一个分配给用户使用，另外19个当作自由链表中的区块挂在相应的free_list下，这样下次再有相同大小的内存需求时，可直接拨出。
    - 如果不够20个节点大小，则看它是否能满足1个节点大小，如果够的话则直接拿出一个分配给用户，然后从剩余的空间中分配尽可能多的节点挂在相应的free_list中。
    - 如果连一个节点内存都不能满足的话，则将内存池中剩余的空间挂在相应的free_list中（找到相应的free_list），然后再给内存池申请内存，转到3。
  - 内存池为空，申请内存
    - 此时二级空间配置器会使用malloc()从heap上申请内存，（一次所申请的内存大小为2 * 所需节点内存大小（提升后）* 20 + 一段额外空间），申请40块，一半拿来用，一半放内存池中。
    - malloc没有成功
      - 在第三种情况下，如果malloc()失败了，说明heap上没有足够空间分配给我们了，这时，二级空间配置器会从比所需节点空间大的free_list中一一搜索，从比它所需节点空间大的free_list中拔除一个节点来使用。如果这也没找到，说明比其大的free_list中都没有自由区块了，那就要调用一级适配器了。
      - 以及适配器有调用malloc失败的处理函数
- 优点：
  - 小对象的快速分配。解决了外部碎片与提高了效率，
  - 频繁的在堆开辟释放内存，则就会在堆上造成很多外部碎片，浪费了内存空间；
  - 每次都要进行调用malloc、free函数等操作，使空间就会增加一些附加信息，降低了空间利用率；
- 缺点
  - 因为自由链表的管理问题，它会把我们需求的内存块自动提升为8的倍数，这时若你需要1个字节，它会给你8个字节，即浪费了7个字节，所以它又引入了内部碎片的问题，若相似情况出现很多次，就会造成很多内部碎片；
  - 二级空间配置器是在堆上申请大块的狭义内存池，然后用自由链表管理，供现在使用，在程序执行过程中，它将申请的内存一块一块都挂在自由链表上，即不会还给操作系统，并且它的实现中所有成员全是静态的，所以它申请的所有内存只有在进程结束才会释放内存，还给操作系统，由此带来的问题有：1.即我不断的开辟小块内存，最后整个堆上的空间都被挂在自由链表上，若我想开辟大块内存就会失败；2.若自由链表上挂很多内存块没有被使用，当前进程又占着内存不释放，这时别的进程在堆上申请不到空间，也不可以使用当前进程的空闲内存，由此就会引发多种问题

## 特性萃取

- iterator_traits
  - value_type：迭代器所指对象的型别
  - difference_type：两个迭代器之间的距离
  - pointer：迭代器所指向的型别
  - reference：迭代器所引用的型别
  - iterator_category：迭代器的5种类型
- type_traits
  - __type_traits<T>::has_trivial_default_constructor
  - __type_traits<T>::has_trivial_copy_constructor
  - __type_traits<T>::has_trivial_assignment_operator
  - __type_traits<T>::has_trivial_destructor
  - __type_traits<T>::is_POD_type


## 常见容器

- string：与vector相似的容器，专门用于存储字符。随机访问快，在尾位置插入/删除速度快
- array：固定大小数组。支持快速随机访问，不能添加或者删除元素
- vector：可变大小的数组。底层数据结构为数组，支持快速随机访问，在尾部之外的位置插入或者删除元素可能很慢
- list：双向链表。底层数据结构为双向链表，支持双向顺序访问。在list任何位置插入/删除速度很快
- forward_list：单向链表。支持单项顺序访问。在forward_list任何位置插入/删除速度很快
- deque：双端队列。底层数据结构为一个中央控制器和多个缓冲区，支持快速随机访问，在头尾位置插入/删除速度很快
- stack：栈。底层用deque实现，封闭头部，在尾部进行插入和删除元素
- queue：队列。底层用deque实现
- priority_queue：优先队列。底层用vector实现，堆heap为处理规则来管理底层容器的实现
- set：集合。底层为红黑树，元素有序，不重复
- multiset：底层为红黑树，元素有序，可重复
- map：底层为红黑树，键有序，不重复
- multimap：底层为红黑树，键有序，可重复
- hash_set：底层为哈希表，无序，不重复
- hash_multiset：底层为哈希表，无序，可重复
- hash_map：底层为哈希表，无序，不重复
- hash_multiap：底层为哈希表，无序，可重复

## 容器内部删除一个元素
- 顺序容器
  - erase迭代器不仅使所指向被删除的迭代器失效，而且使被删元素之后的所有迭代器失效(list除外)，所以不能使用erase(it++)的方式，但是erase的返回值是下一个有效迭代器；
  - `it = c.erase(it)`
- 关联容器
  - erase迭代器只是被删除元素的迭代器失效，但是返回值是void，所以要采用erase(it++)的方式删除迭代器；
  - `c.erase(it++)` 
## vector和list的区别
- vector
  - 拥有一段连续的内存空间
  - 可以实现动态增长的对象数组
  - 支持对数组高效率的访问和在数组尾端的删除和插入操作，时间复杂度为o(1)
  - 在中间和头部删除和插入相对不易，需要挪动大量的数据，时间复杂度为o(n)
- list
  - 双向链表实现的，因此内存空间是不连续的
  - 只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n)
  - 能高效地进行插入和删除

## vector 的实现

- vector 是一个动态数组，底层实现是一段连续的线性内存空间。
- 扩容的本质：
  - 当 vector 实际所占用的内存空间和容量相等时，如果再往其中添加元素需要进行扩容。其步骤如下：
    - 首先，申请一块更大的存储空间，一般是增加当前容量的 50% 或者 100%，和编译器有关；
    - 然后，将旧内存空间的内容，按照原来的顺序放到新的空间中
    - 最后，将旧内存空间的内容释放掉，本质上其存储空间不会释放，只是删除了里面的内容。
- 从 vector 扩容的原理也可以看出：vector 容器释放后，与其相关的指针、引用以及迭代器会失效的原因。

## vectoc的size和capacity

- size()函数返回的是已用空间大小
- capacity()返回的是总空间大小
- capacity()-size()则是剩余的可用空间大小。
- 当size()和capacity()相等，说明vector目前的空间已被用完，如果再添加新元素，则会引起vector空间的动态增长

## vector的resize和reserve
- reserve(n)预先分配一块较大的指定大小的内存空间，
  - 只有当n>capacity()时，调用reserve(n)才会改变vector容量
- resize()成员函数只改变元素的数目，不改变vector的容量


## push_back()和emplace_back()
- 使用push_back()函数需要调用拷贝构造函数或转移构造函数，先构造出一个临时对象，然后加入到vector结尾
- eplace_back()插入的元素原地构造，不需要触发拷贝构造或转移构造，没有临时对象


## list的实现

- 以节点为单位存放数据，节点的地址在内存中不一定连续，每次插入或者删除数据时，就配置或者释放一个元素的空间
  
## deque的实现

- 动态的以分段连续的空间组成，随时可以增加一段新的连续的空间并链接起来，不提供空间保留（reserve）功能。
- 采用一块map(不是STL的map容器)作为主控，其为一小块连续的空间，其中的每个元素都是指针，指向另一段较大的连续空间（缓冲区）


## 迭代器和指针的区别

- 迭代器不是指针，是类模板，表现的像指针，模拟了指针的功能，重载了指针的一些操作符，->, * , ++, --等；
- 迭代器封装了指针，是一个可遍历STL容器内全部或者部分元素的对象，本质上封装了原声指针，比指针更高级，相当于只能指针
- 迭代器返回的是引用，而不是对象的值
- 可用不用暴露集合内部的结构

## 迭代器分类

- 输入迭代器（用于读数据）：只读不写，单遍扫描，只能递增
  - 支持`==,!=,++,*,->`,
- 输出迭代器（用于写数据）：只写不读，单遍扫描，只能递增
- 前向迭代器：可读写，多变扫描，只能递增
- 双向迭代器：可读写，多变扫描，可递增递减
- 随机访问迭代器：可读写，多变扫描，可随机访问


## vector迭代器失效

- vector动态增加空间时，并不是在原空间之后增加新的空间,而是另外配置一片较大的空间，释放原来的空间
- 插入操作
    - 尾后插入
      - size < capacity时，首迭代器不失效尾迭代失效（未重新分配空间）
      - size == capacity时，所有迭代器均失效（需要重新分配空间）。
    - 中间插入
      - size < capacity时，首迭代器不失效但插入元素之后所有迭代器失效
      - size == capacity时，所有迭代器均失效。
- 删除操作
  - 尾后删除：只有尾迭代失效。
  - 中间删除：删除位置之后所有迭代失效。

## deque迭代器失效

- 在中间插入或者删除元素，将使deque所有的迭代器、引用、指针失效
- 在首部或者尾部插入元素可能会使迭代器失效（缓冲区空间已满，需重新分配内存），但不会引起指针或者引用失效
- 在首部或者尾部删除元素，只会使指向被删除的元素迭代器失效


## hash 表的实现

- hashtable 是采用开链法来完成的，（vector + list）
- 底层键值序列采用 vector 实现，vector 的大小取的是质数，且相邻质数的大小约为 2 倍关系，当创建 hashtable 时，会自动选取一个接近所创建大小的质数作为当前 hashtable 的大小；
- 对应键的值序列采用单向 list 实现；
- 当 hashtable 的键 vector 的大小重新分配的时候，原键的值 list 也会重新分配，因为 vector 重建了相当于键增加了，那么原来的值对应的键可能就不同于原来分配的键，这样就需要重新确定值的键。


## unordered_map 和 map 的区别
- 底层实现不同：
  - unordered_map 底层实现是一个哈希表，元素无序
  - map 底层实现是红黑树，其内部所有的元素都是有序的，因此对 map 的所有操作，其实都是对红黑树的操作
- 优缺点：
  - unordered_map：查找效率高，O(n)；但是建立哈希表比较耗费时间
  - map：内部元素有序，查找和删除操作都是 logn 的时间复杂度；但是维护红黑树的存储结构需要占用一定的内存空间
- 适用情况：
  - 对于要求内部元素有序的使用 map
  - 对于要求查找效率的用 unordered_map

## hash表的扩容
- 什么时候扩容
  - 当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值---即当前数组的长度乘以加载因子的值的时候，就要自动扩容啦。
- 扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。


## 红黑树

- 它是二叉排序树（继承二叉排序树特显）：
  - 若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值。
  - 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值。
  - 左、右子树也分别为二叉排序树。
- 它满足如下几点要求：
  - 树中所有节点非红即黑。
  - 根节点必为黑节点。
  - 红节点的子节点必为黑（黑节点子节点可为黑）。
  - 从根到NULL的任何路径上黑结点数相同。
- 查找时间一定可以控制在O(logn)。


## map的实现 
- map的特性是所有元素会根据键值进行自动排序。
- map中所有的元素都是pair，拥有键值(key)和实值(value)两个部分，并且不允许元素有相同的key
- 一旦map的key确定了，那么是无法修改的，但是可以修改这个key对应的value

## set的实现
- set的key和value其实是一样的了。其实他保存的是两份元素，而不是只保存一份元素

## unordered_map和map的区别和应用场景
- map支持键值的自动排序，底层机制是红黑树，红黑树的查询和维护时间复杂度均为图片，但是空间占用比较大，因为每个节点要保持父节点、孩子节点及颜色的信息
- unordered_map是C++ 11新添加的容器，底层机制是哈希表，通过hash函数计算元素位置，其查询时间复杂度为O(1)，维护时间与bucket桶所维护的list长度有关，但是建立hash表耗时较大
- 从两者的底层机制和特点可以看出：map适用于有序数据的应用场景，unordered_map适用于高效查询的应用场景


# 模板
 
## 模板的特例化
- 使用原因
  - 编写模板是为了它能适应多种类型的需求，使每种类型都具有相同的功能
  - 但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化
- 模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本。
- 模板函数特例化
  - 必须为原函数模板的每个模板参数都提供实参，且使用关键字template后跟一个空尖括号对<>，表明将原模板的所有模板参数提供实参
  - 不能部分特例化
```cpp
template<typename T> //模板函数
int compare(const T &v1,const T &v2)
{
    if(v1 > v2) return -1;
    if(v2 > v1) return 1;
    return 0;
}
//模板特例化,满足针对字符串特定的比较，要提供所有实参，这里只有一个T
template<> 
int compare(const char* const &v1,const char* const &v2)
{
    return strcmp(p1,p2);
}
```
- 类模板特例化
  - 可以对模板进行特例化，也可以对类进行部分特例化
  - 部分特例化
    - 不必为所有模板参数提供实参，可以指定一部分而非所有模板参数
    - 一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其特例化版本中未指定的模板参数提供实参
  - 可以特例化类中的部分成员函数而不是整个类
```cpp
// 类的特例化
template<>
class hash<sales_data>
{
    size_t operator()(sales_data& s);
    //里面所有T都换成特例化类型版本sales_data
    //按照最佳匹配原则，若T != sales_data，就用普通类模板，否则，就使用含有特定功能的特例化版本。
}
// 类的部分特例化
template<class T,bool b>  //原模板
class My 
{
public:
	void fun()
	{
		cout << "original" << endl;
	}
};
 
template<class T>     //特例化第二个参数为true时相应的模板
class My < T, true >
{
public:
	void fun()
	{
		cout << "special" << endl;
	}
};
 
My<double,false> m;
m.fun();     //使用原模板  打印“original”
 
My<int,true>n;
n.fun();     //使用特例化模板  打印“speacial”
// 特例化成员函数
template<typename T>
class Foo
{
    void Bar();
    void Barst(T a)();
};
template<>
void Foo<int>::Bar()
{
    //进行int类型的特例化处理
}
```


## 模板的编译

- 当编译器遇到一个模板定义时，它并不生成代码
- 只有当我们实例化出模板的一个特定版本时，编译器才会生成代码，当我们使用模板时（而不是定义），编译器才生成代码
- 类和函数
  - 调用一个函数时，编译器只需要掌握函数的声明
  - 使用一个类类型的对象时，类定义必须可用，但成员函数的定义不必出现
  - 类定义和函数声明放在头文件中，普通函数和类的成员函数的定义放在源文件中
- 模板
  - 为了实例化一个模板，需要掌握函数模板或类模板成员函数的定义
  - 函数模板和类模板成员函数的定义通常放在头文件中
- 模板出现错误的三个阶段
  - 编译模板本身时，出现语法错误
  - 编译器遇到模板使用时，检查提供的模板实参是否正确
  - 模板实例化时


## std::enable_if 

- 满足条件时类型有效。作为选择类型的小工具，其广泛的应用在 C++ 的模板元编程（meta programming）中
- 只有当第一个模板参数为 true 时，type 才有定义，否则使用 type 会产生编译错误SFINAE，并且默认模板参数可以让你不必指定类型
- SFINAE:从一组重载函数中删除模板实例化无效的函数
```cpp
template <bool, typename T=void>
struct enable_if {
};
 
template <typename T>
struct enable_if<true, T> {
  using type = T;

```

## std::is_same

- `std::is_same<T1,T2>::value`
  - T1,T2类型相同返回true，否则返回false

## std::is_convertible

- `template <typename From, typename To> is_convertible;`
- 如果满足下列条件，则 `std::is_convertible<From, To>::value` 为 true，否则为 false
  - From 和 To 均为 void 类型（可含有 cv 限定）
  - From>可隐式转换为 To 类型

## 类模板和友元
  - 如果一个类模板包含一个非模板友元，则友元被授予可以访问所有模板示例
  - 如果都是模板
    - 一对一友好关系,限定在相同类型实例化的类和函数之间（需要友元的前置声明）
    - 也可以将另一个模板的每个实例声明为自己的友元(不需要友元的前置声明)
```cpp
template <typename T> class A; // 需要前置声明
template <typename T> class B;
template <typename T>
bool com(const B<T> &, const B<T> &);

template <typename T>
class B
{
    // 一对一
    friend class A<T>;
    friend class bool com<T>(const B<T> &, const B<T> &);
    // 每个实例都是友元，不需要前置声明
    template <typename X>
    friend class C;
}
```