# 多线程

## 线程和进程

- 当一个进程需要另一个实体来完成某事时，Unix上大多数网络服务器通过fork一个子进程来处理。但是**fork调用存在一些问题**：
  - **fork是昂贵的**。fork要把父进程的内存映像复制到子进程，并在子进程中复制所有描述符。尽管现在使用**写时拷贝**技术，避免在子进程切实需要自己的副本之前把父进程的数据空间拷贝到子进程。但是fork仍然是昂贵哦的
  - **fork返回之后父子进程之间信息的传递需要进程间通信(IPC)机制**。调用fork之前，父进程向尚未存在的子进程传递信息相当容易，因为子进程将从父进程数据空间及所有描述符的一个副本开始运行。然而从子进程往父进程返回信息却比较费力
- **线程有助于解决上述问题，它被称为“轻量级进程”，创建可能比进程的创建快10~100倍。但是，伴随这种简易性而来的是同步问题**
- **线程之间的资源共享**：
  - **同一进程内的线程共享**
    - 相同的全局内存
    - 进程指令
    - 大多数数据
    - 打开的文件（即描述符）
    - 信号处理函数和信号设置
    - 当前工作目录
    - 用户ID和组ID
  - **线程之间不共享**
    - 线程ID
    - 寄存器集合（包括程序计数器和栈指针）
    - 栈（用于存放局部变量和返回地址）
    - errno
    - 信号掩码
    - 优先级


## pthread
pthread的库不是linux系统的库，所以在进行编译的时候要加上-lpthread  

**pthread函数不设置errno,成功为0,出错则返回正值错误指示**

1. 线程标识符

```cpp
#include <pthread.h>
pthread_t pthread_self();//返回调用线程的线程ID.
int pthread_equal(pthread_t tid1, pthread_t tid2);//比较两个线程ID是否相等.相等返回非0, 不相等返回0.
```
- pthread_t不一定是一个数值类型(整数或指针)，也有可能是一个结构体
- 无法打印pthread_t的值，无法比较大小，只能比较想等，无法定义一个非法的pthread_t值
- 只保证在同一进程之内，同一时刻的各个线程的id不同，不能保证同一进程先后多个线程具有不同的id，也无法保证多个进程之间线程id的唯一性

```cpp
#include <sys/syscall.h> 
static_cast<pid_t>(::syscall(SYS_gettid))
```
- 进程id，类型pid_t，可以由getpid（）获取
- 线程id，类型pthread_t，可以由pthread_self（）获取
- 但是各个进程独立，所以会有不同进程中线程号相同的情况
- 真实的线程id唯一标识，tid,类型也是pid_t
  - 可以通过linux下的系统调用syscall(SYS_gettid)来获得

2. 线程的创建
```cpp
int pthread_create(pthread_t *restrict tidp, const pthread_attr_t *restrict attr, void *(start_rtn)(void*), void *restrict arg);
```
- 当一个程序由exec启动执行时，称为“初始线程”或“主线程”的单个线程就创建了。其余线程则由pthread_create函数创建
- restrict关键字用于告诉编译器，对象已经被指针所引用，不能通过除该指针外所有其他直接或间接的方式修改该对象的内容。
- 返回值: 成功则返回0, 否则返回错误编号.
- 参数: 
    - tidp: 指向新创建线程ID的变量, 作为函数的输出.
    - attr: 用于定制各种不同的线程属性, 通常情况下配置为NULL，使用缺省设置就可以了
    - start_rtn: 函数指针, 为线程开始执行的函数名.该函数可以返回一个void *类型的返回值，而这个返回值也可以是其他类型，并由 pthread_join()获取
    - arg: 该线程执行函数的参数，参数为一个无类型指针，如果需要向函数传递的参数有一个以上，那么需要把这些参数放到一个结构中，然后把这个结构的地址作为参数传入
- 创建的线程通过调用指定的函数开始执行，然后显示地（通过调用pthread_exit）或隐式地（通过让该函数返回）终止
- 线程创建时，并不能保证哪个线程会先运行
  
3. 线程属性
```cpp
typedef struct
{
    int   detachstate;   //线程的分离状态
    int   schedpolicy;   //线程调度策略
    struct sched_param   schedparam;   //线程的调度参数
    int inheritsched; //线程的继承性 
    int scope; //线程的作用域 
    size_t guardsize; //线程栈末尾的警戒缓冲区大小 
    int stackaddr_set; void * stackaddr; //线程栈的位置 
    size_t stacksize; //线程栈的大小
}pthread_attr_t;
```
*  __detachstate，表示新线程是否与进程中其他线程脱离同步，如果置位则新线程不能用pthread_join()来同步，且在退出时自行释放所占用的资源。缺省为PTHREAD_CREATE_JOINABLE状态。这个属性也可以在线程创建并运行以后用pthread_detach()来设置，而一旦设置为PTHREAD_CREATE_DETACH状态（不论是创建时设置还是运行时设置）则不能再恢复到  PTHREAD_CREATE_JOINABLE状态。
* __schedpolicy，表示新线程的调度策略，主要包括SCHED_OTHER（正常、非实时）、SCHED_RR（实时、轮转法）和  SCHED_FIFO（实时、先入先出）三种，缺省为SCHED_OTHER，后两种调度策略仅对超级用户有效。运行时可以用过  pthread_setschedparam()来改变。
* __schedparam，一个struct sched_param结构，目前仅有一个sched_priority整型变量表示线程的运行优先级。这个参数仅当调度策略为实时（即SCHED_RR或SCHED_FIFO）时才有效，并可以在运行时通过pthread_setschedparam()函数来改变，缺省为0。
* __inheritsched，有两种值可供选择：PTHREAD_EXPLICIT_SCHED和PTHREAD_INHERIT_SCHED，前者表示新线程使用显式指定调度策略和调度参数（即attr中的值），而后者表示继承调用者线程的值。缺省为PTHREAD_EXPLICIT_SCHED。
*  __scope，表示线程间竞争CPU的范围，也就是说线程优先级的有效范围。POSIX的标准中定义了两个值：  PTHREAD_SCOPE_SYSTEM和PTHREAD_SCOPE_PROCESS，前者表示与系统中所有线程一起竞争CPU时间，后者表示仅与同进程中的线程竞争CPU。目前LinuxThreads仅实现了PTHREAD_SCOPE_SYSTEM一值。


4. 线程退出
```cpp
void pthread_exit(void*value_ptr);

```
5. 线程取消
```cpp
int pthread_cancel(pthread_t thread);
```
- 该函数可以被某一线程调用，用来请求取消同一进程中的其它线程
- 函数只是发起取消请求，目标线程可以忽略取消请求或控制如何被取消（即执行一些清理函数）


6. 等待结束
```cpp
//如果value_ptr不为空，则来自所等待线程的返回值(一个指向某个对象的指针)将存入它所指向的位置
int pthread_join(pthread_t thread, void **value_ptr);
```
- 用于等待一个给定线程的终止,并且回收该线程中使用的资源
- 调用该函数的线程将挂起等待，直到id为thread的线程终止  
- 参数
  - tid：等待终止的线程ID。和进程不同的是，无法等待任意线程，所以不能通过指定ID参数为-1来企图等待任意线程终止
  - status：如果该指针非空，来自所等待线程的返回值（一个指向某个对象的指针）将存入由status指向的位置
- 对于一个非脱离状态的线程，如果没有其它线程调用pthread_join等待线程终止，那么线性终止后的资源无法回收，会造成资源浪费，进而影响同一进程创建的线程数量


7. 分离线程
```cpp
int pthread_detach(pthread_t thread);
 ```
- 把指定的线程转变为**脱离状态**
- 通常由想让自己脱离的线程调用：```pthread_detach(pthread_self());```
- 一个线程或者是**可汇合**的，或者是**脱离**的：
  - **可汇合**：一个可汇合线程终止时，它的线程ID和退出状态将保存到另一个线程对它调用pthread_join。如果一个线程需要知道另一个线程什么时候终止，那就最好保持第二个线程的可汇合状态
  - **脱离**：脱离的线程像守护进程，当它们终止时，所有相关资源都被释放，不能等待它们终止


8.和fork有关
```cpp
int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void));
```
- 三种函数
  - prepare 在父进程fork创建子进程之前调用
  - parent fork之后在父进程的进程环境中调用
  - child  fork之后在子进程环境中调用
  

## pthread的互斥锁和条件变量

- 互斥锁可以用于保护共享变量：访问共享变量的前提条件是持有该互斥锁，
- 创建互斥锁
  - 按照Pthread，互斥锁的类型为pthread_mutex_t的变量
  - 如果某个互斥锁变量是静态分配的，必须把它初始化为常值PTHREAD_MUTEX_INITIALIZER
  - 如果在共享内存区中分配一个互斥锁，必须通过调用pthread_mutex_init函数在运行时初始化
    - mutexattr用于指定互斥锁属性，如果为NULL则使用缺省属性
    - PTHREAD_MUTEX_TIMED_NP: 这是缺省值，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性。
    - PTHREAD_MUTEX_RECURSIVE_NP: 嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。如果是不同线程请求，则在加锁线程解锁时重新竞争。
    - PTHREAD_MUTEX_ERRORCHECK_NP: 检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁。
    - PTHREAD_MUTEX_ADAPTIVE_NP，适应锁，动作最简单的锁类型，仅等待解锁后重新竞争。
```cpp
#include <pthread.h>
pthread_mutex_t mutex=PTHREAD_MUTEX_INITIALIZER;//静态分配
int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);// 动态分配
```
- 锁操作
```cpp
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);//在锁已经被占据时返回EBUSY而不是挂起等待。
```
- 释放锁
  - 销毁一个互斥锁即意味着释放它所占用的资源，且要求锁当前处于开放状态。
  - 由于在Linux中，互斥锁并不占用任何资源，因此除了检查锁状态以外（锁定状态则返回EBUSY）没有其他动作。
```cpp
int pthread_mutex_destroy(pthread_mutex_t *mutex);
```

- 条件变量可以在某个条件发生之前，将线程投入睡眠
- 初始化条件变量
  - 条件变量是类型为pthread_cond_t的变量
  - 当参数cattr为空指针时，函数创建的是一个缺省的条件变量
  - 不能由多个线程同时初始化一个条件变量。当需要重新初始化或释放一个条件变量时，应用程序必须保证这个条件变量未被使用。
```cpp
#include <pthread.h>
pthread_cond_t cv = PTHREAD_COND_INITIALIZER;//静态
int pthread_cond_init(pthread_cond_t *cv, const pthread_condattr_t *cattr);//动态
```
- 阻塞，和互斥量配合使用
  - 将解锁mutex参数指向的互斥锁，并使当前线程阻塞在cv参数指向的条件变量上。被阻塞的线程可以被pthread_cond_signal函数，pthread_cond_broadcast函数唤醒，也可能在被信号中断后被唤醒。
  - pthread_cond_wait函数的返回并不意味着条件的值一定发生了变化，必须重新检查条件的值。
  - pthread_cond_wait函数返回时，相应的互斥锁将被当前线程锁定，即使是函数出错返回 
  - 一般一个条件表达式都是在一个互斥锁的保护下被检查。当条件表达式未被满足时，线程将仍然阻塞在这个条件变量上。当另一个线程改变了条件的值并向条件变量发出信号时，等待在这个条件变量上的一个线程或所有线程被唤醒，接着都试图再次占有相应的互斥锁。
  - 阻塞在条件变量上的线程被唤醒以后，直到pthread_cond_wait()函数返回之前条件的值都有可能发生变化。所以函数返回以后，在锁定相应的互斥锁之前，必须重新测试条件值。最好的测试方法是循环调用pthread_cond_wait函数，并把满足条件的表达式置为循环的终止条件.
```cpp
int pthread_cond_wait(pthread_cond_t *cv,pthread_mutex_t *mutex);
// 函数到了一定的时间，即使条件未发生也会解除阻塞。这个时间由参数abstime指定。函数返回时，相应的互斥锁往往是锁定的
// 超时时间参数是指一天中的某个时刻,绝对时间
int pthread_cond_timedwait(pthread_cond_t *cv,pthread_mutex_t *mp, const struct timespec * abstime);
// 通常的使用模式，要用循环
pthread_mutex_lock();
while (condition_is_false)
  pthread_cond_wait();
pthread_mutex_unlock();
```
- 解除阻塞
  - 函数被用来释放被阻塞在指定条件变量上的一个线程。
  - pthread_cond_signal即可以放在pthread_mutex_lock和pthread_mutex_unlock之间，也可以放在pthread_mutex_lock和pthread_mutex_unlock之后，但是各有各缺点。
  - 之间
    - 会有潜在的性能损耗
    - pthread_cond_signa可能会唤醒等待的线程，但此时锁还没被释放，该线程只能被迫再次进入休眠直到释放了锁
    - 但在Linux中没有这个问题，所以推荐放中间
      - 因为在Linux 线程中，有两个队列，分别是cond_wait队列和mutex_lock队列， cond_signal只是让线程从cond_wait队列移到mutex_lock队列，而不用返回到用户空间，不会有性能的损耗
  - 之后
    - 如果unlock和signal之前，有个低优先级的线程正在mutex上等待的话，那么这个低优先级的线程就会抢占高优先级的线程（cond_wait的线程)
```cpp
int pthread_cond_signal(pthread_cond_t *cv);//释放被阻塞在指定条件变量上的一个线程。
int pthread_cond_broadcast(pthread_cond_t *cv);//释放阻塞的所有线程
// 通常的使用模式
pthread_mutex_lock(&mut);
if (condition_is_true) 
    pthread_cond_signal(&cond);
pthread_mutex_unlock(&mut); 

```
- 唤醒丢失问题
  - 在线程未获得相应的互斥锁时调用pthread_cond_signal或pthread_cond_broadcast函数可能会引起唤醒丢失问题。
  - 唤醒丢失往往会在下面的情况下发生：
    - 一个线程调用pthread_cond_signal或pthread_cond_broadcast函数；另一个线程正处在测试条件变量和调用pthread_cond_wait函数之间；
    - 没有线程正在处在阻塞等待的状态下。

## c++里的多线程
- lock_guard
  - 创建lock_guard对象时，它将尝试获取提供给它的互斥锁的所有权。当控制流离开lock_guard对象的作用域时，lock_guard析构并释放互斥量
  - 不能中途解锁，必须等作用域结束才解锁
- unique_guard
  - 可以随时加锁解锁
  - 和条件变量配合使用，条件变量需要该类型的锁作为参数
- 所有 lock_guard 能够做到的事情，都可以使用 unique_lock 做到，反之则不然。

```cpp
#include <mutex>
#include <condition_variable>

class CountDownLatch
{
public:
    explicit CountDownLatch(int count) : count_(count) {}
    void wait()
    {
        std::unique_lock<std::mutex> lock(mutex_);
        while (count_ > 0)
            cond_.wait(lock);
    }

    void countDown()
    {
        std::lock_guard<std::mutex> lock(mutex_);
        --count_;
        if (count_ == 0)
            cond_.notify_all();
    }
    int getCount()
    {
        std::lock_guard<std::mutex> lock(mutex_);
        return count_;
    }

private:
    mutable std::mutex mutex_;
    std::condition_variable cond_;
    int count_;
};
```


# atomic

- 多个线程访问对象所包含的值不会引起数据竞争。此外，原子对象能够通过指定不同的内存顺序来同步对线程中其他非原子对象的访问

## atomic<T>模板类

- 生成一个T类型的原子对象，并提供了系列原子操作函数
- T是trivially copyable type满足
  - 要么全部定义了拷贝/移动/赋值函数，要么全部没定义
  - 没有虚成员
  - 基类或其它任何非static成员都是trivally copyable
- T能够被memcpy、memcmp函数使用，从而支持compare/exchange系列函数
- compare_exchange_weak/strong函数
  - 保证在比较和交换执行下原子化
  - 函数直接比较原子对象所封装的值与参数expected的物理内容，所以某些情况下，对象的比较操作在使用 operator==() 判断时相等，但 compare_exchange_weak 判断时却可能失败，因为对象底层的物理内容中可能存在位对齐或其他逻辑表示相同但是物理表示不同的值(比如 true 和 2 或 3，它们在逻辑上都表示"真"，但在物理上两者的表示并不相同)
  - 

```cpp
template <class T>
struct atomic
{
    atomic() = default;                                  //默认构造函数，T未初始化，可能后面被atomic_init(atomic<T>* obj,T val )函数初始化
    constexpr atomic(T val);                             //T由val初始化
    atomic(const atomic &) = delete;                     //禁止拷贝

    atomic &operator=(const atomic &) = delete;          //atomic对象间的相互赋值被禁止，但是可以显示转换再赋值，如atomic<int> a=static_cast<int>(b)这里假设atomic<int> b
    atomic &operator=(const atomic &) volatile = delete; //atomic间不能赋值

    T operator=(T val) volatile;                         //可以通过T类型对atomic赋值，如：atomic<int> a;a=10;
    T operator=(T val);

    operator T() const volatile;        //读取被封装的T类型值，是个类型转换操作，默认内存序是memory_order_seq需要其它内存序则调用load
    operator T() const;                 //如：atomic<int> a,a==0或者cout<<a<<endl都使用了类型转换函数

    //以下函数可以指定内存序memory_order
    bool is_lock_free() const volatile; //判断atomic<T>中的T对象是否为lock free的，若是返回true。lock free(锁无关)指多个线程并发访问T不会出现data race，任何线程在任何时刻都可以不受限制的访问T
    bool is_lock_free() const;

    T exchange(T val, memory_order = memory_order_seq_cst) volatile; //将T的值置为val，并返回原来T的值
    T exchange(T val, memory_order = memory_order_seq_cst);

    void store(T val, memory_order = memory_order_seq_cst) volatile; //将T值设为val
    void store(T val, memory_order = memory_order_seq_cst);

    T load(memory_order = memory_order_seq_cst) const volatile; //访问T值
    T load(memory_order = memory_order_seq_cst) const;

    bool compare_exchange_weak(T &expected, T val, memory_order = memory_order_seq_cst) volatile; //可以虚假的返回false(和expected相同)。若本atomic的T值和expected相同则用val值替换本atomic的T值，返回true;若不同则用本atomic的T值替换expected，返回false。
    bool compare_exchange_weak(T &, T, memory_order = memory_order_seq_cst);

    bool compare_exchange_strong(T &, T, memory_order = memory_order_seq_cst) volatile; //与compare_exchange_weak 不同, strong版本的 compare-and-exchange 操作不允许虚假返回 false，即原子对象所封装的值与参数 expected 的物理内容相同，比较操作一定会为 true。不过在某些平台下，如果算法本身需要循环操作来做检查， compare_exchange_weak 的性能会更好。因此对于某些不需要采用循环操作的算法而言, 通常采用compare_exchange_strong 更好
    bool compare_exchange_strong(T &, T, memory_order = memory_order_seq_cst);
};
```

## 针对整数和指针的特化

- 可以使用类型别名，例如atomic_int，atomic_bool，atomic_size_t
- 增加了一些额外的成员函数

```cpp
    // 将原子对象的封装值加 val，并返回原子对象的旧值（适用于整形和指针类型的 std::atomic 特化版本），整个过程是原子的
    T fetch_add(T val, memory_order sync = memory_order_seq_cst) noexcept;         //整型
    T fetch_add(ptrdiff_t val, memory_order sync = memory_order_seq_cst) noexcept; //指针
    T fetch_sub(T val, memory_order sync = memory_order_seq_cst) noexcept; 
    T fetch_sub(ptrdiff_t val, memory_order sync = memory_order_seq_cst) noexcept; 

    T fetch_and(T val, memory_order sync = memory_order_seq_cst) noexcept; //将原子对象的封装值按位与 val，并返回原子对象的旧值（只适用于整型的 std::atomic 特化版本），整个过程是原子的。
    T fetch_or(T val, memory_order sync = memory_order_seq_cst) noexcept; //将原子对象的封装值按位或 val，并返回原子对象的旧值（只适用于整型的 std::atomic 特化版本），整个过程是原子的。
    T fetch_xor(T val, memory_order sync = memory_order_seq_cst) noexcept; //将原子对象的封装值按位异或 val，并返回原子对象的旧值（只适用于整型的 std::atomic 特化版本），整个过程是原子的。

    // 自增运算符重载， 第一种形式(1) 返回自增后的值（即前缀++ ），第二种形式(2) 返回自增前的值（即后缀++ ），适用于整形和指针类型的 std::atomic 特化版本。
    // operator-- 自减运算符重载， 第一种形式(1) 返回自减后的值（即前缀-- ），第二种形式(2) 返回自减前的值（即后缀-- ），适用于整形和指针类型的 std::atomic 特化版本。
    T operator++() volatile noexcept;
    T operator++() noexcept;
    T operator++(int) volatile noexcept;
    T operator++(int) noexcept;

    //复合赋值运算符重载，主要包含以下形式：
    T operator+=(T val) volatile noexcept;
    T operator+=(T val) noexcept;
    T operator-=(T val) volatile noexcept;
    T operator-=(T val) noexcept;
    T operator&=(T val) volatile noexcept;
    T operator&=(T val) noexcept;
    T operator|=(T val) volatile noexcept;
    T operator|=(T val) noexcept;
    T operator^=(T val) volatile noexcept;
    T operator^=(T val) noexcept;

    T operator+=(ptrdiff_t val) volatile noexcept;
    T operator+=(ptrdiff_t val) noexcept;
    T operator-=(ptrdiff_t val) volatile noexcept;
    T operator-=(ptrdiff_t val) noexcept;
```


## 针对bool的特化

- std::atomic_flag是一个bool原子类型有两个状态：set(flag=true) 和 clear(flag=false)
- 必须被ATOMIC_FLAG_INIT初始化，此时flag为clear状态，相当于静态初始化。
- 一旦atomic_flag初始化后只有三个操作：test_and_set,clear,析构，均是原子化操作。
  - atomic_flag::test_and_set检查flag是否被设置，若被设置直接返回true，若没有设置则设置flag为true后再返回false。
  - atomic_clear()清楚flag标志即flag=false。
  - 不支持拷贝、赋值等操作，

## 内存顺序
- 指令重排问题
  - 编译器与CPU的优化都可能打乱指令执行顺序
  - 这种重排有可能会导致一个线程内相互之间不存在依赖关系的指令交换执行顺序
  - 虽然可能提高效率，但有时我们并不想要这样子（代码不按照我们所想顺序而执行）。
```cpp
typedef enum memory_order {
    memory_order_relaxed,   // relaxed
    memory_order_consume,   // consume
    memory_order_acquire,   // acquire
    memory_order_release,   // release
    memory_order_acq_rel,   // acquire/release
    memory_order_seq_cst    // sequentially consistent
} memory_order;
```
- 6个内存顺序可以分为3类：
- 自由顺序(memory_order_relaxed)
- 获取-释放顺序(memory_order_consume, memory_order_acquire, memory_order_release和memory_order_acq_rel)
  - std::memory_order_release，当前线程的读写操作都不能重排到此操作之后
    - 某一线程先写入A，再写入B，再以memeory_order_release操作写入C，再写入D。在多核处理器中观测到的顺序AB只能在C之前，不能出现C写入之后，A或B再写入的情况。但是，可能出现D重排到C之前的情况
    - 用于发布数据，放在写操作的最后。表示数据写完了，可以释放
  - std::memory_order_acquire，当前线程的读写操作都不能重排到此操作之前
    - 某一线程先读取A，再读取B，再以memeory_order_acquire操作读取C，再读取D。在多核处理器中观测到的顺序D只能在C之后，不能出现先读取D，最后读取C的情况。但是，可能出现A或B重排到C之后的情况
    - 用于获取数据，放在读操作的最开始。表示要开始读数据了，需要获取
    - “获取”与“释放”一般会成对出现，用来同步线程
  - std::memory_order_acq_rel，没有操作能够从此操作之后被重排到此操作之前，也没有操作能够从此操作之前被重排到此操作之后
  - std::memory_order_consume，保证该对象存储先行于那些需要加载该对象的操作
    - 防止在其后对原子变量有依赖的操作被重排到前面去。
- 排序一致顺序(memory_order_seq_cst)
  - 对所有拥有此标签的内存操作建立一个单独全序
  - memory_order_seq_cst比std::memory_order_acq_rel更为严格。
    - memory_order_acq_rel的顺序保障，是要基于同一个原子变量的。memory_order_acq_rel使用了两个不同的原子变量x1, x2，那在x1之前的读写，重排到x2之后，是完全可能的，在x1之后的读写，重排到x2之前，也是被允许的
    - 如果两个原子变量x1,x2，是基于memory_order_seq_cst在操作，那么即使是x1之前的读写，也不能被重排到x2之后，x1之后的读写，也不能重排到x2之前，
    - 也就说，如果都用memory_order_seq_cst，那么程序代码顺序(Program Order)就将会是你在多个线程上都实际观察到的顺序(Observed Order)。
  - 顺序一致是最简单、直观的序列，但是它也是最昂贵的内存序列，它需要对所有线程进行全局同步，比其他的顺序造成更多的消耗。因为保证一致顺序，需要添加额外的指令
