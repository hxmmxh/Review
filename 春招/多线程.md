# 多线程

## 线程和进程

- 当一个进程需要另一个实体来完成某事时，Unix上大多数网络服务器通过fork一个子进程来处理。但是**fork调用存在一些问题**：
  - **fork是昂贵的**。fork要把父进程的内存映像复制到子进程，并在子进程中复制所有描述符。尽管现在使用**写时拷贝**技术，避免在子进程切实需要自己的副本之前把父进程的数据空间拷贝到子进程。但是fork仍然是昂贵哦的
  - **fork返回之后父子进程之间信息的传递需要进程间通信(IPC)机制**。调用fork之前，父进程向尚未存在的子进程传递信息相当容易，因为子进程将从父进程数据空间及所有描述符的一个副本开始运行。然而从子进程往父进程返回信息却比较费力
- **线程有助于解决上述问题，它被称为“轻量级进程”，创建可能比进程的创建快10~100倍。但是，伴随这种简易性而来的是同步问题**
- **线程之间的资源共享**：
  - **同一进程内的线程共享**
    - 相同的全局内存
    - 进程指令
    - 大多数数据
    - 打开的文件（即描述符）
    - 信号处理函数和信号设置
    - 当前工作目录
    - 用户ID和组ID
  - **线程之间不共享**
    - 线程ID
    - 寄存器集合（包括程序计数器和栈指针）
    - 栈（用于存放局部变量和返回地址）
    - errno
    - 信号掩码
    - 优先级


## pthread
pthread的库不是linux系统的库，所以在进行编译的时候要加上-lpthread  

**pthread函数不设置errno,成功为0,出错则返回正值错误指示**

1. 线程标识符

```cpp
#include <pthread.h>
pthread_t pthread_self();//返回调用线程的线程ID.
int pthread_equal(pthread_t tid1, pthread_t tid2);//比较两个线程ID是否相等.相等返回非0, 不相等返回0.
```
- pthread_t不一定是一个数值类型(整数或指针)，也有可能是一个结构体
- 无法打印pthread_t的值，无法比较大小，只能比较想等，无法定义一个非法的pthread_t值
- 只保证在同一进程之内，同一时刻的各个线程的id不同，不能保证同一进程先后多个线程具有不同的id，也无法保证多个进程之间线程id的唯一性

```cpp
#include <sys/syscall.h> 
static_cast<pid_t>(::syscall(SYS_gettid))
```
- 进程id，类型pid_t，可以由getpid（）获取
- 线程id，类型pthread_t，可以由pthread_self（）获取
- 但是各个进程独立，所以会有不同进程中线程号相同的情况
- 真实的线程id唯一标识，tid,类型也是pid_t
  - 可以通过linux下的系统调用syscall(SYS_gettid)来获得

2. 线程的创建
```cpp
int pthread_create(pthread_t *restrict tidp, const pthread_attr_t *restrict attr, void *(start_rtn)(void*), void *restrict arg);
```
- 当一个程序由exec启动执行时，称为“初始线程”或“主线程”的单个线程就创建了。其余线程则由pthread_create函数创建
- restrict关键字用于告诉编译器，对象已经被指针所引用，不能通过除该指针外所有其他直接或间接的方式修改该对象的内容。
- 返回值: 成功则返回0, 否则返回错误编号.
- 参数: 
    - tidp: 指向新创建线程ID的变量, 作为函数的输出.
    - attr: 用于定制各种不同的线程属性, 通常情况下配置为NULL，使用缺省设置就可以了
    - start_rtn: 函数指针, 为线程开始执行的函数名.该函数可以返回一个void *类型的返回值，而这个返回值也可以是其他类型，并由 pthread_join()获取
    - arg: 该线程执行函数的参数，参数为一个无类型指针，如果需要向函数传递的参数有一个以上，那么需要把这些参数放到一个结构中，然后把这个结构的地址作为参数传入
- 创建的线程通过调用指定的函数开始执行，然后显示地（通过调用pthread_exit）或隐式地（通过让该函数返回）终止
- 线程创建时，并不能保证哪个线程会先运行
  
3. 线程属性
```cpp
typedef struct
{
    int   detachstate;   //线程的分离状态
    int   schedpolicy;   //线程调度策略
    struct sched_param   schedparam;   //线程的调度参数
    int inheritsched; //线程的继承性 
    int scope; //线程的作用域 
    size_t guardsize; //线程栈末尾的警戒缓冲区大小 
    int stackaddr_set; void * stackaddr; //线程栈的位置 
    size_t stacksize; //线程栈的大小
}pthread_attr_t;
```
*  __detachstate，表示新线程是否与进程中其他线程脱离同步，如果置位则新线程不能用pthread_join()来同步，且在退出时自行释放所占用的资源。缺省为PTHREAD_CREATE_JOINABLE状态。这个属性也可以在线程创建并运行以后用pthread_detach()来设置，而一旦设置为PTHREAD_CREATE_DETACH状态（不论是创建时设置还是运行时设置）则不能再恢复到  PTHREAD_CREATE_JOINABLE状态。
* __schedpolicy，表示新线程的调度策略，主要包括SCHED_OTHER（正常、非实时）、SCHED_RR（实时、轮转法）和  SCHED_FIFO（实时、先入先出）三种，缺省为SCHED_OTHER，后两种调度策略仅对超级用户有效。运行时可以用过  pthread_setschedparam()来改变。
* __schedparam，一个struct sched_param结构，目前仅有一个sched_priority整型变量表示线程的运行优先级。这个参数仅当调度策略为实时（即SCHED_RR或SCHED_FIFO）时才有效，并可以在运行时通过pthread_setschedparam()函数来改变，缺省为0。
* __inheritsched，有两种值可供选择：PTHREAD_EXPLICIT_SCHED和PTHREAD_INHERIT_SCHED，前者表示新线程使用显式指定调度策略和调度参数（即attr中的值），而后者表示继承调用者线程的值。缺省为PTHREAD_EXPLICIT_SCHED。
*  __scope，表示线程间竞争CPU的范围，也就是说线程优先级的有效范围。POSIX的标准中定义了两个值：  PTHREAD_SCOPE_SYSTEM和PTHREAD_SCOPE_PROCESS，前者表示与系统中所有线程一起竞争CPU时间，后者表示仅与同进程中的线程竞争CPU。目前LinuxThreads仅实现了PTHREAD_SCOPE_SYSTEM一值。


4. 线程退出
```cpp
void pthread_exit(void*value_ptr);

```
5. 线程取消
```cpp
int pthread_cancel(pthread_t thread);
```
- 该函数可以被某一线程调用，用来请求取消同一进程中的其它线程
- 函数只是发起取消请求，目标线程可以忽略取消请求或控制如何被取消（即执行一些清理函数）


6. 等待结束
```cpp
//如果value_ptr不为空，则来自所等待线程的返回值(一个指向某个对象的指针)将存入它所指向的位置
int pthread_join(pthread_t thread, void **value_ptr);
```
- 用于等待一个给定线程的终止,并且回收该线程中使用的资源
- 调用该函数的线程将挂起等待，直到id为thread的线程终止  
- 参数
  - tid：等待终止的线程ID。和进程不同的是，无法等待任意线程，所以不能通过指定ID参数为-1来企图等待任意线程终止
  - status：如果该指针非空，来自所等待线程的返回值（一个指向某个对象的指针）将存入由status指向的位置
- 对于一个非脱离状态的线程，如果没有其它线程调用pthread_join等待线程终止，那么线性终止后的资源无法回收，会造成资源浪费，进而影响同一进程创建的线程数量


7. 分离线程
```cpp
int pthread_detach(pthread_t thread);
 ```
- 把指定的线程转变为**脱离状态**
- 通常由想让自己脱离的线程调用：```pthread_detach(pthread_self());```
- 一个线程或者是**可汇合**的，或者是**脱离**的：
  - **可汇合**：一个可汇合线程终止时，它的线程ID和退出状态将保存到另一个线程对它调用pthread_join。如果一个线程需要知道另一个线程什么时候终止，那就最好保持第二个线程的可汇合状态
  - **脱离**：脱离的线程像守护进程，当它们终止时，所有相关资源都被释放，不能等待它们终止


8.和fork有关
```cpp
int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void));
```
- 三种函数
  - prepare 在父进程fork创建子进程之前调用
  - parent fork之后在父进程的进程环境中调用
  - child  fork之后在子进程环境中调用
  

## pthread的互斥锁和条件变量

- 互斥锁可以用于保护共享变量：访问共享变量的前提条件是持有该互斥锁，
- 创建互斥锁
  - 按照Pthread，互斥锁的类型为pthread_mutex_t的变量
  - 如果某个互斥锁变量是静态分配的，必须把它初始化为常值PTHREAD_MUTEX_INITIALIZER
  - 如果在共享内存区中分配一个互斥锁，必须通过调用pthread_mutex_init函数在运行时初始化
    - mutexattr用于指定互斥锁属性，如果为NULL则使用缺省属性
    - PTHREAD_MUTEX_TIMED_NP: 这是缺省值，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性。
    - PTHREAD_MUTEX_RECURSIVE_NP: 嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。如果是不同线程请求，则在加锁线程解锁时重新竞争。
    - PTHREAD_MUTEX_ERRORCHECK_NP: 检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁。
    - PTHREAD_MUTEX_ADAPTIVE_NP，适应锁，动作最简单的锁类型，仅等待解锁后重新竞争。
```cpp
#include <pthread.h>
pthread_mutex_t mutex=PTHREAD_MUTEX_INITIALIZER;//静态分配
int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);// 动态分配
```
- 锁操作
```cpp
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);//在锁已经被占据时返回EBUSY而不是挂起等待。
```
- 释放锁
  - 销毁一个互斥锁即意味着释放它所占用的资源，且要求锁当前处于开放状态。
  - 由于在Linux中，互斥锁并不占用任何资源，因此除了检查锁状态以外（锁定状态则返回EBUSY）没有其他动作。
```cpp
int pthread_mutex_destroy(pthread_mutex_t *mutex);
```

- 条件变量可以在某个条件发生之前，将线程投入睡眠
- 初始化条件变量
  - 条件变量是类型为pthread_cond_t的变量
  - 当参数cattr为空指针时，函数创建的是一个缺省的条件变量
  - 不能由多个线程同时初始化一个条件变量。当需要重新初始化或释放一个条件变量时，应用程序必须保证这个条件变量未被使用。
```cpp
#include <pthread.h>
pthread_cond_t cv = PTHREAD_COND_INITIALIZER;//静态
int pthread_cond_init(pthread_cond_t *cv, const pthread_condattr_t *cattr);//动态
```
- 阻塞，和互斥量配合使用
  - 将解锁mutex参数指向的互斥锁，并使当前线程阻塞在cv参数指向的条件变量上。被阻塞的线程可以被pthread_cond_signal函数，pthread_cond_broadcast函数唤醒，也可能在被信号中断后被唤醒。
  - pthread_cond_wait函数的返回并不意味着条件的值一定发生了变化，必须重新检查条件的值。
  - pthread_cond_wait函数返回时，相应的互斥锁将被当前线程锁定，即使是函数出错返回 
  - 一般一个条件表达式都是在一个互斥锁的保护下被检查。当条件表达式未被满足时，线程将仍然阻塞在这个条件变量上。当另一个线程改变了条件的值并向条件变量发出信号时，等待在这个条件变量上的一个线程或所有线程被唤醒，接着都试图再次占有相应的互斥锁。
  - 阻塞在条件变量上的线程被唤醒以后，直到pthread_cond_wait()函数返回之前条件的值都有可能发生变化。所以函数返回以后，在锁定相应的互斥锁之前，必须重新测试条件值。最好的测试方法是循环调用pthread_cond_wait函数，并把满足条件的表达式置为循环的终止条件.
```cpp
int pthread_cond_wait(pthread_cond_t *cv,pthread_mutex_t *mutex);
// 函数到了一定的时间，即使条件未发生也会解除阻塞。这个时间由参数abstime指定。函数返回时，相应的互斥锁往往是锁定的
// 超时时间参数是指一天中的某个时刻,绝对时间
int pthread_cond_timedwait(pthread_cond_t *cv,pthread_mutex_t *mp, const struct timespec * abstime);
// 通常的使用模式，要用循环
pthread_mutex_lock();
while (condition_is_false)
  pthread_cond_wait();
pthread_mutex_unlock();
```
- 解除阻塞
  - 函数被用来释放被阻塞在指定条件变量上的一个线程。
  - pthread_cond_signal即可以放在pthread_mutex_lock和pthread_mutex_unlock之间，也可以放在pthread_mutex_lock和pthread_mutex_unlock之后，但是各有各缺点。
  - 之间
    - 会有潜在的性能损耗
    - pthread_cond_signa可能会唤醒等待的线程，但此时锁还没被释放，该线程只能被迫再次进入休眠直到释放了锁
    - 但在Linux中没有这个问题，所以推荐放中间
      - 因为在Linux 线程中，有两个队列，分别是cond_wait队列和mutex_lock队列， cond_signal只是让线程从cond_wait队列移到mutex_lock队列，而不用返回到用户空间，不会有性能的损耗
  - 之后
    - 如果unlock和signal之前，有个低优先级的线程正在mutex上等待的话，那么这个低优先级的线程就会抢占高优先级的线程（cond_wait的线程)
```cpp
int pthread_cond_signal(pthread_cond_t *cv);//释放被阻塞在指定条件变量上的一个线程。
int pthread_cond_broadcast(pthread_cond_t *cv);//释放阻塞的所有线程
// 通常的使用模式
pthread_mutex_lock(&mut);
if (condition_is_true) 
    pthread_cond_signal(&cond);
pthread_mutex_unlock(&mut); 

```
- 唤醒丢失问题
  - 在线程未获得相应的互斥锁时调用pthread_cond_signal或pthread_cond_broadcast函数可能会引起唤醒丢失问题。
  - 唤醒丢失往往会在下面的情况下发生：
    - 一个线程调用pthread_cond_signal或pthread_cond_broadcast函数；另一个线程正处在测试条件变量和调用pthread_cond_wait函数之间；
    - 没有线程正在处在阻塞等待的状态下。

## c++里的多线程
- lock_guard
  - 创建lock_guard对象时，它将尝试获取提供给它的互斥锁的所有权。当控制流离开lock_guard对象的作用域时，lock_guard析构并释放互斥量
  - 不能中途解锁，必须等作用域结束才解锁
- unique_guard
  - 可以随时加锁解锁
  - 和条件变量配合使用，条件变量需要该类型的锁作为参数
- 所有 lock_guard 能够做到的事情，都可以使用 unique_lock 做到，反之则不然。

```cpp
#include <mutex>
#include <condition_variable>

class CountDownLatch
{
public:
    explicit CountDownLatch(int count) : count_(count) {}
    void wait()
    {
        std::unique_lock<std::mutex> lock(mutex_);
        while (count_ > 0)
            cond_.wait(lock);
    }

    void countDown()
    {
        std::lock_guard<std::mutex> lock(mutex_);
        --count_;
        if (count_ == 0)
            cond_.notify_all();
    }
    int getCount()
    {
        std::lock_guard<std::mutex> lock(mutex_);
        return count_;
    }

private:
    mutable std::mutex mutex_;
    std::condition_variable cond_;
    int count_;
};
```