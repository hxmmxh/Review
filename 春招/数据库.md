

# 数据库系统原理

## 关系型数据库和非关系型数据库的区别

- 关系型数据库：指采用了关系模型来组织数据的数据库。
  - 关系模型把数据看作是一个二维表格，任何数据都可以通过行号+列号来唯一确定
  - MySQL，Oracle
- 非关系型数据库：指非关系型的，分布式的
  - 以键值对存储，且结构不固定，每一个元组可以有不一样的字段，每个元组可以根据需要增加一些自己的键值对，不局限于固定的结构，可以减少一些时间和空间的开销。
  - Redis

## 什么是SQL

- SQL是结构化查询语言的缩写，用来访问和操作数据库系统
- 可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还可以对数据库进行管理和维护操作
- 不同的数据库，都支持SQL，这样，我们通过学习SQL这一种语言，就可以操作各种不同的数据库。
  - DDL：Data Definition Language
    - DDL允许用户定义数据，也就是创建表、删除表、修改表结构这些操作。通常，DDL由数据库管理员执行。
  - DML：Data Manipulation Language
    - DML为用户提供添加、删除、更新数据的能力，这些是应用程序对数据库的日常操作。
  - DQL：Data Query Language
    - DQL允许用户查询数据，这也是通常最频繁的数据库日常操作。

## 数据库三大范式

- 第一范式（1NF）
  - 数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性
  - （比如“姓名与年龄“，我们应该拆分成两个字段：“姓名“、“年龄“。）
- 第二范式（2NF）
  - 满足1NF后，要求表中的所有列，都必须依赖于同一个主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情
  - （比如我们主字段是教师的“姓名“，那么字段“年龄“、“工号“、“工资“、“电话“都是与教师相关的，而字段“销售额“跟我们教师没有关系，就要去掉。）
- 第三范式（3NF）
  - 必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关
  - （如果某一属性依赖于其他非主键属性，而其他非主键属性又依赖于主键，那么这个属性就是间接依赖于主键）

## 聚簇索引与非聚簇索引

- 聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据
- 非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行



# 事务
- 事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。事务是DBMS中最基础的单位，事务不可分割。

## ACID

- 原子性（Atomicity）
  - 事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。
  - 回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。
- 一致性（Consistency）
  - 数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。
- 隔离性（Isolation）
  - 一个事务所做的修改在最终提交以前，对其它事务是不可见的。
  - 一个事务不应该影响其它事务运行效果
- 持久性（Durability）
  - 一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。
  - 使用重做日志来保证持久性。
- 特性之间的相关性
  - 只有满足一致性，事务的执行结果才是正确的。
  - 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。
  - 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
  - 事务满足持久化是为了能应对数据库崩溃的情况


## 并发一致性问题
- 丢失修改
  - T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。
- 读脏数据
  - T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。
- 不可重复读
  - T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。
- 幻读
  - T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。


## 4种隔离级别

- 未提交读READ UNCOMMITTED
  - 一个事务在提交之前，对其他事务是可见的，即事务可以读取未提交的数据。
  - 存在“脏读”（读到了脏数据）问题；
- 提交读READ COMMITTED：
  - 事务在提交之前，对其它事务是不可见的。
  - 存在“不可重复读”（两次查询的得到的结果可能不同，即可能在查询的间隙，有事务提交了修改）问题。解决了“脏读”问题。
- 可重复读REPEATABLE READ：
  - 在同一事务中多次读取的数据是一致的。
  - 解决了脏读和不可重复读问题，存在“幻读”（在事务两次查询间隙，有其他事务又插入或删除了新的记录）。--- MySQL默认隔离级别。
- 可串行化SERIALIZABLE：
  - 强制事务串行化执行。即一个事物一个事物挨个来执行，
  - 可以解决上述所有问题。



# 锁

## 锁粒度

- MySQL 中提供了两种封锁粒度
  - 表级锁：锁住整张表，读锁互不阻塞，写锁阻塞其他所有读写锁（同一张表）。开销最小。
  - 行级锁：对每一行数据（记录）加锁，开销大，并发程度高
- 锁定的数据量越少（粒度越小），并发程度越高，但相应的加锁、检测锁、释放锁用的系统开销也随之增大。
- 锁策略：锁开销与数据安全性之间的平衡


## 锁类型

- 读写锁
  - 共享锁/读锁（S）：互不阻塞，优先级低
  - 排他锁/写锁(X)：阻塞其他锁，优先级高，即确保在一个事务写入时不受其他事务的影响。
  - 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。
  - 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A加 S 锁，但是不能加 X 锁。
- 意向锁
  - 在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。
  - 意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S锁
  - 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；
  - 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。

## 悲观锁和乐观锁

- 悲观锁
  - 是对数据被外界修改持保守态度，在整个数据处理过程中，将数据处于锁定状态。
  - 悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）
- 乐观锁
  - 认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做（一般是回滚事务）


## 三级封锁协议
- 一级封锁协议
  - 事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。
  - 可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。
- 二级封锁协议
  - 在一级的基础上，要求读取数据 A 时必须加 S 锁，**读取完**马上释放 S 锁。
  - 可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S锁了，也就是不会读入数据。
- 三级封锁协议
  - 在二级的基础上，要求读取数据 A 时必须加 S 锁，**直到事务结束了**才能释放 S 锁。
  - 可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。






# MySql基本概念

## 关系模型

- 关系模型本质上就是若干个存储数据的二维表
- 表的每一行称为记录（Record），记录是一个逻辑意义上的数据。
- 表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段
  - 字段定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为NULL
  - NULL表示字段数据不存在。一个整型字段如果为NULL不表示它的值为0，同样的，一个字符串型字段为NULL也不表示它的值为空串''
- 表和表之间需要建立“一对多”，“多对一”和“一对一”的关系，这样才能够按照应用程序的逻辑来组织和存储数据。
  - 多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系
  - 一对一关系:把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高的性能。例如，把一个大的用户表分拆为用户基本信息表user_info和用户详细信息表user_profiles，大部分时候，只需要查询user_info表，并不需要查询user_profiles表，这样就提高了查询速度

## 主键

- 主键是能确定一条记录的唯一标识，其值能够唯一区分表中的每个行
- 主键的要求
  - 任意两行都不具有相同的主键值  
  - 每个行都必须具有一个主键值，主键值不应该允许NULL
- 主键的最好习惯
  - 一旦插入到表中，主键最好不要再修改
  - 不使用任何业务相关的字段（和数据有关的）作为主键
- 常见的可作为主键的类型
  - 自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键；
  - 全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。
- 联合主键
  - 还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。
  - 允许一列有重复，只要不是所有主键列都重复即可
  - 没有必要的情况下，我们尽量不使用联合主键，因为它给关系表带来了复杂度的上升。


## 外键

- 外键用于与另一张表的关联。它为表中的某一列，包含了另一个表的主键值，定义了两个表之间的关系
- 外键可以通过定义外键约束实现
  - 两个表students和classed,分别有一列为class_id和id
  - 外键约束的名称fk_class_id可以任意，`FOREIGN KEY (class_id)`指定了`class_id`作为外键，`REFERENCES classes (id)`指定了这个外键将关联到classes表的id列（即classes表的主键）
  - 通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果classes表不存在id=99的记录，students表就无法插入class_id=99的记录
  - 但是由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性
- 外键不能跨引擎
```sql
--建立一个外键约束
ALTER TABLE students
ADD CONSTRAINT fk_class_id
FOREIGN KEY (class_id)
REFERENCES classes (id);
--删除一个外键约束
ALTER TABLE students
DROP FOREIGN KEY fk_class_id;
```

## mysql的存储引擎

- MyISAM、InnoDB。mysql默认引擎是MyISAM。
- InnoDB是一个可靠的事务处理引擎。
  - 支持事务、支持所有隔离级别、行级锁、外键关联、灾难恢复性好、索引和数据是在一起的、用的B+树。不保存行列的信息，使用select需要扫描全表，查找慢些。
  - 不支持全文本搜索
- MyISAM 不支持事务、不支持行级锁、外键关联，灾难恢复性差、在读写的时候需要锁住整个表，效率低些。但是查找的时候保持行列信息，通过select可以查找相对比较快，索引和数据是分开的、用的B+树。

## 索引

- 索引是对数据库表中一列或多列的值进行排序的一种结构
- 使用索引可快速访问数据库表中的特定信息。与在表中搜索所有的行相比，索引有助于更快地获取信息。
- 唯一、不为空、经常被查询的字段适合建立索引。
- 索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值,对该列创建索引就没有意义。
- 对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一

```sql
--创建了一个名称为idx_score，使用列score的索引
ALTER TABLE students
ADD INDEX idx_score (score)
--索引如果有多列，可以在括号里依次写上
ALTER TABLE students
ADD INDEX idx_name_score (name, score);
--创建唯一索引，通过UNIQUE关键字
ALTER TABLE students
ADD UNIQUE INDEX uni_name (name);
```
- 索引优缺点
  - 优点：提高了查询效率
  - 缺点：在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢
- 索引类型与索引模型
  - 普通索引：哈希表、红黑树；
  - 唯一索引：比如设定学号为索引；
  - 主键索引：设定主键作为索引；
  - 联合索引：多个字段共同索引；
  - 全文索引：查找关键字。
  - 索引模型：哈希表、红黑树、B树、B+树

## 安装和启动





# MySql操作

## 安装，登录

- 启动服务`service mysql start`
- 登录服务器`mysql -u<user> -p`


## 数据库操作

- `SHOW DATABASES`, 返回可用数据库的一个列表
- `USE <database>`, 必须先使用USE打开数据库，才能读取其中的数据
- `SHOW TABLES`, 返回当前选择的数据内可用表的列表
- `SHOW COLUMNS FROM <table>`, `DESCRIBE <table>`, 返回给定表的列信息 
  - 字段名，数据类型，是否可以为NULL，建信息（主键？外键？）,默认值，其他信息

### 创建和操纵表

- 创建新表
  - CREATE TABLE <表名>(列的名字和定义)；
  - 各列之间用逗号分隔
  - 表的主键可以在创建时用PRIMARY KEY关键字指定
  - 创建新表时，指定的表名必须不存在
- 每个列或者是NULL值，或者是NOT NULL值。NULL是默认设置。
- AUTO_INCREMENT
  - 本列每增一行时自动增量
  - 每个表只允许有一个AUTO_INCREMENT列，而且它必须被索引
  - 可以指定自己给定的值，只要它是唯一的，后续的增量从这个指定的值开始
  - `SELECT last_insert_id()`返回最后一个AUTO_INCREMENT的值
- 可以用DEFALUT指定默认值
```sql
CREATE TABLE customers
(
  cust_id      int       NOT NULL AUTO_INCREMENT,
  cust_name    char(50)  NOT NULL ,
  cust_address char(50)  NULL ,
  cust_city    char(50)  NULL ,
  cust_state   char(5)   NULL ,
  cust_zip     char(10)  NULL ,
  cust_country char(50)  NULL ,
  cust_contact char(50)  NULL ,
  cust_email   char(255) NULL ,
  PRIMARY KEY (cust_id)
) ENGINE=InnoDB;
CREATE TABLE orderitems
(
  order_num  int          NOT NULL ,
  order_item int          NOT NULL ,
  prod_id    char(10)     NOT NULL ,
  quantity   int          NOT NULL DEFAULT 1,
  item_price decimal(8,2) NOT NULL ,
  PRIMARY KEY (order_num, order_item)
) ENGINE=InnoDB;

```

### 更新表

- `ALTER TABLE <表名>`
- ADD 增加列，需要明确列的数据类型
- DROP COLUMN 删除列
- 增加外键 `ADD CONSTRAINT [] FOREIGN KEY [] REFERENCES []`
```sql
ALTER TABLE orderitems ADD CONSTRAINT fk_orderitems_orders FOREIGN KEY (order_num) REFERENCES orders (order_num);
ALTER TABLE orderitems ADD CONSTRAINT fk_orderitems_products FOREIGN KEY (prod_id) REFERENCES products (prod_id);
ALTER TABLE orders ADD CONSTRAINT fk_orders_customers FOREIGN KEY (cust_id) REFERENCES customers (cust_id);
ALTER TABLE products ADD CONSTRAINT fk_products_vendors FOREIGN KEY (vend_id) REFERENCES vendors (vend_id);
```

### 重命名表

- `DROP TABLE <表名>`
- 删除表没有确认，也不能撤销
  
### 删除表
- `RENAMW TABLE <旧表名> TO <新表名>`

## 查询数据

- 常用字句的用户以及顺序

|字句|说明|是否必须使用|
|----|----|-------|
SELECT|要返回的列或表达式|是|
FROM|从中检索数据的表|仅在从表选择数据时使用
WHERE|行级过滤|
GROUP BY|分组|仅在按组计算聚集时使用
HAVING|组级过滤|
ORDER BY|输出排序顺序|
LIMIT|要检索的行数|

### 基本查询

- `SELECT * FROM <表名>`, 查询一个表的所有行和所有列的数据
- 只希望返回某些列的数据，而不是所有列的数据
  - `SELECT 列1, 列2, 列3 FROM <表名>`
  - `SELECT 列1 AS 别名1, 列2 别名2, 列3 别名3 FROM <表名>`, 给每一列起个别名，结果集的列名就可以与原表的列名不同.AS可写可不写
- 不带select的语句可以用来计算，也可以用来判断当前到数据库的连接是否有效。许多检测工具会执行一条`SELECT 1`来测试数据库连接
- 只检索不同的行,DISTINCT
  - `SELECT DISTINCT <列名> FROM <表名>`
  - DISTINCT必须直接放在列名的前面
  - 应用于所有的列，而不仅是前置它的列
- 从结果中“截取”出记录,LIMIT, OFFSET
  - `LIMIT <M> OFFSET <N>`,从N号记录开始取最多M条记录，等于`LIMIT N,M`
  - OFFSET是可选的，如果只写LIMIT 15，那么相当于LIMIT 15 OFFSET 0
  - OFFSET超过了查询的最大数量并不会报错，而是得到一个空的结果集
  - 注意检索出来的第一行为行0而不是行1

### 排序

- 使用SELECT查询时，查询结果集通常是按照id排序的，也就是根据主键排序。
- 要根据其他条件排序可以加上ORDER BY子句
- 默认的排序规则是ASC：“升序”，即从小到大。ASC可以省略。可以加上DESC表示倒序，DESC只应用到直接位于其前面的列名
- 可以对多列进行排序例如`ORDER BY score DESC, gender`
- ORDER BY子句要放到WHERE子句后面，LIMIT字句前面

### 条件查询

- 以通过WHERE条件来设定查询条件，查询结果是满足查询条件的记录
- `SELECT * FROM <表名> WHERE <条件表达式>`
- WHERE中的可用操作符
  - `=,!=,<,<=,>,>=`
  - `<>`表示不等于
  - `BETWEEN a AND b`，在指定的两个值之间,闭区间[a,b]
  - `IN (a,b,c...)`，等于a或b或c...
  - `IS NULL`，判断是否是空值
  - `IS NOT NULL`
- 组合的条件表达式
  - NOT <条件>,可以对IN,BETWEEN使用
  - <条件1> OR <条件2>
  - <条件1> AND <条件2>
  - NOT优先级最高，其次是AND，最后是OR
  - 可以用圆括号明确指出结合的顺序
- 通配符，使用LIKE利用通配符匹配
  - 区分大小写
  - %，任何字符出现任意字数，包括0次
  - _, 下划线, 匹配单个字符而不是多个字符
- 正则表达式，REGEXP
  - 默认不区分大小写，如果要区别，用REGEXP BINARY
  - [规则](./linux.md/#1-正则表达式)
  - mysql中用反斜线转义时要用两个反斜线，mysql自己解释一个，正则表达式解释一个
  - 可以用SELECT进行简单的正则表达式测试，返回0(不匹配)或1(匹配)。`SELECT 'hello' REGEXP '[0-9]'`
- LIKE和REGEXP的区别
  - LIKE匹配整个列，文本要等于整个列
  - REGEXP在列中进行匹配，文本在列中出现过，就是匹配成功
- 单引号用来限定字符串，将值与串类型的列进行比较时需要限定引号。用来和数值列进行比较时不需要引号

```sql
SELECT prod_name, prod_price
FROM products
WHERE prod_name='fuses';
SELECT vend_id, prod_name
FROM products
WHERE vend_id != 1003;
SELECT prod_name, prod_price
FROM products
WHERE prod_price BETWEEN 5 AND 10;
SELECT prod_name, prod_price
FROM products
WHERE vend_id IN (1002,1003)
ORDER BY prod_name;
SELECT prod_id,prod_name
FROM products
WHERE prod_name LIKE '%anvil%';
SELECT prod_id,prod_name
FROM products
WHERE prod_name LIKE '_ ton anvil';
```

### 函数

- [详细介绍](https://www.runoob.com/mysql/mysql-functions.html)
- 文本处理函数
  - 拼接，`Concat (a,b,c...)`
    - 把多个串连接起来形成一个较长的串
  - 去除空格
    - RTrim(),去掉值右边的所有空格
    - LTrim(),去掉值左边的所有空格
    - Trim(),去掉左右两边的空格
  - 将文本串转换成描述其语音表示的字母数字模式 Soundex()
  - 大小写转换
    - Upper(),转换成大写
    - Lower(),转换成小写
- 日期和时间处理函数
  - mysql的日期格式必须是yyyy-mm-dd
  - Date(),返回日期时间的日期部分
  - Time(),返回日期时间的时间部分
- 数值函数

```sql
SELECT Concat (vend_name, '(', vend_country, ')')
FROM vendors
ORDER BY vend_name;
SELECT Concat (RTrim(vend_name), '(', vend_country, ')') AS vend_title
FROM vendors
ORDER BY vend_name;
SELECT cust_id, order_num
FROM orders
WHERE Date(order_date) BETWEEN '2005-09-01' AND '2005-09-30';
```

### 汇总数据

- 使用聚集函数统计总数、平均数,最大值，最小值
  - COUNT 符合特定条件的行的数目
  - SUM	计算某一列的合计值，该列必须为数值类型
  - AVG	计算某一列的平均值，该列必须为数值类型
  - MAX	计算某一列的最大值
  - MIN	计算某一列的最小值
- 聚合查询同样可以使用WHERE条件
- 指定聚集不同值，使用DISTINCT参数
- 分组聚合，GROUP BY，先分组再统计(可以使用多个列)
- 举例：
```sql
SELECT COUNT(*) num FROM students;
SELECT COUNT(*) boys FROM students WHERE gender = 'M';
SELECT AVG(score) average FROM students WHERE gender = 'M';
SELECT COUNT(*) num FROM students GROUP BY class_id;
SELECT class_id, COUNT(*) num FROM students GROUP BY class_id;
SELECT class_id, gender, COUNT(*) num FROM students GROUP BY class_id, gender;
SELECT AVG(DISTINCT prod_price) avg_price
FROM products
WHERE vend_id=1003;
```

### 分组数据

- 把数据分成多个逻辑组，以便能对每个组进行聚集计算
- GROUP BY
  - GROUP BY字句可以包含任意数据的列
  - 每个列必须是检索列或有效的表达式（不能是聚集函数）
    - 如果在SELECT中使用表达式，必须在GROUP BY中指定相同的表达式，不能使用别名
  - 除了聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY 语句中给出
  - 如果列中有NULL值，NULL将作为一个分组返回
  - 必须出现在WHERE子句后，ORDER BY子句前
  - 加了WITH ROLLUP会在最后一行汇总
- HAVINF 过滤分组
  - 不能使用WHERE，因为WHERE过滤的是行，而不是分组
  - HAVING的语法和WHERE是一样的
  - HAVING和WHERE可以同时使用，WHERE在数据分组前进行过滤，HAVING是在数据分组后进行过滤
```sql
SELECT vend_id, COUNT(*) AS num_prods
FROM products
GROUP BY vend_id WITH ROLLUP;
SELECT cust_id, COUNT(*) AS orders
FROM orders
GROUP BY cust_id
HAVING count(*)>=2;
SELECT vend_id, COUNT(*) AS num_prods
FROM products
WHERE prod_price>=10
GROUP BY vend_id
HAVING COUNT(*)>=2;
SELECT order_num, SUM(quantity*item_price) AS ordertotal
FROM orderitems
GROUP BY order_num
HAVING ordertotal >=50
ORDER BY ordertotal;
```

### 子查询

- 嵌套在其他查询中的查询
- 可以把一条SELECT语句返回的结果用于另一条SELECT语句的WHERE子句，与IN操作符结合使用

```sql
SELECT cust_name, cust_contact
FROM customers 
WHERE cust_id IN (SELECT cust_id 
                  FROM orders
                  WHERE order_num IN (SELECT order_num
                                      FROM orderitems
                                      WHERE prod_id='TNT2'));
SELECT cust_name, cust_state, (SELECT COUNT(*)
                               FROM orders
                               WHERE orders.cust_id=customers.cust_id) AS orders
FROM customers
ORDER BY cust_name;

```

### 多表查询

- SELECT查询不但可以从一张表查询数据，还可以从多张表同时查询数据。
- `SELECT * FROM <表1> <表2>`
  - 查询的结果也是一个二维表，它是表1和表2的“乘积”，即表1的每一行与表2的每一行都两两拼在一起返回。结果集的列数是表1和表2的列数之和，行数是表1和表2的行数之积
  - 这种多表查询又称笛卡尔查询，使用笛卡尔查询时要非常小心，由于结果集是目标表的行数乘积，对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录
  - 可以利用“设置列的别名”来给两个表各自的id和name列起别名
  - 要使用`表名.列名`这样的方式。还允许给表设置一个别名,让它简洁一些
  - 也可以添加WHERE条件
```sql
SELECT
    s.id sid,
    s.name,
    s.gender,
    s.score,
    c.id cid,
    c.name cname
FROM students s, classes c
WHERE s.gender = 'M' AND c.id = 1;
SELECT vend_name, prod_name, prod_price
FROM vendors, products
WHERE vendors.vend_id=products.vend_id
ORDER BY vend_name, prod_name;
SELECT vend_name, prod_name, prod_price
FROM vendors INNER JOIN products
ON vendors.vend_id =products.vend_id
```

### 连接查询

- 对多个表进行JOIN运算，先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上
- 内连接——INNER JOIN
  - 先确定主表，仍然使用FROM <表1>的语法；
  - 再确定需要连接的表，使用INNER JOIN <表2>的语法；
  - 然后确定连接条件，使用ON <条件...>，这里的条件是s.class_id = c.id，表示students表的class_id列与classes表的id列相同的行需要连接；
  - 可选：加上WHERE子句、ORDER BY等子句。
  - 使用别名不是必须的，但可以更好地简化查询语句
  - INNER JOIN只返回同时存在于两张表的行数据
- 外连接-OUTER JOIN
  - RIGHT OUTER JOIN返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以NULL填充剩下的字段
  - LEFT OUTER JOIN则返回左表都存在的行
  - FULL OUTER JOIN，它会把两张表的所有记录全部选择出来，并且，自动把对方不存在的列填充为NULL

```sql
--内连接
SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
FROM students s
INNER JOIN classes c
ON s.class_id = c.id;
--外连接
SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
FROM students s
RIGHT OUTER JOIN classes c
ON s.class_id = c.id;

```

### 组合查询

- 可以执行多个查询，并将结果作为单个查询结果集返回
- UNION，由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分开
- UNION中的每个查询必须包含相同的列，表达式或聚集函数（次序可以不一致）
- UNION在查询结果集中自动去除了重复的行。如果不想这样做，用UNION ALL
- UNION组合查询只能使用一条ORDER BY子句，且必须出现在最后一条SELECT语句之后

```sql
SELECT vend_id, prod_id, prod_price
FROM products
WHERE prod_price <=5
UNION
SELECT vend_id, prod_id, prod_price
FROM products
WHERE vend_id IN (1001,1002)
ORDER BY vend_id, prod_price;

```

### 全文本搜索

- MyISAM支持全文本搜索，而InnoDB不支持
- 为了进行全文本搜索，必须索引被搜索的列，而且随着数据的改变要不断地重新索引
- 启动全文本搜索支持
  - 可以在创建表时指定，CREATE TABLE时增加FULLTEXT子句，给出被索引列的列表
  - 也可以稍后指定
- 进行全文本搜索
  - MATCH()指定被搜索的列，Against()指定要使用的搜索表达式
  - 会对结果进行排序，具有较高优先级的行先返回
  - 优先级根据行中词的数目，唯一词的数目，整个索引中词的总数，以及包含该词的行的数目计算得到
- 使用查询扩展
  - 在Against()内加上WITH　QUERY EXPANSION
  - 首先进行一个基本的全文本搜索，找出与搜索条件匹配的所有行
  - 然后检查这些匹配行并选择所有有用的词
  - 再次进行全文本搜索，不仅使用原来的条件，还使用所有有用的词
```sql
SELECT note_text
FROM productnotes
WHERE MATCH(note_text) Against ('rabbit');
SELECT note_text, MATCH(note_text) Against ('rabbit') AS ran
FROM productnotes;
```

## 修改数据

### 插入 INSERT, REPLACE
- `INSERT INTO <表名> VALUES (值1，值2....)`
  - 表中存在的每个列都必须提供值
  - 且必须以列在表中出现的次序填充
- `INSERT INTO <表名> (字段1, 字段2, ...) VALUES1(值1, 值2, ...), VALUES2(.....);`
  - 字段顺序不必和数据库表的字段顺序一致，但值的顺序必须和字段顺序一致
  - 更安全，推荐使用这种写法
  - 即使表的结构发生改变，这种写法也能正常使用
- 还可以一次性添加多条记录，只需要在VALUES子句中指定多个记录值，每个记录是由(...)包含的一组值，用逗号分隔
- 如果表的定义允许，可以在插入操作中省略某些列
  - 该列定义为允许NULL值
  - 或者定义中给出了默认值
- `INSERT LOW_PRIORITY INTO`,降低插入语句的优先级
- 可以将一条SELECT语句的结果插入到表中，也可以包含WHERE子句过滤要插入的数据
  - `INSERT INTO <表名>(字段1，字段2...) SELECT 字段1，字段2....FROM <表名2> `
- REPLACE: 插入一条新记录，但如果记录已经存在，就先删除原记录，再插入新记录
  
```sql
INSERT INTO students (class_id, name, gender, score) VALUES (2, '大牛', 'M', 80);
INSERT INTO students (class_id, name, gender, score) VALUES
  (1, '大宝', 'M', 87),
  (2, '二宝', 'M', 81);
REPLACE INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'F', 99);
-- 插入一条新记录，但如果记录已经存在，就更新该记录
INSERT INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'F', 99) ON DUPLICATE KEY UPDATE name='小明', gender='F', score=99;

```

### 更新 UPDATE
 
- `UPDATE <表名> SET 字段1=值1, 字段2=值2, ... WHERE ...`
- 更新字段时可以使用表达式
- 如果WHERE条件没有匹配到任何记录，UPDATE语句不会报错，也不会有任何记录被更新
- UPDATE语句可以没有WHERE条件,此时整个表的所有记录都会被更新
- UPDATE IGNORE 更新发生了错误也继续更新

```sql
UPDATE students SET name='大牛', score=66 WHERE id=1;
UPDATE students SET score=score+10 WHERE score<80;
```

### 删除 DELETE

- `DELETE FROM <表名> WHERE ...`
- DELETE语句的WHERE条件也是用来筛选需要删除的行，因此和UPDATE类似，DELETE语句也可以一次删除多条记录
- 如果WHERE条件没有匹配到任何记录，DELETE语句不会报错，也不会有任何记录被删除
- 不带WHERE条件的DELETE语句会删除整个表的数据
- 如果想要删除所有行，不要使用DELETE,使用 TRUNCATE TABLE,速度更快

## 视图

### 视图的概念
- 视图是虚拟的表，只包含使用时动态检索数据的查询
- 视图本身不包含数据，仅仅是用来查看存储在别处的数据的一种设施

### 使用视图
- CREATE VIEW,创建视图

## 存储过程

## 游标

## 触发器