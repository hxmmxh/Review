
- [0.概述](#0概述)
  - [TCP特征简介](#tcp特征简介)
  - [TCP头部和封装](#tcp头部和封装)
- [1.连接管理](#1连接管理)
  - [连接的建立与终止](#连接的建立与终止)
    - [异常情况](#异常情况)
    - [半关闭](#半关闭)
    - [同时打开和关闭](#同时打开和关闭)
  - [TCP攻击](#tcp攻击)
  - [TCP](#tcp)
- [超时与重传](#超时与重传)

--------------------
# 0.概述

在有损通信信道上提供可靠通信

## TCP特征简介
- TCP提供一种面向连接、可靠的的字节流服务
  - 面向连接：使用TCP的两个应用程序必须在它们可交换数据之前，通过相互联系来建立一个TCP连接。每个TCP连接由一对套接字唯一标识
  - 字节流：没有消息边界。对字节流的解读取决于连接中的每个端点
  - 单播

## TCP头部和封装

<img src="../pic/TCP封装.png" width = "600" height = "" alt="图片名称" align=center>  
<img src="../pic/TCP头部.png" width = "600" height = "" alt="图片名称" align=center>

- 20字节的固定大小
- 源端口号，目的端口号。和IP头部中的源和目的IP地址一起唯一地标识了每个连接
- 序列号：TCP的序号是数据流中的字节数，不是分组的序号。表示该报文段数据字段首字节的序号
- 确认号(ACK)：TCP使用累积确认，确认号是第一个未收到的字节序号，表示希望接收到的下一个字节
- 头部长度：以32位字为单位给出头部的大小(最小值为5，也就是20字节)，最大为15，也就是60字节
- 标志字段 
  - CWR: 拥塞窗口减，发送方降低发送速率
  - ECE:ECN回显，发送方接收到了一个更早的拥塞报告
  - URG：报文段中存在着(被发送方的上层实体置位)“紧急”的数据
  - ACK: 指示确认字段中的值是有效的
  - PSH：指示接收方应立即将数据交给上层(实际没被可靠的实现或利用）
  - RST：重置连接
  - SYN：初始化一个连接的同步序列号
  - FIN: 用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。
- 接收窗口：用于流量控制（表示接收方还有多少可用的缓存空间）
- 校验和：
- 紧急指针：只有在URG字段被设置时才有效。
- 常见选项字段，最多40字节
  - MSS,最大段大小。指定该选项的发送者在相反方向上希望接收到的报文段的最大值
  - SACK
  - 时间戳
  - 窗口缩放
- **不带数据部分的TCP报文段**
  - 连接建立和终止时
  - 纯ACK
  - 窗口更新

# 1.连接管理

- 一个TCP连接由一对套接字(IP地址和端口的组合)构成
  
## 连接的建立与终止

<img src="../pic/TCP建立和终止.png" width = "600" height = "" alt="TCP建立和终止" align=center>

- 传统情况下，发送连接和发起关闭的都是Client
- 建立连接的三次握手
  1. Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。 
  2. Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态,为该TCP连接分配TCP缓存和变量。 
  3. Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，为该连接分配缓存和变量,并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态。
- 关闭连接的四次挥手
  1. Client将标志位FIN置位，Seq=K,同时包含ACK用于确认对方最近一次发来的数据，Client进入FIN_WAIT_1状态，此时客户端依然可以接收服务器发送来的数据。 
  2. Server接收到FIN后，发送一个ACK=K+1给客户端，表明已经成功接收到了FIN。同时Server进入CLOSE_WAIT状态。客户端收到后进入FIN_WAIT_2状态。 
  3. 当Server没有数据要发送时，发起自己的关闭操作。服务器发送一个FIN报文，此时服务器进入LAST_ACK状态，等待客户端的确认 
  4. 客户端收到服务器的FIN报文后，给服务器发送一个ACK报文，确认序列号为收到的序号+1。此时客户端进入TIME_WAIT状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接。 

### 异常情况

- 服务器关闭
- 









### 半关闭

### 同时打开和关闭 



## TCP攻击

- **SYN cookies预防SYN洪泛攻击：**
    * 当服务器接收到一个SYN报文段时，它并不知道该报文段是来自一个合法的用户，还是一个SYN洪泛攻击的一部分。因此服务器不会为该报文段生成一个半开TCP连接。相反，服务器生成一个初始TCP序列号y，该序列号是SYN报文段的源和目的IP地址、端口号以及仅被该服务器所知的秘密数的一个散列函数，这种精心制作的初始序列号被称作“cookie”。服务器发送具有这种特殊序列号的SYNACK分组，服务器并不记忆该cookie或任何对应于SYN的其他状态信息
    * 如果客户机是合法的，它将返回一个ACK报文段。服务器一旦收到该ACK，需要验证与前面发送的某些SYN对应的ACK。对于一个合法的ACK，确认字段中的值等于SYNACK序号字段y的值加1。服务器将使用在ACK报文段中的相同字段和秘密数运行相同的函数。如果该函数的结果加1与确认号相同，服务器就认为该ACK对应于前面发送的SYN报文段，生成一个具有套接字的全开的连接
    * 如果客户机没有返回一个ACK报文段，则初始化的SYN也没有对该服务器产生危害，因为服务器没有为它分配任何资源

## TCP

# 超时与重传

