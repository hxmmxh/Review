# 套接字编程

- 一个IP地址和一个端口的组合被称为套接字


## 常用接口

## 常见IO模型

### 常见的五种IO模型

1. 阻塞IO（blocking I/O）:
   * 调用者调用了某个函数，等待这个函数返回，期间什么也不做，进入睡眠，必须等这个函数返回才能进行下一步动作
   * 当系统调用发现用户请求的I/O操作不能立刻完成时（比如对I/O写操作，缓冲区没有空闲空间或者空闲空间少于待写的数据量；而对于读操作，缓冲区中没有数据可读或者可读数据少于用户请求的数据量），则当前的进程会进入睡眠，也就是进程被I/O读写阻塞。但是当数据可以写出或有数据可供读入时（其他进程或线程从缓冲区中读走了数据后或者向缓冲区写入了数据），系统将会产生中断，唤醒在缓冲区上等待相应事件的进程继续执行。
2. 非阻塞IO:
   * 非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。
   * 进程在I/O操作不能完成的时侯通过系统调用立刻返回一个错误，以报告这一情况，然后进程可以根据需要在适当的时候再重新请求这个I/O操作
   * 这种对一个非阻塞I/O端口反复调用Read()进行数据读取的动作称为轮询，即应用程序持续轮询内核数据是否准备好，这将导致耗费大量的CPU时间，因此该模型并不常见。
3. 信号驱动IO:
   * 信号驱动IO:linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。
4. IO复用:
   * 对非阻塞模型进行改进，使得应用程序可以同时对多个I/O端口进行监控以判断其上的操作是否可以顺利完成，达到时间复用的目的
   * linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数
5. 异步IO:
   * linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。
   * 启用异步I/O意味着告知内核启动某个I/O操作，并让内核在整个操作（包括将数据从内核复制到用户空间的缓冲区）完成时通知我们。也就是说，信号驱动I/O是由内核通知我们何时可以启动一个I/O操作，而在异步I/O模型中，是由内核通知我们I/O操作何时完成，即实际的I/O操作也是异步的

### 常见IO多路复用模型

#### select

#### poll

#### epoll

#### select, poll, epoll的区别

* select
    1. 单个进程能够监视的文件描述符的数量存在最大限制，通常是1024。由于select采用轮询的方式扫描文件描述符，文件描述符数量越多，性能越差；
    2. 每次调用select前都要重新初始化描述符集，将fd从用户态拷贝到内核态，每次调用select后，都需要将fd从内核态拷贝到用户态； 
    3. Select返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生事件；
* poll
    1. 通过一个可变长度的数组解决了select文件描述符受限的问题
    2. 解决了select重复初始化的问题。轮寻排查的问题未解决
* epoll
    1. 只返回状态发生变化的文件描述符，便解决了轮寻的瓶颈
    2. epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的现象下降的性能问题。

### 阻塞和非阻塞I/O区别

* 阻塞表示一旦调用I/O函数必须等整个I/O完成才返回。
* 例如当服务器调用了read函数之后，如果不是立即接收到数据，服务器进程会被阻塞，之后一直在等待用户数据到达，用户数据到达后首先会写进内核缓冲区，之后内核缓冲区数据复制到用户进程（服务器进程）缓冲区。完成了上述所有的工作后，才会把执行权限返回给用户（从内核态 -> 用户态）。
* 阻塞式I/O的效率实在太低，如果用户输入数据迟迟不到的话，整个服务器就会一直被阻塞（单进程/线程）。
* 解决方法
  * 为了不影响服务器接收其他进程的连接，我们可以考虑多进程模型，这样当服务器建立连接后为连接的用户创建新线程，新线程即使是使用阻塞式I/O也仅仅是这一个线程被阻塞，不会影响服务器等待接收新的连接。
  * 多线程模型下，主线程等待用户请求，用户有请求到达时创建新线程。新线程负责具体的工作，即使是因为调用了read函数被阻塞也不会影响服务器。我们还可以进一步优化创建连接池和线程池以减小频繁调用I/O接口的开销。但新问题随之产生，每个新线程或者进程（加入使用对进程模型）都会占用大量系统资源，除此之外过多的线程和进程在调度方面开销也会大很对，所以这种模型并不适合大并发量。
* 阻塞和非阻塞最大的区别在于调用I/O系统调用后，是等整个I/O过程完成再把操作权限返回给用户还是会立即返回。
* 可以使用以下语句将句柄fd设置为非阻塞I/O：fcntl(fd, F_SETFL, O_NONBLOCK);

* 非阻塞I/O在调用后会立即返回，用户进程对返回的返回值判断以区分是否完成了I/O。如果返回大于0表示完成了数据读取，返回值即读取的字节数；返回0表示连接已经正常断开；返回-1表示错误，并设置errno为EAGAIN，接下来用户进程会不停地询问kernel是否准备完毕。
* 非阻塞I/O虽然不再会完全阻塞用户进程，但实际上由于用户进程需要不停地询问kernel是否准备完数据，所以整体效率依旧非常低，不适合做并发。

### 同步和异步区别

* 同步I/O指产生I/O操作的进程和处理I/O操作的进程是同一个。
* 异步I/O就是当用户进程发起I/O请求后立即返回，直到内核发送一个信号，告知进程I/O已完成，在整个过程中，都没有进程被阻塞，I/O操作由操作系统完成，并不由产生I/O的用户进程执行。

### Reactor和Proactor区别

* Reactor模式是同步I/O，处理I/O操作的依旧是产生I/O的程序；Proactor是异步I/O，产生I/O调用的用户进程不会等待I/O发生，具体I/O操作由操作系统完成。
* 异步I/O需要操作系统支持，Linux异步I/O为AIO，Windows为IOCP。
* Reactor
  * 应用程序注册读就需事件和相关联的事件处理器。
  * 事件分离器等待事件的发生。
  * 当发生读就需事件的时候，事件分离器调用第一步注册的事件处理器。
  * 事件处理器首先执行实际的读取操作，然后根据读取到的内容进行进一步的处理。
* Proactor
  * 应用程序初始化一个异步读取操作，然后注册相应的事件处理器，此时事件处理器不关注读取就绪事件，而是关注读取完成事件，这是区别于Reactor的关键。
  * 事件分离器等待读取操作完成事件。
  * 在事件分离器等待读取操作完成的时候，操作系统调用内核线程完成读取操作，并将读取的内容放入用户传递过来的缓存区中。这也是区别于Reactor的一点，在Proactor中，应用程序需要传递缓存区。
  * 事件分离器捕获到读取完成事件后，激活应用程序注册的事件处理器，事件处理器直接从缓存区读取数据，而不需要进行实际的读取操作。
* 从上面可以看出，Reactor和Proactor模式的主要区别就是真正的读取和写入操作是有谁来完成的，Reactor中需要应用程序（TKeed中为worker线程）自己读取或者写入数据，而Proactor模式中，应用程序不需要进行实际的读写过程，操作系统会读取缓存区或者写入缓存区到真正的IO设备。

## 并发模型理解