
- [1. HTTP基本知识](#1-http基本知识)
  - [1.1 概述](#11-概述)
  - [1.2 HTTP 特性](#12-http-特性)
  - [1.3 URI和URL](#13-uri和url)
  - [1.4 http保存用户状态](#14-http保存用户状态)
  - [1.5 web缓存器](#15-web缓存器)
- [2. HTTP报文结构](#2-http报文结构)
  - [2.1 方法](#21-方法)
  - [2.2 状态码](#22-状态码)
  - [2.3 常见字段](#23-常见字段)
  - [2.4 HTTP缓存](#24-http缓存)
- [3. HTTPS](#3-https)
  - [3.1 HTTP和HTTPS区别](#31-http和https区别)
  - [3.2 SSL/TLS协议运行机制](#32-ssltls协议运行机制)
  - [3.3 数字证书](#33-数字证书)
  - [3.4 HTTPS加密技术](#34-https加密技术)
    - [数字摘要和MD5加密](#数字摘要和md5加密)
    - [RSA 加密](#rsa-加密)
- [4. 发展历程](#4-发展历程)
  - [4.1 HTTP/0.9](#41-http09)
  - [4.2 HTTP/1.0](#42-http10)
  - [4.3 HTTP/1.1](#43-http11)
    - [长短连接优缺点对比](#长短连接优缺点对比)
  - [4.4 HTTP/2](#44-http2)
  - [4.5 HTTP/3](#45-http3)
- [5. 在浏览器地址栏输入一个URL后回车](#5-在浏览器地址栏输入一个url后回车)
- [6. 安全问题](#6-安全问题)
  - [XSS攻击](#xss攻击)
  - [CSRF攻击](#csrf攻击)

# 1. HTTP基本知识

## 1.1 概述
- HTTP协议是`Hyper Text Transfer Protocol（超文本传输协议）`的缩写
  - 基于TCP/IP协议的应用层协议 
  - 传输的内容是超文本(文字、图片、音频、视频、超链接等)
  - 一般用于从互联网服务器传输超文本到本地浏览器，但也可以在服务器之间传输

## 1.2 HTTP 特性
- 简单快速。客户向服务器请求服务时，只需传送请求方法和路径。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
- 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。  
- 无连接： 无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 
- 无状态： HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 

## 1.3 URI和URL
- URI, `Uniform Resource Identifier`, 统一资源标识符
- URL, `Uniform Resource Locator`, 统一资源定位符
- URI用字符串标识某一互联网资源，而URL表示资源的地点，URL是URI的子集
- 一个完整的URL包括以下几部分`<协议>//<域名>::[端口]/[虚拟目录]/[文件名][#锚部分][?参数部分]`
    1. 协议部分：URL的协议部分为`http:`，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等,本例中使用的是HTTP协议。在"HTTP"后面的“//”为分隔符
    2. 域名部分：一个URL中，也可以使用IP地址作为域名使用
    3. 端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口
    4. 目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”
    5. 文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名
    6. 锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分
    7. 参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。

## 1.4 http保存用户状态

- 因为Http本身是无状态的，引入cookie和session来保存状态信息
- **基于 Cookie 实现的会话保持**
  - Cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器
  - 当服务器发送响应消息时，在 HTTP 响应头中设置 Set-Cookie 字段，用来存储客户端的状态信息。客户端解析出 HTTP 响应头中的字段信息，并根据其生命周期创建不同的 Cookie，这样一来每次浏览器发送 HTTP 请求的时候都会带上 Cookie 字段，从而实现状态保持。基于 Cookie 的会话保持与基于 Session 实现的会话保持最主要的区别是前者完全将会话状态信息存储在浏览器 Cookie 中。
  - 优点：服务器不用保存状态信息， 减轻服务器存储压力，同时便于服务端做水平拓展。
  - 缺点：该方式不够安全，因为状态信息存储在客户端，这意味着不能在会话中保存机密数据。除此之外，浏览器每次发起 HTTP 请求时都需要发送额外的 Cookie 到服务器端，会占用更多带宽。
  - Cookie被禁用了怎么办
    - 只能使用 Session，并且通过重写 URL 的方式将会话标识放在 URL 的参数里（URL后面都会被附加上一个诸如sid=xxxxx这样的参数），也可以实现会话保持。
- **基于 Session 实现的会话保持**
  - 将会话状态信息存储在服务器端，更加安全
  - 在客户端第一次向服务器发送 HTTP 请求后，服务器会创建一个 Session 对象并将客户端的身份信息以键值对的形式存储下来，
  - 然后分配一个会话标识（Session Id）给客户端，这个会话标识一般保存在客户端 Cookie 中，之后每次该浏览器发送 HTTP 请求都会带上 Cookie 中的 SessionId 到服务器，服务器根据会话标识就可以将之前的状态信息与会话联系起来，从而实现会话保持。
  - 优点：
    - 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中
    - 由于大型网站往往采用的是分布式服务器，浏览器发送的 HTTP 请求一般要先通过负载均衡器才能到达具体的后台服务器，倘若同一个浏览器两次 HTTP 请求分别落在不同的服务器上时，基于 Session 的方法就不能实现会话保持了。
  - 解决方法：采用中间件，例如 Redis，我们通过将 Session 的信息存储在 Redis 中，使得每个服务器都可以访问到之前的状态信息
- **两者区别**
  - 存储的位置不同。cookie：存放在客户端，session：存放在服务端。Session存储的数据比较安全
  - 存储的数据类型不同。两者都是key-value的结构，但针对value的类型是有差异的 cookie：value只能是字符串类型，session：value是Object类型
  - 存储的数据大小限制不同 cookie：大小受浏览器的限制，很多是是4K的大小， session：理论上受当前内存的限制
  - 生命周期的控制 

## 1.5 web缓存器

- 也叫代理服务器，用于缓存web对象。用户可以配置其浏览器，使得所有HTTP请求首先指向web缓存器
- 如果web缓存器没有请求的对象，会与初始服务器直接建立一条TCP连接，web缓存器进一步发送HTTP请求，获取对象，当接收到对象后，首先在本地缓存，然后生成一个HTTP响应报文，发送给客户机（**因此，web缓存器既是客户机，又是服务器**）
- web缓存器类似于内存与处理器之间的cache，它能从整体上大大降低因特网上的web流量，从而改善所有应用的性能
- **条件GET**
  - web缓存器使用条件GET向web服务器确认某个对象是否已经被修改（不是最新的对象）。如果1)请求报文使用GET方法，2)并且包含一个If-modified-since:首部行，那么这个HTTP请求报文就是一个条件GET
  - 如果相应对象未被修改，web服务器返回一个实体为空的响应报文(也就是说并没有包含请求对象)，状态码为“304 Not Modified”

# 2. HTTP报文结构
![请求报文首部](/pic/HTTP请求报文.jpg)
```
方法+空格+URI+空格+版本+回车+换行
头部字段名+':'+字段值+回车+换行
...
头部字段名+':'+字段值+回车+换行
回车+换行
请求数据(报文主体)
```
![响应报文首部](/pic/HTTP响应报文.jpg)
```
版本+空格+状态码+空格+状态码描述+回车+换行
头部字段名+':'+字段值+回车+换行
...
头部字段名+':'+字段值+回车+换行
回车+换行
报文主体
```

## 2.1 方法
- `GET`：从服务器获取资源，请求指定的页面信息
- `POST`：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中
- `HEAD`：获取报文首部.和 GET 方法一样，但是不返回报文实体主体部分。主要用于确认 URL 的有效性以及资源更新的日期时间等。
- `PUT`：上传文件。由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般 WEB 网站不使用该方法。
- `DELETE`：删除文件.与 PUT 功能相反，并且同样不带验证机制。
- `PATCH`:对资源进行部分修改.PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改
- `OPTIONS`：查询支持的方法，查询指定的 URL 能够支持的方法。会返回 Allow: GET, POST, HEAD, OPTIONS 这样的内容。
- `TRACE`：追踪路径.服务器会将通信路径返回给客户端。
- `Connect`: 要求在与代理服务器通信时建立隧道使用， SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。

**get和post区别**  
- GET 用于获取资源，POST主要目的不是获取资源，而是传输实体主体数据
- GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL中，而 POST 的参数存储在实体主体部分。这导致：
  - get请求在url中传递的参数是有长度限制的(浏览器限制)，而post没有。 
  - get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。
  - get请求只能进行url编码，而post支持多种编码方式。 
  - get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。  
- 产生的数据包
  - 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）； 
  - 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。GET产生一个TCP数据包；POST产生两个TCP数据包。 
- 安全性和幂等性
  - GET ⽅法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。
  - POST 因为是「新增或提交数据」的操作，会修改服务器器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。

## 2.2 状态码

| 状态码 |           类别           |                描述                |
| :----: | :----------------------: | :--------------------------------: |
|  1XX   | Information,信息性状态码 |         接收的请求正在处理         |
|  2XX   |   Success，成功状态码    |        操作被成功接收并处理        |
|  3XX   | Redirection,重定向状态码 |     需要进一步的操作以完成请求     |
|  4XX   | Client Error,客户端错误  |   请求包含语法错误或无法完成请求   |
|  5XX   | Server Error, 服务器错误 | 服务器在处理请求的过程中发生了错误 |

- 1XX 提示信息
  - 100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。
- 2XX 成功
  - 200 OK,一切正常
  - 204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。
  - 206 Partial Content ：应用于HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，⽽是其中的一部分。
- 3XX 重定向(客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取)
  - 301 Moved Permanently ：永久性重定向,说明请求的资源已经不存在了，需改用新的 URL 再次访问。
  - 302 Found ：临时性重定向,说明请求的资源还在，但暂时需要用另一个 URL 来访问。
    - 301 和 302 都会在响应头里使用字段 Location ，指明后续要跳转的 URL，浏览器器会自动重定向新的URL。
  - 303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。
  - 304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。
  - 307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的POST 方法改成 GET 方法。
- 4XX 客户端错误,客户端发送的报⽂有误，服务器无法处理
  - 400 Bad Request ：请求报文中存在语法错误。
  - 401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。
  - 403 Forbidden ：请求被拒绝。服务器禁⽌访问资源
  - 404 Not Found:请求的资源在服务器上不存在或未找到，所以无法提供给客户端
- 5XX 服务器错误,客户端请求报⽂正确，但是服务器处理时内部发⽣了错误
  - 500 Internal Server Error ：服务器正在执行请求时发生错误。  
  - 501 Not Implemented：客户端请求的功能还不不⽀支持
  - 502 Bad Gateway：通常是服务器作为⽹关或代理时返回的错误码，表示服务器⾃身工作正常，访问后端服务器发⽣了错误。
  - 503 Service Unavailable：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

## 2.3 常见字段
https://blog.csdn.net/ynd_sg/article/details/82182951
- Host字段
  - 客户端发送请求时，⽤来指定服务器的域名
  - 可以将请求发往「同一台」服务器上的不同网站，为虚拟主机的兴起打下了基础
- Accept字段，客户端请求时告诉服务端自己可以接收的数据的信息
    - `Accept: */*`，客户端声明自己可以接受任何格式的数据
    - Accept-Encoding，自己可以接受哪些压缩方法。
    - Accept-Language
    - Accept-Ranges
- Content字段，出现在响应报文中，服务器告诉传输的数据的相关信息
  - Content-Length，本次回应的数据长度。
  - Content-Type，告诉客户端本次数据是什么格式
    - 值的数据类型总称为MIME type,每个值包括一级类型和二级类型，之间用斜杠分隔
    - `text/plain`,`text/html`,`image/png`,`video/mp4`等等
  - Content-Language，响应的对象的语言
  - Content-Encoding，说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式
  - Content-Range，表明该响应包含的部分对象为整个对象的哪个部分
- Connection字段
  - HTTP/1.1 版本的默认连接都是持久连接
  - close，告诉WEB服务器或者代理服务器，在完成本次请求的响应后，断开连接，不要等待本次连接的后续请求了
  - keep-alive，告诉WEB服务器或者代理服务器，在完成本次请求的响应后，保持连接，等待本次连接的后续请求
  - Keep-Alive: timeout= ，等待多少秒
- Expired
  - 服务器表明该实体将在什么时候过期，在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。对于过期了的对象，只有在跟WEB服务器验证了其有效性后，才能用来响应客户请求
- Cache-Control
  - 用来指定当前的请求/回复中是否使用缓存机制
  - 
- Authorization，身份验证
- ETag
  - 当前资源在服务器的唯一标识（生成规则由服务器决定）默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的
  - 供 WEB 服务器判断一个对象是否改变了
  - If-Match：如果对象的 ETag 没有改变，其实也就意味著对象没有改变，才执行请求的动作。
  - If-None-Match：如果对象的 ETag 改变了，其实也就意味著对象也改变了，才执行请求的动作。
  - If-Modified-Since：如果请求的对象在该头部指定的时间之后修改了，才执行请求的动作（比如返回对象），否则返回代码304，告诉浏览器 该对象没有修改。例如：If-Modified-Since：Thu, 10 Apr 2008 09:14:42 GMT
  - If-Unmodified-Since：如果请求的对象在该头部指定的时间之后没修改过，才执行请求的动作（比如返回对象）。
  - If-Range：浏览器告诉 WEB 服务器，如果我请求的对象没有改变，就把我缺少的部分给我，如果对象改变了，就把整个对象给我。浏览器通过发送请求对象的 ETag 或者 自己所知道的最后修改时间给 WEB 服务器，让其判断对象是否改变了。总是跟 Range 头部一起使用。

## 2.4 HTTP缓存



# 3. HTTPS

- HTTPs 并不是新协议，而是 HTTP 先和 SSL/TLS 通信，再由 SSL/TLS 和 TCP 通信。HTTPs 提供了加密、认证和完整性保护。

## 3.1 HTTP和HTTPS区别
- HTTP不安全
  - 通信使⽤明文（不加密），内容可能会被窃听。
  - 不验证通信方的身份，因此有可能遭遇伪装。
  - 无法证明报⽂文的完整性，所以有可能已遭篡改。
- HTTP协议和HTTPS协议区别如下： 
    1. HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，HTTPS具有更高的安全性 
       1. 窃听风险vs信息加密
       2. 篡改风险vs校验机制
       3. 冒充风险vs身份证书
    2. HTTPS在TCP三次握手阶段之后，还需要进行SSL/TSL的握手过程，协商加密使用的对称加密密钥 
    3. HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书 
    4. HTTP协议端口是80，HTTPS协议端口是443 
- HTTPS优点： 
    1. HTTPS传输数据过程中使用密钥进行加密，所以安全性更高 
    2. HTTPS协议可以认证用户和服务器，确保数据发送到正确的用户和服务器 
- HTTPS缺点： 
    1. HTTPS握手阶段延时较高：由于在进行HTTP会话之前还需要进行SSL握手，因此HTTPS协议握手阶段延时增加 
    2. HTTPS部署成本高：一方面HTTPS协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用HTTPS协议需要进行加解密的计算，占用CPU资源较多，需要的服务器配置或数目高 

## 3.2 SSL/TLS协议运行机制

- SSL(Secure Sockets Layer), TSL(Transport Layer Security)
- SSL/TSL建立过程的四次握手
  - ClientHello，客户端向服务器发起加密通信请求，向服务器发送以下信息
    - 客户端支持的 SSL/TLS 协议版本
    - 客户端支持的密码套件列表，如 RSA 加密算法。
    - 客户端生产的随机数（ Client Random ），后面用于生产对话密钥
  - SeverHello，服务器收到客户端请求后，向客户端回应以下内容
    - 确认 SSL/ TLS 协议版本，如果浏览器不⽀支持，则关闭加密通信
    - 确认的密码套件列表，如 RSA 加密算法。
    - 服务器⽣生产的随机数（Server Random），后面用于生产对话密钥
    - 服务器的数字证书
  - 客户端回应
    - 首先通过浏览器或者操作系统中的CA公钥，确认服务器的数字证书的真实性。
    - 如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：
      - 一个随机数（premaster key）。并使用数字证书中的公钥，加密这个随机数，发给服务器
      - 加密通信算法改变通知，表示随后的信息都将用对话密钥加密通信。
      - 客户端握手结束通知(是前面发送的所有内容的hash值，用来供服务器校验)，表示客户端的握手阶段已经结束
  - 服务器的最后回应
    - 收到客户端加密后的第三个随机数（premaster key）之后，用私钥解密得到其值，随后生成对话密钥
    - 加密通信算法改变通知，表示随后的信息都将⽤用对话密钥加密通信
    - 服务器器握⼿手结束通知(也是前面发送的所有内容的hash值)，表示服务器器的握⼿手阶段已经结束
- 最终的对话密钥(session key)是使用这三个随机数生成的
- SSL/TLS 的握手阶段结束后，客户端与服务器器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用对话密钥加密内容
- 注意点
  - 生成对话密钥一共需要三个随机数。
    - pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数
    - 如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适
    - 三个随机数一同生成的密钥不容易被猜出，一个伪随机可能完全不随机，可是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加
  - 握手之后的对话使用"对话密钥"加密（对称加密），服务器的公钥和私钥只用于加密和解密"对话密钥"（非对称加密），无其他作用。
  - 服务器公钥放在服务器的数字证书之中

## 3.3 数字证书

https://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html
- 权威的证书签发机构，称为CA
- 包含的内容
  - 证书的发布机构
  - 证书的有效期
  - 公钥
  - 证书所有者（Subject），这个证书是发布给谁的，一般是某个人或者某个公司名称、机构的名称、公司网站的网址
  - 签名所使用的算法，一般为RSA
  - 指纹以及指纹算法
    - 用来保证证书的完整性的，也就是说确保证书没有被修改过
    - 在发布证书时，发布者根据指纹算法(一个hash算法)计算整个证书的hash值(指纹)并和证书放在一起，使用者在打开证书时，自己也根据指纹算法计算一下证书的hash值(指纹)，如果和刚开始的值对得上，就说明证书没有被修改过
    - 这个指纹会使用CA的私钥用签名算法(Signature algorithm)加密后和证书放在一起
- 数字证书的产生
  - 用户产生了自己的密钥对，并将公共密钥及部分个人身份信息传送给一家认证中心
  - 认证中心把用户证书的基本信息做哈希算法，然后用自己的私钥对哈希值进行加密
- 验证数字证书
  - 都保存有常见CA的公钥
  - 用公钥解密数字证书
  - 解不开，证明不是CA私钥加密，无效证书
  - 解开了，证明是该CA私钥加密的，由于CA私钥只有CA知道，证书有效

证书发布机构的数字证书(一般由他自己生成)在我们的操作系统刚安装好时(例如windows xp等操作系统)，这些证书发布机构的数字证书就已经被微软(或者其它操作系统的开发机构)安装在操作系统中了，微软等公司会根据一些权威安全机构的评估选取一些信誉很好并且通过一定的安全认证的证书发布机构，把这些证书发布机构的证书默认就安装在操作系统里面了，并且设置为操作系统信任的数字证书。这些证书发布机构自己持有与他自己的数字证书对应的私钥，他会用这个私钥加密所有他发布的证书的指纹作为数字签名

## 3.4 HTTPS加密技术

1. 对称密钥加密
   - 对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。
   - 优点：运算速度快；
   - 缺点：无法安全地将密钥传输给通信方。
   - 举例：DES、3DES、RC2、RC4
2. 非对称密钥加密
   - 非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。
   - 公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。
   - 优点：可以更安全地将公开密钥传输给通信发送方；由已知的公钥几乎不可能推导出私钥
   - 缺点：运算速度慢。不适合加密大数据。主要应用于签名/校验，密钥交换
   - 举例：RSA算法，ECC（椭圆曲线）算法
3. HTTPS 采用混合的加密机制
   - 使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率
   - 在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密
   - 在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。
   - 流程
     - 客户端向服务器端发起SSL连接请求
     - 服务端把非对称加密的公开密钥发送给客户端，保存着唯一的私钥
     - 客户端自己生成对称密钥
     - 用公开密钥加密对称密钥，发送给服务端
     - 服务端用私有密钥解密，得到对称密钥
     - 随后进行的数据传输，都用对称密钥加密解密

### 数字摘要和MD5加密

- 数字摘要
  - 把可变输入长度串转换成固定长度输出串的一种函数
  - 明文的长度不固定，摘要的长度固定
  - 不可回溯
- MD5（单向散列算法）的全称是Message-Digest Algorithm 5（信息-摘要算法）
- 对等加密,不可逆
- MD5的功能：
  - 输入任意长度的信息，经过处理，输出为128位的信息（数字指纹）；
  - 不同的输入得到的不同的结果（唯一性）；
  - 根据128位的输出结果不可能反推出输入的信息（不可逆），也就是**只能加密，不能解密**； 
- MD5的用途
  - 防止被篡改：
    - 比如发送一个电子文档，发送前，我先得到MD5的输出结果a。然后在对方收到电子文档后，对方也得到一个MD5的输出结果b。如果a与b一样就代表中途未被篡改。
    - 比如我提供文件下载，为了防止不法分子在安装程序中添加木马，我可以在网站上公布由安装文件得到的MD5输出结果。
  - 防止直接看到明文：
    - 现在很多网站在数据库存储用户的密码的时候都是存储用户密码的MD5值。这样就算不法分子得到数据库的用户密码的MD5值，也无法知道用户的密码(其实这样是不安全的，后面我会提到)。
  - 防止抵赖（数字签名）
    - 这需要一个第三方认证机构。例如A写了一个文件，认证机构对此文件用MD5算法产生摘要信息并做好记录。若以后A说这文件不是他写的，权威机构只需对此文件重新产生摘要信息，然后跟记录在册的摘要信息进行比对，相同的话，就证明是A写的了。这就是所谓的“数字签名”。
- 不足
  - 容易遭受彩虹表（rainbow table, 如下）攻击！通过把大量的哈希值和原密码存储的组合存储在表中。达到用得到的hash值反向查询原密码。
  - 另外一个缺点是可以看到谁有相同的密码
- 改进
  - 哈希+salt，salt可以简单的理解成：随机产生的一定长度的，可以和密码相结合，从而使hash算法产生不同结果的字符串。
  - （哈希 + salt--盐 + Iteration--反复）通过迭代计算的方式增加计算密码的成本。迭代的周期控制在用户可以接受范围内，这样攻击者的计算和时间成本就会大大增加。
  - 加密哈希后的密码，定时更换密钥，密钥存储在在不同的数据源 
  - 将密码分成若干个块，分发到不同的数据库

### RSA 加密

- 非对等加密，可逆，用户需要设置公钥，用公钥加密，用私钥解密
- 原理
  - 其公钥和私钥是一对大素数（100到200位十进制数或更大）的函数。从一个公钥和密文恢复出明文的难度，等价于分解两个大素数之积（这是公认的数学难题）。
  - 当p和q是一个大素数的时候，从它们的积pq去分解因子p和q，这是一个公认的数学难题
```
公钥：KU包括有 n=pq,以及与(p-1)(q-1)互斥的e
私钥：KR包括有n=pq,以及d=(e^-1)mod(p-1)(q-1)
加密：C= m^e mod n
解密：m= C^d mod n
```
- 不足
  - 产生密钥很麻烦，受到素数产生技术的限制，因而难以做到一次一密。
  - 分组长度太大，为保证安全性，n 至少也要 600 bits 以上，使运算代价很高，尤其是速度较慢，较对称密码算法慢几个数量级；且随着大数分解技术的发展，这个长度还在增加，不利于数据格式的标准化
  - 使用RSA只能加密少量数据，大量的数据加密还要靠对称密码算法。


# 4. 发展历程

## 4.1 HTTP/0.9

- 1991年发布的0.9版。该版本极其简单，只有一个命令GET。
- 服务器只能回应HTML格式的字符串，不能回应别的格式
- 服务器发送完毕，就关闭TCP连接。

## 4.2 HTTP/1.0

- 1996年5月，HTTP/1.0 版本发布
- 改进
  - HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header）
  - 任何格式的内容都可以发送
  - 除了GET命令，还引入了POST命令和HEAD命令
  - 增加了状态码
- 主要缺点
  - 每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接
  - TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）

## 4.3 HTTP/1.1

- 1997年1月，HTTP/1.1 版本发布
- 新增了许多动词方法：PUT、PATCH、OPTIONS、DELETE
- 长连接(持久连接)
  - TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive
  - 减少了 TCP 连接的重复建立和断开所造成的额外开销
  - 客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接
- 管道机制
  - 在同一个TCP连接里面，客户端可以同时发送多个请求，减少整体的响应时间
  - 以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求
  - 还是按照顺序，先回应 A 请求，完成后再回应 B 请求。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为**队头堵塞**。
    - 当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据
- 分块传输编码
  - 请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成
  - 每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了
- 存在的问题
  - 请求/响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；
  - 发送冗长的首部。每次互相发送相同的首部造成的浪费较多；
  - 队头阻塞；
  - 没有请求优先级控制；
  - 请求只能从客户端开始，服务器器只能被动响应。

### 长短连接优缺点对比
- 长连接
  - 优点：可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。
  - 缺点：服务器端有很多TCP连接时，会降低服务器的性能。管理所有的TCP连接，检测是否是无用的连接（长时间没有读写事件），并进行关闭等操作。server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可 以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数
  - 适用场景： 操作频繁（读写），点对点的通讯，而且连接数不能太多情况
- 短连接
  - 优点：对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。
  - 缺点：但如果客户请求频繁，将在TCP的建立和关闭操作上浪费较多时间和带宽。
  - 适用场景：短连接用于并发量大，且每个用户无需频繁向服务器发数据包。 而像WEB网站的http服务一般都用短链接。因为长连接对于服务端来说会耗费一定的资源像，WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源。

## 4.4 HTTP/2

- 2015年，HTTP/2发布
- 二进制协议
  - HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制
  - HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"（frame）：头信息帧和数据帧。
  - 服务器收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这增加了数据传输的效率
- 头部压缩 
  - HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的
  - HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。
- 多路复⽤
  - 在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"。
  - 降低了延迟，大幅度提高了连接的利用率。
- 数据流
  - HTTP/2的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应
  - 每个请求或回应的所有数据包，称为一个数据流（ Stream ）。每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数，服务器发出的数据流编号为偶数
  - 客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应
- 服务器推送
  - HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。
  - 常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。
- 依旧存在的问题
  - 多个 HTTP 请求在复用一个 TCP 连接时，下层的 TCP 协议是不知道有多少个HTTP 请求的。所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。

## 4.5 HTTP/3

- 2018年发布
- 把HTTP下层的TCP协议改成了UDP
  - HTTP/1.1 中的管道(pipeline)传输中如果有一个请求阻塞了，那么队列后的请求也统统被阻塞住了
  - HTTP/2 多个请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。
  - UDP是不管顺序，也不管丢包的，所以不会出现 HTTP/1.1 的队头阻塞 和 HTTP/2 的一个丢包全部重传问题。
- QUIC（Quick UDP Internet Connections）快速 UDP 网络连接
  - 可以实现类似 TCP 的可靠性传输，在 UDP 之上的伪 TCP + TLS + HTTP/2 的多路路复⽤用的协议
  - QUIC 有自己的一套机制，可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响
  - TLS3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack 。
  - 直接把TCP的和TLS的合并成了三次握手

# 5. 在浏览器地址栏输入一个URL后回车

1. 浏览器解析这个url
   - 确定协议是http还是https（HTTP 默认端口号是 80， HTTPS 默认端口号是 443）
   - 获得域名 
   - 获得目录名，文件名，参数
2. 生成http的请求报文
3. 查询服务器域名对应的IP地址，DNS
4. 获得IP地址后开始三次握手建立TCP连接
5. 如果协议是https，还会进行SSl/TSL的四次握手
6. 连接完成后，浏览器将http请求消息发送给服务端
   - 如果 HTTP 请求消息比较长，超过了 MSS 的长度，这时 TCP 就需要把 HTTP 的数据拆解一块块的数据发送，而不是一次性发送所有数据。
   - 每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据
   - 再加上IP头部
   - 再加上MAC头部，获取目的MAC地址需要ARP协议
7. 服务器收到数据，不断删除头部，最后将http请求报文发送给http进程
8. 服务器发送HTTP响应报文
9. 客户端收到响应报文后，交给浏览器渲染页面

# 6. 安全问题

## XSS攻击

- 是Cross Site Scripting（跨站脚本）
- 
## CSRF攻击

- Cross-site request forgery, 跨站请求伪造。是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起跨站请求
  - 攻击者盗用了你的身份，以你的名义向第三方网站发送恶意请求。 CRSF能做的事情包括利用你的身份发邮件、发短信、进行交易转账等，甚至盗取你的账号。
- 攻击原理
  - 首先用户C浏览并登录了受信任站点A；
  - 登录信息验证通过以后，站点A会在返回给浏览器的信息中带上已登录的cookie，cookie信息会在浏览器端保存一定时间（根据服务端设置而定）；
  - 完成这一步以后，用户在没有登出（清除站点A的cookie）站点A的情况下，访问恶意站点B；
  - 这时恶意站点 B的某个页面向站点A发起请求，而这个请求会带上浏览器端所保存的站点A的cookie；
  - 站点A根据请求所带的cookie，判断此请求为用户C所发送的。