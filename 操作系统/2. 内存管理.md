内存管理

----------------------------------------
- [](#)
- [1. 内存管理的需求](#1-内存管理的需求)
  - [连续分配存储管理方式](#连续分配存储管理方式)
      - [单一连续存储管理](#单一连续存储管理)
      - [分区式存储管理](#分区式存储管理)
    - [覆盖和交换技术](#覆盖和交换技术)
  - [页式和段式存储管理](#页式和段式存储管理)
    - [页式存储管理](#页式存储管理)
    - [段式存储管理](#段式存储管理)
    - [段页式存储管理](#段页式存储管理)
    - [段页式管理每一次数据要访问几次内存?](#段页式管理每一次数据要访问几次内存)
    - [页和段的区别](#页和段的区别)
    - [虚拟内存与物理内存](#虚拟内存与物理内存)
    - [分页系统地址映射](#分页系统地址映射)
    - [虚拟内存的好处和代价](#虚拟内存的好处和代价)
    - [缺页置换方法](#缺页置换方法)
    - [LRU的实现](#lru的实现)
    - [内存溢出和内存泄漏](#内存溢出和内存泄漏)
[参考资料](https://blog.csdn.net/XD_hebuters/article/details/79519406)

# 1. 内存管理的需求

1. 重定位
   * 进程多次在内存切入切出，放置于不同位置能力 
   * 一旦程序被换出到磁盘，当下一次换入时，如果必须放在和被换出前相同的内存区域，那么这将会是很大的限制。为了避免这种限制，需要把进程重定位到内存的不同区域。 
2. 保护
   * 保护进程的程序和数据不被未授权的进程访问和修改
   * 内存保护的需求必须有处理器硬件来满足，而不是操作系统（软件）来满足。这是因为操作系统不能够预测程序可能产生的所有的内存访问;即使可以预测，提前审查每个进程可能潜在的违法访问也是非常费时的，因此，只能在指令访问内存时来判断这个内存访问是否违法(存取数据或跳转)。为实现这一点，要求处理器有这个能力。 
3. 共享
   * 多个进程访问内存同一区域 
   * 如果多个进程在执行同一个程序，则允许每个进程访问该程序的同一个副本比每个进程都有自己的单独的副本更有优势
4. 逻辑组织
   * 把线性的地址空间组织成不同的模块
   * 可以独立编写和编译模块，系统在运行时解析一个模块到其他模块的所有引用。 
   * 通过适度的额外开销，可以给不同的模块以不同的保护级别（只读、只执行）。 
   * 可以引入某种机制，使得模块被多个进程共享。
5. 物理组织
   * 两级存储
   。内存提供快速的访问，成本高，并且内存是易失性的，不能提供永久存储。用于保存当前使用的程序或数据
   * 外存比内存慢且便宜，通常为非易失性的，用于长期存储程序和数据
   * 需要管理内存和磁盘间的信息流动


##  连续分配存储管理方式
连续分配是指为一个用户程序分配连续的内存空间。
#### 单一连续存储管理
* 整个内存里面只有两个程序：一个是用户程序，另外一个是操作系统。
* 应用程序装入到用户区，可使用用户区全部空间，并且总是加载到同一个内存地址上。即用户程序永远从同一个地方开始执行。
* 优点：管理非常简单，实际上不需要任何的内存管理单元，程序运行速度快，因为越过了地址翻译这个步骤
* 缺点：
   * 整个程序要加载到内存空间中去，这样将导致比物理内存大的程序无法运行。
   * 只运行一个程序造成资源浪费，如果一个程序很小，虽然占用内存空间小，但剩下的内存空间也无法使用
   * 可能无法在不同的操作系统下运行，因为不同操作系统所占用的内存空间大小可能不一样，使得用户程序的起始地址可能不一样

#### 分区式存储管理
* 把内存分为一些大小相等或不等的分区，操作系统占用其中一个分区，其余的分区由应用程序使用，每个应用程序占用一个或几个分区
* 可以支持并发，但难以进行内存分区的共享。
* 内碎片是占用分区内未被利用的空间
* 外碎片是占用分区之间难以利用的空闲分区(通常是小空闲分区)。
* 为实现分区式存储管理，操作系统应维护的数据结构为分区表或分区链表。表中各表项一般包括每个分区的起始地址、大小及状态(是否已分配)。
* 固定分区(nxedpartitioning)
   * 把内存划分为若干个固定大小的连续分区。
   * 分区大小可以相等：这种作法只适合于多个相同程序的并发执行(处理多个类型相同的对象)。
   * 分区大小也可以不等：有多个小分区、适量的中等分区以及少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。
   * 优点：易于实现，开销小。
   * 缺点主要有两个：内碎片造成浪费；分区总数固定，限制了并发执行的程序数目。
* 动态分区(dynamic partitioning)
   * 动态创建分区：在装入程序时按其初始要求分配，或在其执行过程中通过系统调用进行分配或改变分区大小
   * 没有内碎片。但它却引入了另一种碎片——外碎片。
   * 寻找某个空闲分区，其大小需大于或等于程序的要求。若是大于要求，则将该分区分割成两个分区，其中一个分区为要求的大小并标记为“占用”，而另一个分区为余下部分并标记为“空闲”。分区释放过程中会将相邻的空闲分区合并成一个大的空闲分区
   * 常用的分区分配算法
      * 最先适配法(first-fit)：按分区在内存的先后次序从头查找，找到符合要求的第一个分区进行分配。该算法的分配和释放的时间性能较好，较大的空闲分区可以被保留在内存高端。但随着低端分区不断划分会产生较多小分区，每次分配时查找时间开销便会增大。
      * 下次适配法(循环首次适应算法 next fit)：按分区在内存的先后次序，从上次分配的分区起查找(到最后一个分区时再从头开始}，找到符合要求的第一个分区进行分配。该算法的分配和释放的时间性能较好，使空闲分区分布得更均匀，但较大空闲分区不易保留。
      * 最佳适配法(best-fit)：按分区在内存的先后次序从头查找，找到其大小与要求相差最小的空闲分区进行分配。从个别来看，外碎片较小；但从整体来看，会形成较多外碎片。优点是较大的空闲分区可以被保留。
      * 最坏适配法(worst- fit)：按分区在内存的先后次序从头查找，找到最大的空闲分区进行分配。基本不留下小空闲分区，不易形成外碎片。但由于较大的空闲分区不被保留，当对内存需求较大的进程需要运行时，其要求不易被满足。
* 伙伴系统
   *  固定分区和动态分区方式都有不足之处。
      * 固定分区方式限制了活动进程的数目，当进程大小与空闲分区大小不匹配时，内存空间利用率很低。
      * 动态分区方式算法复杂，回收空闲分区时需要进行分区合并等，系统开销较大。
      * 伙伴系统方式是对以上两种内存方式的一种折衷方案
   * 无论已分配分区或空闲分区，其大小均为 2 的 k 次幂，k 为整数， l≤k≤m，其中：
      * 2^l 表示分配的最小分区的大小，
      * 2^m 表示分配的最大分区的大小，2^m是整个可分配内存的大小。
   * 在系统运行过中，由于不断的划分，可能会形成若干个不连续的空闲分区，将这些空闲分区根据分区的大小进行分类，对于每一类具有相同大小的所有空闲分区，单独设立一个空闲分区双向链表。这样，不同大小的空闲分区形成了k(0≤k≤m)个空闲分区链表。  
   * 分配步骤
      * 当需要为进程分配一个长度为n 的存储空间时: 首先计算一个i 值，使 2^(i－1) < n ≤ 2^i，
      * 然后在空闲分区大小为2^i的空闲分区链表中查找。
      * 若找到，即把该空闲分区分配给进程。否则，表明长度为2^i的空闲分区已经耗尽，则在分区大小为2^(i＋1)的空闲分区链表中寻找。
      * 若存在 2^(i＋1)的一个空闲分区，则把该空闲分区分为相等的两个分区，这两个分区称为一对伙伴，其中的一个分区用于配，而把另一个加入分区大小为2^i的空闲分区链表中.若仍然找不到，则继续查找大小为 2^(i＋2)的空闲分区，以此类推。
   * 与一次分配可能要进行多次分割一样，一次回收也可能要进行多次合并，
* 内存紧缩
   * 将各个占用分区向内存一端移动，然后将各个空闲分区合并成为一个空闲分区。
   * 紧缩时机：每个分区释放后，或内存分配找不到满足条件的空闲分区时

### 覆盖和交换技术
* 覆盖
   * 引入覆盖 (overlay)技术的目标是在较小的可用内存中运行较大的程序。这种技术常用于多道程序系统之中，与分区式存储管理配合使用
   * 原理
      * 一个程序的几个代码段或数据段，按照时间先后来占用公共的内存空间。
      * 将程序必要部分(常用功能)的代码和数据常驻内存；
      * 可选部分(不常用功能)平时存放在外存(覆盖文件)中，在需要时才装入内存。不存在调用关系的模块不必同时装入到内存，从而可以相互覆盖。
      * 在任何时候只在内存中保留所需的指令和数据；当需要其它指令时，它们会装入到刚刚不再需要的指令所占用的内存空间；
   * 缺点是编程时必须划分程序模块和确定程序模块之间的覆盖关系，增加编程复杂度；从外存装入覆盖文件，以时间延长换取空间节省
* 交换
   * 在多个程序并发执行时，可以将暂时不能执行的程序（进程）送到外存中，从而获得空闲内存空间来装入新程序（进程），或读人保存在外存中而处于就绪状态的程
   * 交换单位为整个进程的地址空间
   * 交换技术优点之一是增加并发运行的程序数目，并给用户提供适当的响应时间；与覆盖技术相比交换技术另一个显著的优点是不影响程序结构。
   * 对换人和换出的控制增加处理器开销；程序整个地址空间都进行对换，没有考虑执行过程中地址访问的统计特性。
* 两者对比
   * 与覆盖技术相比，交换不要求程序员给出程序段之间的覆盖结构。
   * 交换主要是在进程与作业之间进行，而覆盖则主要在同一作业或进程内进行。 另外覆盖只能覆盖那些与覆盖程序段无关的程序段。

## 页式和段式存储管理
* 如果允许将一个进程分散到许多不连续的空间，就可以避免内存紧缩，减少碎片。基于这一思想，通过引入进程的逻辑地址，把进程地址空间与实际存储空间分离，增加存储管理的灵活性。
* 地址空间：将源程序经过编译后得到的目标程序，存在于它所限定的地址范围内，这个范围称为地址空间。地址空间是逻辑地址的集合。
* 存储空间：指主存中一系列存储信息的物理单元的集合，这些单元的编号称为物理地址。存储空间是物理地址的集合。
* 根据分配时所采用的基本单位不同，可将离散分配的管理方式分为以下三种：页式存储管理、段式存储管理和段页式存储管理。其中段页式存储管理是前两种结合的产物。

### 页式存储管理
* 将程序的逻辑地址空间划分为固定大小的页(page)，而物理内存划分为同样大小的页框(page frame)。程序加载时，可将任意一页放入内存中任意一个页框，这些页框不必连续，从而实现了离散分配
* 需要CPU的硬件支持(内存管理单元（MMU）)，来实现逻辑地址和物理地址之间的映射。在页式存储管理方式中地址结构由两部构成，前一部分是页号，后一部分为页内地址w（位移量）

### 段式存储管理
段式存储管理要求每个作业的地址空间按照程序自身的逻辑划分为若干段，每个段都有一个唯一的内部段号。
逻辑地址由段号S与段内偏移量W两部分组成。
### 段页式存储管理
在段页式存储中，每个分段又被分成若干个固定大小的页。
逻辑地址由段号S、段内页号P与页内偏移量W两部分组成。
[1](https://blog.csdn.net/guoweimelon/article/details/50853719)
[2](https://blog.csdn.net/hguisu/article/details/5713164)

### 段页式管理每一次数据要访问几次内存? 
三次
第一次是由段表地址寄存器得段表始址后访问段表，由此取出对应段的页表在内存中的地址。 第二次则是访问页表得到所要访问的物理地址。 第三次才能访问真正需要访问的物理单元。




### 页和段的区别

1. 页是信息的物理单位，分页是由于系统管理的需要。段是信息的逻辑单位，分段是为了满足用户的要求。
2. 页的大小固定且由系统决定，段的长度不固定，决定于用户所编写的程序，通常由编译程序在对源程序紧进行编译时，根据信息的性质来划分。
3. 分页的作业的地址空间是一维的，程序员只需要利用一个记忆符，即可表示一个地址。分段的作业地址空间则是二维的，程序员在标识一个地址时，既需要给出段名，又需要给出段的地址值。


























### 虚拟内存与物理内存
* 虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。
* 为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。
* 从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。

### 分页系统地址映射
* 内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。
* 一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。

### 虚拟内存的好处和代价
* 好处
   1.扩大地址空间； 
   2.内存保护：每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。虚存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改。 
   3.公平内存分配。采用了虚存之后，每个进程都相当于有同样大小的虚存空间。 
   4.当进程通信时，可采用虚存共享的方式实现。 
   5.当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存 
   6.虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。在内存中可以保留多个进程，系统并发度提高 
   7.在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片 
* 代价 
   1.虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存 
   2.虚拟地址到物理地址的转换，增加了指令的执行时间。 
   3.页面的换入换出需要磁盘I/O，这是很耗时的 
   4.如果一页中只有一部分数据，会浪费内存。 

### 缺页置换方法
当访问一个内存中不存在的页，并且内存已满，则需要从内存中调出一个页或将数据送至磁盘对换区，替换一个页，这种现象叫做缺页置换。

1. 最优算法
   - 
* 先进先出(FIFO)算法：
   * 置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。
   * 按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。 
* LFU（最不经常访问淘汰算法） 
   * 如果数据过去被访问多次，那么将来被访问的频率也更高。 
   * 每个数据块一个引用计数，所有数据块按照引用计数排序，具有相同引用计数的数据块则按照时间排序。每次淘汰队尾数据块
* 最近最少使用（LRU）算法
   * 置换最近一段时间以来最长时间未访问过的页面。
   * 根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。 
   * 缓存颠簸，当缓存（1，2，3）满了，之后数据访问（0，3，2，1，0，3，2，1。。。）。 
   * 缓存污染，突然大量偶发性的数据访问，会让内存中存放大量冷数据。 
* LRU-K（LRU-2、LRU-3） 
   * 最久未使用K次淘汰算法。
   * LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。 


### LRU的实现
利用链表和hashmap。当需要插入新的数据项的时候，如果新数据命中，则把该节点放到链表头部，如果不存在，则将新数据放在链表头部。若缓存满了，则将链表尾部的节点删除。


### 内存溢出和内存泄漏
* 内存溢出 
   * 指程序申请内存时，没有足够的内存供申请者使用。内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误 
   * 内存溢出原因： 
      * 内存中加载的数据量过于庞大，如一次从数据库取出过多数据 
      * 集合类中有对对象的引用，使用完后未清空，使得不能回收 
      * 代码中存在死循环或循环产生过多重复的对象实体 
      * 使用的第三方软件中的BUG 
      * 启动参数内存值设定的过小 
* 内存泄漏 
   * 内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。  
   * 堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。 
   * 系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。
   * 没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。 