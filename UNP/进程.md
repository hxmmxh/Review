# 进程环境

## 进程终止方式

* 有8种方式可导致进程终止，其中5种为正常终止，分别为  
  1. 从main返回，执行return，等效于调用exit
  2. 调用exit，调用各终止处理程序，然后关闭所有标准IO流
  3. 调用_exit或_Exit，直接终止，不运行终止处理程序，也不冲洗标准IO流
  4. 最后一个线程从其启动例程返回
  5. 从最后一个现场调用pthread_exit
* 还有3种为异常终止，分别为  
  1. 调用abort，产生SIGABRT信号  
  2. 接到一个信号，信号可由进程自身，其他进程或内核产生  
  3. 最后一个线程对取消请求做出响应，详细说明见  

### 3个exit函数

```c
#include <stdlib.h>
void exit(int status);
void _Exit(int status);
#include <unistd.h>
void _exit(int status);
status是程序终止状态
在shell中用echo $? 查看程序终止状态

```

* _exit和_Exit不执行标准IO的缓冲区冲洗操作
* exit会冲洗缓冲区，并关闭IO流
* 子进程可通过传入退出状态通知其父进程它是如何终止的，父进程可用wait和waitpid获得子进程的退出状态

```c
#include <stdlib.h>
int atexit(void (*func)(void));
成功返回0，出错返回非0
登记函数的终止处理程序，参数是函数指针，参数类型和返回类型都是void
进程调用exit后，exit会先调用这些终止处理程序，调用的顺序和登记时候的顺序相反，随后关闭所有的打开流。
调用了_exit或_Exit后会清除所有已安装的终止处理程序
```

## 命令行参数和环境表

```c
int main(int argc, char** argv);
extern char **environ;
其中argc是命令行参数的数目，argv是指向参数的各个指针构成的数组
environ是环境指针，指向环境表，环境表是一个字符指针数组，每个指针包含一个以null结束的C字符串地址，
```

环境字符串的形式通常为： name=value  

```c
#include <stdlib.h>
char* getenv(const char *name);
成功则返回指向与name关联的value的指针，指向的是name=value字符串中的value
未找到则返回NULL
int putenv(char *str);
将形式为name=value的字符串放到环境表中，如果name已存在，则先删除其原来的定义
成功返回0，出错返回非0值
int setenv(const char* name, const char *value, int rewrite);
将name设成value，如果在环境中name已存在，rewrite非0是会先删除其现有的定义，rewrite为0则不删除也不覆盖也不出错
int unsetenv(const char *name);
删除name的定义，即使不存在也不算出错
成功返回0，出错返回-1
```

* 可以更改当前环境和后面生成的子进程的环境，不能影响父进程的环境
putenv不会分配存储空间，而setenv会，如果将存放在栈中的字符串作为参数传递给putenv，可能会发生错误，因为函数返回时其栈占用的存储区可能将被重用  
环境表占用的空间在进程地址空间的顶部，无法向高地址扩展，同时也不能移动在它之下的栈，所以也无法向低地址扩展。因此该空间的长度无法增加，这就导致：  
如果修改一个现有的name,新value的长度大于原长度时，必须调用malloc为新字符串分配空间，将新字符串复制到该空间中，并使环境表种对name的指针指向新分配去。
如果新增加一个name时。首先必须调用malloc为name=value字符串分配空间，将该字符串复制到此空间中，随后
如果是第一次增加一个新name，还需要调用malloc为新的指针表分配空间，接着将原来的环境表复制到新分配区，并将指向新name=value字符串的指针存放在新指针表的表尾，然后将一个空指针存放在其后，最后使environ指向新指针表。
如果不是第一次增加一个新的name，只用调用realloc多分配一个指针的空间。

## C程序的存储空间布局

![内存管理](pic/C++内存模型.png)
从低地址往高地址分别为：

* text segment(代码段):包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。
* data segment(数据段)：存储程序中已初始化的非0全局变量和静态变量
* bss segment：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0。这个段其实并不占用物理空间。
* heap（堆）： 当进程未调用malloc时是没有堆段的，只有调用malloc时采用分配一个堆，并且在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。分配小内存时使用该区域。  堆的起始地址由mm_struct 结构体中的start_brk标识，结束地址由brk标识。
* memory mapping segment(映射区):存储动态链接库等文件映射、申请大内存（malloc时调用mmap函数）
* stack（栈）：使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。在创建进程时会有一个最大栈大小，Linux可以通过ulimit命令指定。
* 存放命令行参数和环境变量

## malloc相关函数

```c
#include <stdlib.h>
void* malloc(size_t size);
分配指定字节数的存储区，初始值不确定
void* calloc(size_t nobj, size_t size);
为指定数量指定长度的对象分配存储空间，每一位会被初始化为0
void* realloc(void *ptr, size_t newsize);
增加或减少以前分配区的长度。如果增加了长度，新增区域的初始值是不确定的
成功返回非空指针，失败返回Null
void free(void *ptr);
释放ptr指向的存储空间

返回的指针是对齐的
```

## setjmp和longjmp

goto语句不能跨越函数，实行跨越函数的跳转需要用setjmp和longjmp，能有效处理发生在深层嵌套函数调用中的出错情况

```c
#include <setjmp.h>
int setjmp(jmp_buf env);
若直接调用返回0，若从longjmp返回，则为非0。
void longjmp(jmp_buf env, int val);
val指定setjmp返回的值

jmp_buf数据类型是某种形式的数组，其中存放着调用longjmp时能用来恢复栈状态的所有信息，因为需要在另一个函数中引用env，所以通常将env变量定义为全局变量
```






# 进程控制

## 进程标志

* 每个进程都有一个非负整型表示的唯一进程ID
* 系统中保留的ID值：
  * 0：调度进程，也被称为交换进程，并不执行磁盘上的程序，是内核中的系统进程
  * 1：init进程，在自举过程结束后由内核调用，该进程的程序文件在unix早期版本中是/etc/init，在较新版本中是/sbin/init，负责在自举内核后启动Unix系统。进行系统的初始化，将系统引导到一个状态，该进程绝不会终止，是一个普通的用户进程，但是以超级用户特权运行，是所有孤儿进程的父进程
* 获取进程标识符的函数(实际和有效用户ID的说明见)

```c
#include <unistd.h>
pid_t getpid(void);  进程ID
pid_t getppid(void); 父进程ID
uid_t getuid(void);  实际用户ID
uid_t geteuid(void); 有效用户ID
gid_t getgid(void);  实际组ID
gid_t getegid(void); 有效组ID
```

### 更改用户ID和更改组ID

* 特权以及访问控制是基于用户ID和组ID的，当程序需要增加特权或者需要访问当前并不允许访问的资源时，需要更换自己的用户ID或组ID,使新ID具有合适的特权或访问权限
* 最小特权模型：程序应该只具有为完成给定任务所需的最小特权

```c
#include <unistd.h>
int setuid(uid_t uid); 设置用户ID
int setgid(gid_t gid); 设置组ID
成功返回0，失败返回-1
```

* 若进程拥有超级用户特权，则setuid函数将实际用户ID,有效用户ID以及保存的设置用户ID设置为uid
* 若进程没有超级用户特权，但是uid等于实际用户ID或保存的设置用户ID,则setuid只能将有效用户ID设置为uid，不更改实际用户ID和保存的设置用户ID
* 若上述两个条件都不满足，则出错返回-1，并将errno设置为EPERM













## 创建进程

### fork函数

```c
#include <unistd.h>
pid_t fork(void);
子进程返回0,父进程返回子进程ID,出错返回-1
```

* 由fork创建的新进程被称为子进程，fork函数被调用一次但是返回两次
* 子进程和父进程继续执行fork调用后的指令，但是谁先执行是不确定的，控制子进程和父进程之间的同步关系见
* 子进程获得父进程的数据段、栈和堆的完全副本。现在都使用写时复制技术。一开始这些区域由子进程和父进程共享，只有其中任意一个试图修改这些区域时，才会真正的复制出一个副本
* fork会使父进程的所有打开的文件描述符都被复制到子进程，父进程和子进程每个相同的打开描述符共享一个文件表项，也即共享文件偏移量，文件状态位置和节点指针。这就导致如果子进程和父进程同时写同一描述符指向的文件，如果没有确定形式的同步，输出是会相互混合的。常见处理方式是：
  * 父进程等待子进程完成后再运行
  * 父进程和子进程各自执行不同的程序段
* fork与标准IO函数。如果在fork前，有数据写到缓冲区且并未冲洗，fork之后子进程和父进程都会写入该数据一次。
* 父进程和子进程相同的属性
* 父进程和子进程不同的属性
* 父进程在子进程之前终止，子进程的父进程会被改变为init进程。操作过程是：在一个进程终止时，内核逐个检查所有的活动进程，判断它是否是正要终止进程的子进程，如果是，就将该进程的父进程ID改为1，保证每个进程都有一个父进程
* 子进程在父进程之前终止，内核会为每个终止子进程保存一定量的信息，当其父进程调用wait或waitpid时，可以获得这些信息，包括进程ID,进程的终止状态以及该进程使用的CPU时间总量。一个已经终止，但父进程尚未对其进行梳理的进程被称为僵死进程，ps命令将僵死进程的状态打印为Z
* init进程收养的进程不会变成僵死进程，init无论何时只要有一个子进程终止，就会调用一个wait函数取得其终止状态

### vfork函数

* 不建议在可移植的应用程序中使用这个函数
* 目的是用于创建一个新进程，而该新进程的目的是exec一个新程序
* 和fork区别
  * vfork并不复制父进程的地址空间，因为认为子进程会立即调用exec，因此在子进程调用exec之前，它在父进程的空间中运行，如果这时子进程修改数据、进行函数调用等会造成未知的后果
  * vfork会包值子进程先运行，当子进程调用exec或exit后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖父进程的进一步动作，会导致死锁。

### wait和waitpid

* 当一个进程终止时，内核会向其父进程发送SIGCHLD信号。父进程可以忽略该信号，也可以提供一个信号处理程序。系统的默认动作的忽略它。

```c
#include <sys/wait.h>
pid_t wait (int *stat)；
pid_t waitpid(pid_t pid, int *stat, int option);
成功返回进程ID,出错返回0或-1
```

* 终止进程的终止状态存放在stat指向的地址中，如果不关心终止状态，可以将stat指定为空指针，可用宏来判断stat来得到进程终止的原因
  * WIFEXITED(stat),若为正常终止，则为真，并可以用WEXITSTATUS(stat)或的子进程传递给exit参数的低8位
  * WIFSIGNALED(stat)，若为异常终止，则为真，并可用WTERMSIG(stat)获得使子进程终止的信号编号
  * WCOREDUMP(stat),若产生了core文件，则为真
  * WIFSTOPPED(stat)，若为当前暂停子进程的返回状态，则为真,并可用WSTOPSIG(stat)获得使子进程暂停的信号编号
  * WIFCONTINUED(stat)，若为在作业控制暂停后已经继续进程的子进程返回了状态，则为真
* waitpid中pid的取值
  * pid==-1，等待任一子进程，等同于wait
  * pid>0，等待进程ID与pid相等的子进程
  * pid==0，等待组ID等于调用进程组ID的任一子进程
  * pid<-1，等待组ID等于pid绝对值的任一子进程
* option的取值为0，或一下常量按位或运算的结果
  * WCONTINUED
  * WNOHANG, 当由Pid指定的子进程并不是立即可用时，不阻塞，直接返回0
  * WUNTRACED
* 调用这两个函数可能出现的状态
  * 如果其所有子进程都还在运行，则阻塞
  * 如果有一个子进程已终止，则取得该子进程的终止状态后返回
  * 如果没有任何子进程，则立即出错返回

### 其他wait函数

```c
```

### exec函数

* 用fork创建新进程，用exec函数执行新的程序，用exit和wait处理终止和等待终止
* 调用exec函数后，进程执行的程序被完全替换成新程序，并从其main函数开始执行
* 并不是创建新进程，所以前后的进程ID并未改变，只是用一个新程序替换了当前进程的正文段，数据段，堆和栈

```c
#include <unistd.h>
int execl(const char *pathname, const char *arg0, ..., (char *)0);
int execv(const char *pathname, char * const argv[]);
int execle(const char* pathname,const char *arg0, ..., (char *)0, char* const envp[]);
int execve(const char *pathname, char * const argv[],char* const envp[]);
int execlp(const char *filename,const char *arg0, ..., (char *)0);
int execvp(const char *filename, char *const argv[]);
int fexecve(int fd, char *const argv[], char *const envp[]);
出错返回-1，成功不返回
```

* 共有7种函数，前4个取路径名为参数，后两个取文件名作为参数，最后一个取文件描述符作为参数
* 用文件名作为参数时：
  * 如果filename种包含/，就将其视为路径名
  * 否则就按PATH环境变量，在它所指定的各目录中搜寻指定的可执行文件
* l表示List, execl, execlp和execle，要求将新程序的每个命令行参数都说明为一个单独的参数，并以空指针结尾
* v表示vector,execv,execvp,execve,execve则应先构造一个指向各参数的指针驻足，然后将该数组地址作为这四个函数的参数
* e表示环境表，以e结尾的execve,execle,fexecve可以传递一个指向环境字符串指针数组的指针。其他4个函数则使用调用进程中的environ变量为新程序复制现有的环境





## 进程之间的竞争









# 进程关系

# 守护进程


# 进程间通信

