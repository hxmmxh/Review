

# 0. 概述

# 1. 初步认知

- 模板定义中模板参数列表不能为空
- 调用函数模板时通常用函数实参来推断模板实参
- inline 和constexpr说明符放在模板参数列表之后，返回类型之前

## 1.1 非类型模板参数
- 表示一个值而非一个类型
- 通过一个特定的类型名而非typename指定
- 被实例化时被一个用户提供的或编译器推断出的值所替代，这些值必须是常量表达式，因为需要在编译时就实例化
  - 整型
  - 指向对象或函数类型的指针或引用，且具有静态的生存期
```cpp
template<int N, int M>
int compare(const char (&p1)[N],const char(&p2)[M])
{
    ......
}
```

## 1.2 模板的编译

- 当编译器遇到一个模板定义时，它并不生成代码
- 只有当我们实例化出模板的一个特定版本时，编译器才会生成代码，当我们使用模板时（而不是定义），编译器才生成代码
- 类和函数
  - 调用一个函数时，编译器只需要掌握函数的声明
  - 使用一个类类型的对象时，类定义必须可用，但成员函数的定义不必出现
  - 类定义和函数声明放在头文件中，普通函数和类的成员函数的定义放在源文件中
- 模板
  - 为了实例化一个模板，需要掌握函数模板或类模板成员函数的定义
  - 函数模板和类模板成员函数的定义通常放在头文件中
- 模板出现错误的三个阶段
  - 编译模板本身时，出现语法错误
  - 编译器遇到模板使用时，检查提供的模板实参是否正确
  - 模板实例化时

# 1.3 类模板

- 编译器不能为类模板推断模板参数类型，必须在模板名后的尖括号中提供额外信息
- 一个类模板的每个实例都形成一个独立的类
- 定义在类模板之外的成员函数必须以关键字template开始，后接类模板参数列表
- 一个类模板的成员函数只有当程序用到它时才进行实例化，如果一个函数没有被使用，则它不会被实例化
  - 因此即使某些类型不能完全复合模板操作的要求，也能用该类型实例化类
- 在类模板自己的作用域中，可以直接使用模板名而不提供实参
- 但是在类外，只有遇到了类名才表示进入的类的作用域（返回类型需要提供实参）
- 类模板的每个实例都有一个独有的static对象
```cpp
template <typename T>
class A
{
    A();
    A& operator++ ();
};

template <typename T>
A<T>::A()
{}

template <typename T>
A<T>& A<T>::operator++()
{}
```
- **类模板和友元**
  - 如果一个类模板包含一个非模板友元，则友元被授予可以访问所有模板示例
  - 如果都是模板
    - 一对一友好关系,限定在相同类型实例化的类和函数之间（需要友元的前置声明）
    - 也可以将另一个模板的每个实例声明为自己的友元(不需要友元的前置声明)
```cpp
template <typename T> class A; // 需要前置声明
template <typename T> class B;
template <typename T>
bool com(const B<T> &, const B<T> &);

template <typename T>
class B
{
    // 一对一
    friend class A<T>;
    friend class bool com<T>(const B<T> &, const B<T> &);
    // 每个实例都是友元，不需要前置声明
    template <typename X>
    friend class C;
}
```
- **模板类型别名**
```cpp
template <typename T> using twin=pair<T，T>;
twin<int> a;//等于pair<int,int>
twin<string> b;//等于pair<string,string>
// 也可以固定一个或多个模板参数
template <typename T> using twinNo= pair<T,int>;
```
- **使用类的类型成员**
  - 通过作用域运算符（::）可用来访问类的static成员和类型成员
  - 普通类：编译器掌握了类的定义，可以分辨出是static成员还是类型
  - 模板：只有实例化才能知道，所以`T::size_type *p`有两种解释
    - 定义一个类型为size_type的变量p
    - 名为size_type的static成员乘以p
  - `typename T::size_type`显式告诉编译器它是类型
- **默认模板实参**
  - 可以为类和函数模板提供
  - 只有当它右侧的所有参数都有默认实参时，才可以有默认实参
  - 无论何时使用类模板，都要在模板名后加尖括号。
    - 即使用默认实参，可要一个空的尖括号
- **成员模板**
  - 一个类（普通类，类模板都行）都可以包含自身时模板的成员函数
  - 不能是虚函数
  - 在类模板外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表，类模板的参数列表在前，后跟成员函数自己的模板参数列表
- **控制实例化**
  - 模板被使用时才会进行实例化，所以相同的实例可能出现在多个对象文件中，造成额外开销
  - 实例化声明`extern template declaration`
    - 不会在本文件中生成实例化代码
    - 在程序其他位置有该实例化的一个定义
    - 必须出现在任何使用此实例化版本的代码之前
  - 实例化定义`template declaration`
  - declaration是一个类或函数声明，其中所有的模板参数已被替换为模板实参
  - 对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义
  - 一个模板的实例化会定义会实例化该模板的所有成员，成员函数

# 2. 模板实参推断

- 从函数实参来确定模板实参的过程
- 编译器通常不是对实参进行类型转换，而是生成一个新的模板实例
- 函数模板能应用的类型转换包括两种，大部分情况生成一个新的模板实例
  - const转换（非const对象的引用或指针转换成const)
  - 数组或函数指针转换。（形参是一个引用，则数组不会转换成指针）
  - 算术转换，派生类向基类的转换，用户定义的转换都不能应用于函数模板。
- 如果函数参数类型不是模板参数，则对实参进行正常的类型转换
- 指定**显式模板实参**
  - 显示模板实参在尖括号中给出，位于函数名之后，实参列表之前
  - 只有最右边参数的显示模板实参可以忽略
- 尾置返回
  - `template <typename It> auto f(It begin, It end)->decltype(*beg)`
  - 注意这里decltype(*beg)的类型是beg&
- 标准库的类型转换模板，头文件`type_traits`
  - `remove_reference<decltype(*beg)>::type`会得到beg类型
- 用函数模板初始化一个函数指针或为一个函数指针赋值时，编译器用指针的类型来推断模板实参
- 可以使用显示模板实参来消除函数调用的歧义
- **引用与模板实参推断**
  - 






	1.  引用折叠，右值引用的右值引用为右值引用，其他均折叠为左值引用
	2.  可以将任意类型的实参传递给T&&类型的函数参数
	3.  右值引用通常运用于模板转发其实参或模板被重载
	4.  将一个左值传递给函数的右值引用参数，编译器推断模板的类型参数为实参的左值引用类型
	5.  move 获得一个绑定到左值上的右值引用
	6.  可以用static_cast显示地将一个左值转换为一个右值引用
	7.  转发:某些函数需要将其一个或多个实参连同类型不变地转发给其他函数
	8.  将一个函数参数定义为一个指向模板类型参数地右值引用，既能保存引用也能保存const，但不能传递给接受右值引用的参数
	9.  函数参数是左值表达式
	10. forword返回显示实参类型的右值引用，用于传递那些定义为模板类型参数的右值引用的函数参数
	11. 结合上述两点得到：参数为右值引用，且用forword传递参数，可保证参数的每个细节不变



## 3. 重载与模板


## 4. 可变参数模板

## 5. 模板特例化

- 当我们不能或不希望使用模板版本时，可以定义类或函数模板的一个特例化版本
- 当我们特例化一个函数模板时，必须为原模版的每个模板参数都提供实参
- 为了指出我们正在特例化一个模板，应使用关键字template后跟一个空尖括号对<>
- 当我们定义特例化版本时，函数参数类型必须与一个先前声明的模板中对应的类型匹配
- 特例化时实例化一个模板，而非重载，不影响函数匹配
- 为了特例化一个模板，原模板的声明必须在作用域中
- 模板及其特例化版本应该声明在同一个头文件中，所有同名模板的声明应该放在前面，然后是这些模板的特例化版本
- 只能部分特例化类模板，不能部分特例化函数模板
- 局部特化，在特定的环境下指定类模板的特定实现，并且要求某些模板参数仍然由用户来定义
- 部分特例化版本的模板参数列表是原始模板的参数列表的一个子集或者是一个特例化版
