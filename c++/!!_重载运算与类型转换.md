
# 0. 概述

- 重载运算符函数的参数数量与该运算符作用的运算对象数量一样多
- 除了重载的函数调用运算符operator ()外，其他重载运算符不能含有默认实参
- 一个运算符函数或者是类的成员或者至少含有一个类类型的参数
- 如果一个运算符函数是成员函数，则它的第一个运算对象绑定到隐式的this指针上
- 只能重载已有的运算符
- 部分运算符无法重载
  - 域运算符`::`
  - 成员(指针)访问运算符`.`,`.*`,`->*`
  - 条件运算符`? :`
  - 长度运算符`sizeof`
  - 预处理符号`#`
- 部分运算符不建议被重载（4个）
  - `&&`, `||` , 重载版本无法保留短路求值顺序
  - 逗号和取地址运算符已经定义了用于类类型对象的特殊含义

# 1. 成员，非成员函数？
- 运算符重载有两种方式
  - 一种是类内重载（运算符重载函数作为类的成员函数）
    - 成员函数声明必须在类的内部，定义可以在类的内部也可以在外部
  - 另一种是类外重载（运算符重载函数作为类的友元函数）
    - 非成员函数声明和定义都在类的外部
  - 把运算符定义为成员函数时，左侧运算对象必须是类
- 赋值（=），下标（[]），调用(())，成员访问(->)，类型转换运算符必须是成员
- 输入输出必须是非成员
- 复合赋值一般来说是成员，但非必须
- 改变对象状态的运算符一般是成员
  - 例如递增，递减，解引用
- 具有对称性的运算符（可以转换任意一端的运算对象）一般是非成员
  - 例如算术，相等性，比较

# 2. 输入和输出运算符

- **必须是非成员函数**，一般声明为友元
- 输出运算符
  - 第一个形参是一个非常量ostream对象的引用
  - 第二个形参是类对象的一个常量引用i
  - 返回类型是ostream的引用
- 输入运算符
  - 第一个形参是一个非常量istream对象的引用
  - 第二个形参是类对象的一个非常量引用
  - 返回类型是istream的引用
  - 需要考虑输入时的错误
```cpp
class A
{
    friend ostream& operator<< (ostream &output, const A &a);
    friend istream& operator>> (istream &input, A &a);
};
```

# 3. 算术和关系

- **通常情况下是非成员函数**，以允许对左侧或右侧的运算对象进行转换
- 形参通常是常量的引用
- 如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下用复合运算符来实现算术运算符
```cpp
class A
{
    friend A operator+(const A &, const A &);
    friend bool operator==(const A&, const A&);
    friend bool operator!=(const A&, const A&);
    friend bool operator<(const A&, const A&);
};
```

# 4. 赋值运算符

- **必须是成员函数**
- 复合赋值运算符非必须但建议是成员函数
```cpp
class Foo{
public:
    Foo& operator= (const Foo&);
    Foo& operator+= (const Foo&);
}
```
# 5. 下标运算符

- **必须是成员函数**
- 以所访问元素的引用作为返回值
- 最好同时定义常量和非常量版本
```cpp
class A
{
public:
    string &operator[](size_t n)
    {
        return s[n];
    }
    const string &operator[](size_t n) const
    {
        return s[n];
    }
private:
    string *s;
};
```  

# 6. 递增和递减

- **建议设为成员函数**
- 后置版本接受一个额外的不被使用的int类型的形参
- 前置版本返回引用，后置版本返回值
- 后置运算符一般调用前置版本来完成实际的工作
```cpp
class A
{
public:
    A &operator++()
    {
      ++c;
      return *this;
    }
    A &operator--();
    A operator++(int)
    {
      A res=*this;
      ++ *this;
      return res;
    }
    A operator--(int);
private:
    char c;
};
```

# 7. 成员访问运算符

- 解引用运算符（*），**最好是成员函数**
- 箭头运算符（->）,**必须是成员函数**
  - 含义必须是成员访问
  - 必须返回类的指针，或者定义了箭头运算符的某个类的对象
  - 一般将实际工作委托给解引用
- `p->m`表达式的执行过程
  - 如果p是指针，则应用内置的箭头运算符，等价于`(*p).m`,先解引用该指针，然后从所得的对象中获取指定的成员
  - 如果p是定义了operator->的类的一个对象，则执行`p.operator->()`，如果获得的结果是一个指针，则执行上一步，如果结果依旧是一个类对象，则重复这一步。
```cpp
class A
{
public:
    string &operator*() const;
    string *operator->() const
    {
        return &this->operator*();
    }
};
```

# 8. 类型转换

- 类类型转换包括了转换构造函数和类型转换运算符
  - 由一个实参调用的非显式构造函数定义了一种隐式的类型转换，将实参类型的对象转换成类类型
- 类类型转换运算符`operator type() const`
  - 可以面向任何类型（除void外）进行定义，只要该类型能作为函数的返回类型
  - 不允许转换成数组或者函数类型
  - 但允许转换成指针（包括数组指针和函数指针）或引用类型 
  - **必须是类的成员函数**
  - 不能声明返回类型，形参列表为空，通常是const的
- 编译器一次只能执行一个用户定义的类型转换
- 显式的类型转换，`explicit operator type() const`，只能显示使用强制类型转换
  - 但是如果表达式被用作条件，则依旧被隐式执行
```cpp
class A
{
public:
    A(int i = 0) : val(i) {}
    operator int() const
    {
        return val;
    }
private:
    int val;
};
```
- 避免具有二义性的类型转换
  - 两个类提供了相同的类型转换
    - A定义了一个接受B对象的转化构造函数
    - B定义了一个转换目标是A的类型转换运算符
  - 类定义了多个转换规则，而这些转换涉及的类型本事可以通过其他类型转换联系在一起
    - 最典型的就是算术运算符
    - 最好只定义一个与算术类型有关的转换规则
  
# 8. 函数调用运算符

- **必须是成员函数**
- 如果类定义了调用运算符，则该类的对象称为函数对象
- lambda是函数对象
  - 编写了一个lamda后，编译器会将该表达式翻译成一个未命名类的未命名对象
  - 该类中含有一个重载的函数调用运算符
  - 默认情况下lamda不能改变它捕获的变量，所以函数调用运算符是const的
  - 值拷贝的lambda生成的类中会有一个构造函数