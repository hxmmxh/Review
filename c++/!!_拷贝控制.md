

# 0. 概述

- 共有5种特殊的成员函数
  - 拷贝构造函数，拷贝赋值运算符，移动构造函数，移动赋值运算符和析构函数
- 拷贝和移动构造函数定义了同类型的另一个对象初始化本对象时做什么
- 拷贝和移动赋值运算符定义了将一个对象赋予另一个对象时做什么
- 析构函数则定义当此类型销毁时做什么

# 1. 拷贝、赋值与销毁

## 1.1 拷贝构造函数

- 如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数
  - 几乎总是一个const的引用
  - 不应该是explict的
```cpp
class Foo{
public:
    Foo (const Foo&);
}
```
- **合成的拷贝构造函数**
  - 即使我们定义了其他构造函数,编译器也会为我们生成合成拷贝构造函数
  - 从给定的对象依次将每个非static成员拷贝到正在创建的对象中
  - (只要有其他构造函数定义,编译器不会帮你生成合成默认构造函数）
- 直接初始化:一般在 "()" 调用时发生
- 拷贝初始化不仅在我们使用 "=" 时发生,下列三种情况也会发生
  1. 将一个对象作为实参传递给非引用类型的形参时.
  2. 从一个返回类型为非引用类型的函数返回参数.
  3. 使用花括弧列表初始化一个数组中的元素或聚合类的成员

## 1.2 拷贝赋值运算符
- 必须定义为类的成员函数
  - 左侧运算对象绑定到隐式的this参数
  - 右侧运算对象作为显示参数传递
- 返回类型通常是左侧运算符的引用(为了和内置类型赋值返回本身保持一致)
```cpp
class Foo{
public:
    Foo& operator= (const Foo&);
}
```
- 未定义拷贝赋值运算符的话编译器会帮你生成一个**合成拷贝赋值运算符**，内部实现也是把每个非static变量赋值给左侧对象

## 1.3 析构函数

- 没有返回值，不接受参数
- 不能被重载，对于一个给定类，只有唯一一个析构函数
- 由一个函数体和析构部分执行,首先执行函数，随后逆序释放成员变量
- 析构部分是隐式的
- 调用析构函数的情况：
  - 变量离开作用域时被销毁
  - 当对象被销毁，其成员被销毁
  - 容器被销毁，成员被销毁
  - 动态分配的对象，指针被delete时
  - 临时对象，创建的完整表达式结束时

## 1.4 三/五法则

- 需要析构函数的类也需要拷贝和赋值操作
  - 例如类中有动态分配内存的指针
- 需要拷贝操作也需要赋值操作,反之亦然
  - 例如每个类对象都要有独一无二的序号

## 1.5 阻止拷贝

- 在函数参数列表后加上=delete将函数定义为删除的
  - 可以对任何函数指定delete
  - 必须出现在函数第一次声明的时候

# 2. 拷贝控制和资源管理
- 行为像值一样的对象，每个对象都有自己的状态，副本和原对象时完全独立的，改变副本不会对原对象有任何影响
- 行为像指针的对象，共享状态，副本和原对象使用相同的底层数据，改变副本也会改变原对象
- 赋值运算符通常组合了析构函数和构造函数的操作，先销毁左侧运算对象的资源，再从右侧运算对象种拷贝数
  - 需要处理自赋值的情况
  - 应保证当异常发生时能将左侧运算对象置于一个有意义的状态
  - 一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中，然后再销毁左侧对象

## 2.1 行为像值的类

- 对于类管理的资源，每个对象都应该拥有一份自己的拷贝
```cpp
class HasPtr
{
public:
    HasPtr(const string &s = string()) : ps(new string(s)), i(0) {}
    HasPtr(const HasPtr &p) : ps(new string(*p.ps)), i(p.i) {}
    HasPtr &operator=(const HasPtr &);
    ~HasPtr() { delete ps; }

private:
    string *ps;
    int i;
};

HasPtr &HasPtr::operator=(const HasPtr &rhs)
{
    auto newp = new string(*rhs.ps);
    delete ps;
    ps = newp;
    i = rhs.i;
    return *this;
}
```
## 2.2 行为像指针的类

- 最好的方式是用shared_ptr
- 直接管理资源的话用引用计数
  - 除了初始化对象外，每个构造函数（除了拷贝构造函数）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态
  - 拷贝构造函数不分配新的计数器，递增共享的计数器
  - 析构函数递减计数器，如果计数器变为0，则释放状态
  - 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器，当左侧运算对象的计数器变为0时，释放状态
- 将计数器保存在动态内存中，创建一个对象时分配一个新的计数器，拷贝或赋值时拷贝指向计数器的指针
```cpp
class HasPtr
{
public:
    HasPtr(const string &s = string()) : ps(new string(s)), i(0), use(new int(1)) {}
    HasPtr(const HasPtr &p) : ps(p.ps), i(p.i), use(p.use) { ++*use; }
    HasPtr &operator=(const HasPtr &);
    ~HasPtr();

private:
    string *ps;
    int i;
    int *use;
};

HasPtr::~HasPtr()
{
    if (--*use == 0)
    {
        delete ps;
        delete use;
    }
}

HasPtr &HasPtr::operator=(const HasPtr &rhs)
{
    ++*rhs.use;
    if (--*use == 0)
    {
        delete ps;
        delete use;
    }
    ps = rhs.ps;
    i = rhs.i;
    use = rhs.use;
    return *this;
}
```  

# 3. 交换操作

- 更希望swap交换指针，而不是值，可以避免内存分配
- 如果存在特定版本的swap，其匹配程度会优于std中定义的版本
  - 所以交换两个对象时，不应该用`std::swap(rhs,lhs);`,而应该用`using std::swap; swap(rhs, lhs);`
  - 第一个写法会强制使用std中定义的swap,第二种会优先使用类内定义的swap
```cpp
class HasPtr
{
  friend void swap(HasPtr &, HasPtr &);
};
inline void swap(HasPtr & lhs, HasPtr&rhs)
{
  using std.swap;
  swap(lhs.ps,rhs.ps);
  swap(lhs.i,rhs.i);
}
```
- 可以使用swap来完成赋值运算符
  - 要注意这里形参是按值传递的
  - 自动处理了自赋值的情况
```cpp
HasPtr& HasPtr::operator= (HasPtr rhs)
{
  swap(*this,rhs);
  return *this;
}
```

# 4. 对象移动

## 4.1 右值引用

- 只能绑定到一个将要销毁的对象，通过`&&`而不是`&`来获得
- 一般来说一个左值表示的是一个对象的身份，一个右值表示的是对象的值。
- 返回左值引用的函数，赋值，下标，解引用，前置递增递减运算符，返回左值表达式，可以绑定左值引用
- 返回非引用类型的函数，算术，关系，位，后置递增递减运算符，生成右值，可以绑定const的左值引用和右值引用
- `std::move`，将左值绑定在右值引用上`int &&r=std::move(i)`,调用move意味着承诺除了对i进行赋值或销毁外，将不再使用它。
  - 可以销毁一个移后源对象，或者赋予它新值，但不能使用一个移后源对象的值
  - 使用move的代码应该使用`std::move`
  
## 4.2 移动构造函数和移动赋值运算符

- 移动构造函数的第一个参数是自身类类型的右值引用，且任何额外参数都有默认值
- 一但移动完成，源对象必须不再指向被移动的资源，这些资源的所有权已经归属新创建的对象。
- noexcept通知标准库函数不抛出异常，在一个函数的参数列表之后指定，在声明和定义中都应该指定。移动操作不应该抛出任何异常
- 在移动操作之后，移后源对象必须保持有效的，可析构的状态（可以安全的赋予新值），但用户不能对其值进行任何假设
- **合成的移动操作**
  - 如果一个类定义了自己的拷贝构造函数，拷贝赋值函数或析构函数，编译器就不会合成移动构造和移动赋值函数
  - 只有当一个类没有定义任何自己版本的拷贝控制成员且类的每个非static数据成员都可以移动时，编译器才会合成移动构造/赋值函数
	1.  定义了一个移动构造函数或移动赋值函数的类必须也定义自己的拷贝操作，否则这些成员默认地被定义为删除
	2.  如果一个类定义了一个拷贝并交换赋值运算符，如果为此类添加一个移动构造函数，它实际上也会获得一个移动赋值运算符

