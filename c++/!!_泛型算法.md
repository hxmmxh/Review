
# 0. 概述

- generic algorithm,泛型算法
  - 实现了一些经典算法的公共接口
  - 可以用于不同类型的元素和多种容器类型
- 大多数定义在algorithm中，数值算法定义在numeric中
- 并不直接操作容器，而是遍历由两个迭代器指定的范围
  - 算法不会执行容器的操作，永远不会改变底层容器的大小
  - 但可能会改变元素的值，也可能会移动元素

# 1. 常见算法

# 2. 定制操作

- 谓词，predicate
  - 是一个可调用的表达式，返回结果是一个能用作条件的值
  - 有一元谓词和二元谓词
- 可以向一个算法传递任何类型的可调用对象


# 3. 迭代器分类

- 输入迭代器（用于读数据）：只读不写，单遍扫描，只能递增
  - 支持`==,!=,++,*,->`,
- 输出迭代器（用于写数据）：只写不读，单遍扫描，只能递增
- 前向迭代器：可读写，多变扫描，只能递增
- 双向迭代器：可读写，多变扫描，可递增递减
- 随机访问迭代器：可读写，多变扫描，可随机访问

# 4. 特殊迭代器

- 插入迭代器：绑定到容器上，用来插入元素
- 流迭代器：绑定到输入或输出流上，用来遍历所关联的IO流
- 反向迭代器：向后移动
- 移动迭代器：用来移动元素

## 3.1 插入迭代器

- 接受一个容器，生成一个迭代器，能向容器中添加元素
  - 普通迭代器向容器元素赋值时，值被赋予迭代器指向的元素
  - 插入迭代器赋值时，元素被添加到容器中
- `*it, ++it, it++`，不会做任何操作，都是返回it
- 有三种类型
  - back_inserter, 插入元素时使用push_back，每次都插入到尾部
  - front_inserter,使用push_front，每次都插入到容器首部
  - inserter,使用insert，会接受第二个参数，该参数指向给定容器的迭代器，元素会被插入到迭代器所表示的元素之前。插入完成后该迭代器还指向原来的元素
```cpp
list<int> lst={1,2,3,4};
list<int> lst2,lst3;//空的list
copy(lst.cbegin(),lst.cend(),front_inserter(lst2));
//得到 4 3 2 1
copy(lst.cbegin(),lst.cend(),inserter(lst3,lst3.begin()));
// 得到 1 2 3 4 
```

## 3.2 流迭代器

- istream_iterator读取输入流
- ostream_iterator向一个输出流写数据
- 将对应的流当作一个特定类型的元素序列来处理
- 创建一个流迭代器时必须指定迭代器将要读写的对象类型
```cpp
istream_iterator<T> in(is);//迭代器in从流is中读取类型为T的值
istream_iterator<T> end;//默认初始化，表示一个尾后的位置
*in;//返回从流中读取的值
in->mem;//
++in;in++；//从输入流中读取下一个值
ostream_iterator<T> out(os);//迭代器out将类型为T的值写到输入流os中
ostream_iterator<T> out(os,d);//每个值后面都输出一个d，d指向一个空字符结尾的字符数组
out=val;//将val写到out所绑定到输出流中
*out;++out;//不做任何事情
```

## 3.3 反向迭代器

- 从尾元素向首元素反向移动
- rbegin,crbegin，返回指向容器尾元素的迭代器
- rend,crend，返回首元素之前一个位置的迭代器
- `rit.base()`会返回反向迭代器对应的正向迭代器
  - rit和rit.base()指向不同的元素，rit指向的是rit.base()左侧的元素
  - 是为了让`[list.rbegin(),rit)`和`[rit.base(),list.end())`指向相同的元素范围

## 3.4 移动迭代器

