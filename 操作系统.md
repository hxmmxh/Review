



### 进程线程区别















### 进程间通信
Linux几乎支持全部UNIX进程间通信方法，包括管道（有名管道和无名管道）、消息队列、共享内存、信号量和套接字。其中前四个属于同一台机器下进程间的通信，套接字则是用于网络通信。  
* 管道
    * 无名管道
        * 无名管道是一种特殊的文件，这种文件只存在于内存中。
        * 无名管道只能用于父子进程或兄弟进程之间，必须用于具有亲缘关系的进程间的通信。
        * 无名管道只能由一端向另一端发送数据，是半双工方式，如果双方需要同时收发数据需要两个管道。
        * 相关接口：int pipe(int fd[2]);fd[2]：管道两端用fd[0]和fd[1]来描述，读的一端用fd[0]表示，写的一端用fd[1]表示。通信双方的进程中写数据的一方需要把fd[0]先close掉，读的一方需要先把fd[1]给close掉。
    * 有名管道：
        * 有名管道是FIFO文件，存在于文件系统中，可以通过文件路径名来指出。
        * 无名管道可以在不具有亲缘关系的进程间进行通信。
        * 相关接口：int mkfifo(const char *pathname, mode_t mode);pathname：即将创建的FIFO文件路径，如果文件存在需要先删除。mode：和open()中的参数相同。
* 消息队列
    * 消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息； 
    * 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。 
    * 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。 
    * 消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。 
* 共享内存
进程可以将同一段共享内存连接到它们自己的地址空间，所有进程都可以访问共享内存中的地址，如果某个进程向共享内存内写入数据，所做的改动将立即影响到可以访问该共享内存的其他所有进程。
相关接口
创建共享内存：int shmget(key_t key, int size, int flag);
成功时返回一个和key相关的共享内存标识符，失败范湖范围-1。
key：为共享内存段命名，多个共享同一片内存的进程使用同一个key。
size：共享内存容量。
flag：权限标志位，和open的mode参数一样。
连接到共享内存地址空间：void *shmat(int shmid, void *addr, int flag);
返回值即共享内存实际地址。
shmid：shmget()返回的标识。
addr：决定以什么方式连接地址。
flag：访问模式。
从共享内存分离：int shmdt(const void *shmaddr);
调用成功返回0，失败返回-1。
shmaddr：是shmat()返回的地址指针。
其他补充
共享内存的方式像极了多线程中线程对全局变量的访问，大家都对等地有权去修改这块内存的值，这就导致在多进程并发下，最终结果是不可预期的。所以对这块临界区的访问需要通过信号量来进行进程同步。
但共享内存的优势也很明显，首先可以通过共享内存进行通信的进程不需要像无名管道一样需要通信的进程间有亲缘关系。其次内存共享的速度也比较快，不存在读取文件、消息传递等过程，只需要到相应映射到的内存地址直接读写数据即可。


* 信号量


* 套接字



### 线程间通信的方式: 
临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问； 
互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问 
信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。 
事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作 