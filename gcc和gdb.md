
# GCC

## gcc编译常用命令选项

* -E
预编译后停下来，生成后缀为 .i 的预编译文件。
* -S
汇编后停下来，生成后缀为 .s 的汇编源文件。
* -c      
只编译，不链接成为可执行文件。编译器只是由输入的 .c 等源代码文件生成 .o 为后缀的目标文件，通常用于编译不包含主程序的子程序文件。
* -o output_filename      
确定输出文件的名称为output_filename。同时这个名称不能和源文件同名。如果不给出这个选项，gcc就给出默认的可执行文件 a.out。
* -g  
产生符号调试工具（GNU的 gdb）所必要的符号信息。想要对源代码进行调试，就必须加入这个选项。
* -O0，-O1，-O2, -O3  
对程序进行优化编译、链接。采用这个选项，整个源代码会在编译、链接过程中进行优化处理，这样产生的可执行文件的执行效率可以提高，但是编译、链接的速度就相应地要慢一些，而且对执行文件的调试会产生一定的影响，造成一些执行效果与对应源文件代码不一致等一些令人“困惑”的情况。因此，一般在编译输出软件发行版时使用此选项。-O0 表示没有优化, -O1 为默认值，-O3 优化级别最高。



**警告提示功能选项**
* -w   
不生成任何警告信息。 
* -Wall   
生成所有警告信息。
* -Werror
它要求 gcc 将所有的警告当成错误进行处理，会在所有产生警告的地方停止编译
* -Wcast-align
当源程序中地址不需要对齐的指针指向一个地址需要对齐的变量地址时，则产生一个警告。例如，char * 指向一个 int * 地址，而通常在机器中 int 变量类型是需要地址能被2或4整除的对齐地址。




**库操作选项**
* -Idirname
将 dirname 所指出的目录加入到程序头文件目录列表中  
在你是用 #include "file" 的时候, gcc/g++ 会先在当前目录查找你所制定的头文件, 如果没有找到, 他回到默认的头文件目录找, 如果使用 -I 制定了目录,他会先在你所制定的目录查找, 然后再按常规的顺序去找。
对于 #include<file>, gcc/g++ 会到 -I制定的目录查找, 查找不到, 然后将到系统的默认的头文件目录查找 。
* -Ldirname  
将dirname所指出的目录加入到程序函数库文件的目录列表中，是在链接过程中使用的参数。在默认状态下，链接程序 ld 在系统默认路径中（如 /usr/lib）寻找所需要的库文件。这个选项告诉链接程序，首先到 -L 指定的目录中去寻找，然后到系统默认路径中寻找；如果函数库存放在多个目录下，就需要依次使用这个选项，给出相应的存放目录。
* -lname  
链接时装载名为 libname.a 的函数库。该函数库位于系统默认的目录或者由 -L 选项确定的目录下。例如，-lm 表示链接名为 libm.a 的数学函数库。






**调试选项**

* -g 和 -ggdb
默认情况下，gcc 在编译时不会将调试符号插入到生成的二进制代码中，因为这样会增加可执行文件的大小。如果需要在编译时生成调试符号信息，可以使用 gcc 的 -g 或 -ggdb 选项。
gcc 在产生调试符号时，同样采用了分级的思路，开发人员可以通过在 -g 选项后附加数字1、2、3指定在代码中加入调试信息的多少。默认的级别是2（-g2），此时产生的调试信息包括：扩展的符号表、行号、局部或外部变量信息。
级别3（-g3）包含级别2中的所有调试信息以及源代码中定义的宏。
级别1（-g1）不包含局部变量和与行号有关的调试信息，因此只能够用于回溯跟踪和堆栈转储。
回溯追踪：指的是监视程序在运行过程中函数调用历史。
堆栈转储：则是一种以原始的十六进制格式保存程序执行环境的方法。

注意：使用任何一个调试选项都会使最终生成的二进制文件的大小急剧增加，同时增加程序在执行时的开销，因此，调试选项通常仅在软件的开发和调试阶段使用。

* -p 和 -pg
会将剖析（Profiling）信息加入到最终生成的二进制代码中。剖析信息对于找出程序的性能瓶颈很有帮助，是协助Linux程序员开发出高性能程序的有力工具。

* -save-temps
保存编译过程中生成的一些列中间文件。
# gcc test.c -o test -save-temps
除了生成执行文件test之外，还保存了test.i 和 test.s 中间文件，供用户查询调试。













-----------------------------------------------

# GDB

## 常用命名
|命令|命令缩写|命令说明|
|:---:|:-----:|:-----:|
list|l|显示多行源代码|
break|b|设置断点,程序运行到断点的位置会停下来|
info|i|描述程序的状态|
run|r|开始运行程序|
display|disp|跟踪查看某个变量,每次停下来都显示它的值
step|s|执行下一条语句,如果该语句为函数调用,则进入函数执行其中的第一条语句
next|n|执行下一条语句,如果该语句为函数调用,不会进入函数内部执行(即不会一步步地调试函数内部语句)
print|p|打印内部变量值
continue|c|继续程序的运行,直到遇到下一个断点
set var name=v||设置变量的值
start|st|开始执行程序,在main函数的第一条语句前面停下来
file||装入需要调试的程序|
kill|k|终止正在调试的程序
watch||监视变量值的变化,使用观察点可以使得当某表达式的值发生变化时,程序暂停执行
backtrace|bt|产看函数调用信息(堆栈)
frame|f|查看栈帧
whatis 变量名||查看变量的类型
quit|q|退出GDB环境


* list
    * list命令显示多行源代码,从上次的位置开始显示,默认情况下,一次显示10行,第一次使用时,从代码其实位置显示
    * list n显示已第n行为中心的10行代码
    * list functionname显示以functionname的函数为中心的10行代码
    * list - 显示刚才打印过的源代码之前的代码
* break
    * break location:在location位置设置断点,改位置可以为某一行,某函数名或者其它结构的地址,GDB会在执行该位置的代码之前停下来
    * delete breakpoints 断点号 : 删除断点,断点号表示的是第几个断点
    * clear n表示清除第n行的断点
    * disable/enable n表示使得编号为n的断点暂时失效或有效
    * info breakpoints 可使用info查看断点相关的信息



## 一般流程
