创建型

-----------------------------------

- [0. 简介](#0-简介)
- [1. 简单工厂模式（Simple Factory Pattern)](#1-简单工厂模式simple-factory-pattern)
  - [1.1 简介](#11-简介)
  - [1.2 模式结构](#12-模式结构)
  - [1.3 代码](#13-代码)
  - [1.4 优缺点](#14-优缺点)
  - [1.5 适用情况](#15-适用情况)
- [2. 工厂方法模式（Factory Method）](#2-工厂方法模式factory-method)
  - [2.1 简介](#21-简介)
  - [2.2 模式结构](#22-模式结构)
  - [2.3 代码](#23-代码)
  - [2.4 优缺点](#24-优缺点)
  - [2.5 适用情况](#25-适用情况)
- [3. 抽象工厂](#3-抽象工厂)
  - [优缺点](#优缺点)
- [4. 建造者模式(Builder)](#4-建造者模式builder)
  - [4.1 简介](#41-简介)
  - [4.2 模式结构](#42-模式结构)
  - [4.3 优缺点](#43-优缺点)
  - [4.4 适用环境](#44-适用环境)
- [5. 单例(Singleton)](#5-单例singleton)
  - [实现方式](#实现方式)
  - [优缺点](#优缺点-1)
  - [适用环境](#适用环境)
- [6. 原型模式（Prototype）](#6-原型模式prototype)


------------------------------------------------------------------
# 0. 简介

- 创建型模式(Creational Pattern)对类的实例化过程进行了抽象
- 将软件模块中对象的创建和对象的使用分离。

# 1. 简单工厂模式（Simple Factory Pattern)
  
## 1.1 简介
- 又称为静态工厂方法(Static Factory Method)模式
- 可以根据参数的不同返回不同类的实例。
- 专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类
- 当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节

## 1.2 模式结构

1. Factory：工厂角色
  - 工厂角色负责实现创建所有实例的内部逻辑
2. Product：抽象产品角色
  - 是所创建的所有对象的父类，负责描述所有实例所共有的公共接口
3. ConcreteProduct：具体产品角色
  - 创建目标，所有创建的对象都充当这个角色的某个具体类的实例。

## 1.3 代码

- 见1_1_SimpleFactort.cpp
  
## 1.4 优缺点

- 优点
  - 实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责
  - 客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品
- 缺点在
  - 工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂

## 1.5 适用情况

- 工厂类负责创建的对象比较少
  - 由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。
- 客户端只知道传入工厂类的参数，对于如何创建对象不关心。



# 2. 工厂方法模式（Factory Method）

## 2.1 简介

- 不同于简单工厂模式，将工厂类扩展成抽象父类和具体工厂类
  - 所有的具体工厂类都具有同一抽象父类
  - 核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做
  - 核心工厂类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化这种细节
  - 可以在不修改具体工厂类的情况下引进新的产品
- 工厂父类负责定义创建产品对象的公共接口
- 工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。

## 2.2 模式结构

- Product：抽象产品
- ConcreteProduct：具体产品
- Factory：抽象工厂
- ConcreteFactory：具体工厂

## 2.3 代码


## 2.4 优缺点

- 优点
  - 工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部
  - 在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”
- 缺点
  - 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度
  - 考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度

## 2.5 适用情况

- 一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。
- 客户端只知道传入工厂类的参数，对于如何创建对象不关心。



# 3. 抽象工厂

- 需要一个工厂可以提供多个产品对象，而不是单一的产品对象

- 当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；
- 当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。






- 产品等级结构
  - 产品等级结构即产品的继承结构
  - 如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。
  - 又或者是洗衣机，空调
- 产品族
  - 在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品
  - 如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。
- 产品族难扩展，产品等级易扩展
- 工厂方法模式针对的是一个产品等级结构
- 而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。 

## 优缺点

- 优点
  - 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象
  - 增加新的具体工厂和产品族很方便
- 缺点
  - 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。
  - 开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）
  


# 4. 建造者模式(Builder)

## 4.1 简介

- 一些复杂的对象，它们拥有多个组成部分
- 一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节


## 4.2 模式结构

- Builder：抽象建造者
  - 创建一个产品对象的各个部件指定抽象接口
- ConcreteBuilder：具体建造者
  - 实现了抽象建造者接口，实现各个部件的构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象
- Director：指挥者
  - 负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造
- Product：产品角色
  - 被构建的复杂对象，包含多个组成部件

## 4.3 优缺点

- 优点
  - 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。
  - 一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。
  - 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。
  - 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。
- 缺点
  - 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。
  - 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。

## 4.4 适用环境
- 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。
- 需要生成的产品对象的属性相互依赖，需要指定其生成顺序。
- 对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。
- 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。



# 5. 单例(Singleton)

- 保证一个类只有一个实例并且这个实例易于被访问
- 该类负责创建自己的对象，同时确保只有单个对象被创建，并且提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。
  - 某个类只能有一个实例
  - 它必须自行创建这个实例
  - 它必须自行向整个系统提供这个实例
- 单例模式在多线程的 应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例， 这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则
- 必须实现以下几点
  - 提供一个private构造函数(防止外部调用而构造类的实例)
  - 提供一个该类的static private对象
  - 提供一个static public函数，用于创建获取其本身的静态私有对象(例如：GetInstance())

[](https://www.cnblogs.com/cthon/p/9196664.html)
## 实现方式
- 总结一般采用饿汉式，若对资源十分在意可以采用静态内部类，不建议采用懒汉式及双重检测 
1. 懒汉式，线程不安全
  - 单例实例在第一次被使用时构建，延迟初始化
  - 没有加锁，线程不安全
2. 懒汉式，线程安全
  - 优点：第一次调用才初始化，避免内存浪费。
  - 缺点：加锁才能保证单例，但加锁会影响效率。
3. 饿汉式
   - 单例实例在类装载时就构建，急切初始化
   - 没有加锁就保证了线程安全，执行效率会提高。
   - 在类加载的同时已经创建好一个静态对象，调用时反应速度快 
   - 缺点：类加载时就初始化，浪费内存。
4. 双重锁(DCL，即 double-checked locking)
  - 采用双锁机制，安全且在多线程情况下能保持高性能
5. 登记式/静态内部类
6. pthread_once
## 优缺点

- 优点
  - 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。
  - 避免对资源的多重占用（比如写文件操作）
## 适用环境


# 6. 原型模式（Prototype）

- 用于创建重复的对象，同时又能保证性能
- 实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式