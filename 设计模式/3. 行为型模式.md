行为型

------------------------------


- [0. 简介](#0-简介)
- [1. 命令模式(Command)](#1-命令模式command)
  - [1.1 简介](#11-简介)
  - [1.2 模式结构](#12-模式结构)
- [2. 中介者模式(Mediator)](#2-中介者模式mediator)
  - [2.1 简介](#21-简介)
  - [2.1 模式结构](#21-模式结构)
- [3. 观察者模式(Observer)](#3-观察者模式observer)
  - [3.1 简介](#31-简介)
  - [3.2 模式结构](#32-模式结构)
  - [3.3 优缺点](#33-优缺点)
  - [3.4 使用环境](#34-使用环境)
- [4. 状态模式(State)](#4-状态模式state)
  - [4.1 简介](#41-简介)
  - [4.2 模式结构](#42-模式结构)
- [5. 策略模式(Strategy)](#5-策略模式strategy)
  - [5.1 简介](#51-简介)
  - [5.2 模式结构](#52-模式结构)
- [责任链型](#责任链型)
# 0. 简介

- 通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象之间的交互
- 类行为型模式
  - 使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责。
- 对象行为型模式
  - 使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。- 根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。

# 1. 命令模式(Command)

## 1.1 简介

- 对命令进行封装，将发出命令的责任和执行命令的责任分割开
- 发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求
- 对象行为型模式

## 1.2 模式结构

- Command: 抽象命令类
  - 声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作；
- ConcreteCommand: 具体命令类
  - 是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中
- Invoker: 调用者
  - 即请求的发送者，又称为请求者，它通过命令对象来执行请求
- Receiver: 接收者
  - 执行与请求相关的操作，它具体实现对请求的业务处理。


# 2. 中介者模式(Mediator)

## 2.1 简介

- 对象行为型模式
- 用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
- 以使对象之间的关系数量急剧减少
- 中转作用（结构性）：通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，通过中介者即可。该中转作用属于中介者在结构上的支持。
- 协调作用（行为性）：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者在行为上的支持。

## 2.1 模式结构

- Mediator: 抽象中介者
  - 定义一个接口，该接口用于与各同事对象之间的通信
- ConcreteMediator: 具体中介者
  - 是抽象中介者的子类，通过协调各个同事对象来实现协作行为，了解并维护它的各个同事对象的引用
- Colleague: 抽象同事类
  - 定义各同事的公有方法
- ConcreteColleague: 具体同事类
  - 抽象同事类的子类，实现了在抽象同事类中定义的方法
  - 每一个同事对象都引用一个中介者对象；每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信；


# 3. 观察者模式(Observer)

## 3.1 简介

- 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新
- 发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展

## 3.2 模式结构
- Subject: 目标
  - 是指被观察的对象
- ConcreteSubject: 具体目标
  - 目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知
  - 存储着观察者队列
- Observer: 观察者
  - 对观察目标的改变做出反应
- ConcreteObserver: 具体观察者
  - 维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致。

## 3.3 优缺点
- 优点
- 缺点
  - 如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。
  - 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。

## 3.4 使用环境


# 4. 状态模式(State)
## 4.1 简介
- 允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类
- 在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的(stateful)对象
- 这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。

## 4.2 模式结构
- Context: 环境类
- State: 抽象状态类
- ConcreteState: 具体状态类

# 5. 策略模式(Strategy)

## 5.1 简介

- 完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。
- 定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略(Strategy)
- 为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类
- 定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化

## 5.2 模式结构

- Context: 环境类
- Strategy: 抽象策略类
- ConcreteStrategy: 具体策略类


# 责任链型 
* 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。




















1. 观察者（Observer）
    * 定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。
    * 主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。
    * 实现细节
        * 主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。
        * 观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。
        * 所有观察者必须实现观察者接口，这个接口只有update()一个方法，当主题状态改变时，它被调用
2. 迭代器（Iterator）
    * 提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。
