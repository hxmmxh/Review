结构型

--------------------------------------------
- [0. 简介](#0-简介)
- [1. 适配器（Adapter）](#1-适配器adapter)
  - [1.1 简介](#11-简介)
  - [1.2 模式结构](#12-模式结构)
  - [1.3 优缺点](#13-优缺点)
  - [1.4 适用环境](#14-适用环境)
- [2. 桥接（Bridge）](#2-桥接bridge)
  - [2.1 简介](#21-简介)
  - [2.2 模式结构](#22-模式结构)
  - [2.3 优缺点](#23-优缺点)
  - [2.4 适用场景](#24-适用场景)
- [3. 装饰模式（Decorator）](#3-装饰模式decorator)
  - [3.1 简介](#31-简介)
  - [3.2 模式结构](#32-模式结构)
  - [3.3 优缺点](#33-优缺点)
  - [3.4 适用范围](#34-适用范围)
- [4. 外观（Facade）](#4-外观facade)
  - [4.1 简介](#41-简介)
  - [4.2 模式结构](#42-模式结构)
- [5. 享元模式（Flyweight）](#5-享元模式flyweight)
  - [5.1 简介](#51-简介)
  - [5.2 模式结构](#52-模式结构)
  - [5.4 适用范围](#54-适用范围)
- [6. 代理模式(Proxy)](#6-代理模式proxy)
  - [6.2 模式结构](#62-模式结构)
  - [6.3 优缺点](#63-优缺点)
  - [6.4 使用场景](#64-使用场景)
- [7. 组合模式(Composite)](#7-组合模式composite)
- [8. 过滤器模式(Filter)](#8-过滤器模式filter)


# 0. 简介

- 描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。
- 可分为两种
  - 类结构型模式
    - 关心类的组合，由多个类可以组合成一个更大的系统
    - 一般只存在继承关系和实现关系
  - 对象结构型模式
    - 关心类与对象的组合
    - 通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法
- 根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系，因此大部分结构型模式都是对象结构型模式。

# 1. 适配器（Adapter）

## 1.1 简介
- 把一个类接口转换成另一个用户需要的接口。
  - 通常情况下，客户端可以通过目标类的接口访问它所提供的服务
  - 有时现有的类可以满足客户类的功能需要，但是它所提供的接口不一定是客户类所期望的
  - 在这种情况下，现有的接口需要转化为客户类期望的接口，这样保证了对现有类的重用
- STL中用deque实现queue和stack,用vector实现priority_queue
- 既可以作为类结构型模式，也可以作为对象结构型模式。

## 1.2 模式结构

- 定义一个包装类，包装不兼容接口的对象，这个包装类指的就是适配器(Adapter)，它所包装的对象就是适配者(Adaptee)，即被适配的类。
- Target，目标抽象类
  - 定义客户要用的特定领域的接口；
- Adapter，适配器类
  - 可以调用另一个接口，作为一个转换器，对适配者和抽象目标类进行适配，它是适配器模式的核心；
  - 在类适配器模式中，适配器类实现了目标抽象类接口并继承了适配者类，并在目标抽象类的实现方法中调用所继承的适配者类的方法；
  - 在对象适配器模式中，适配器类继承了目标抽象类并定义了一个适配者类的对象实例，在所继承的目标抽象类方法中调用适配者类的相应业务方法。
- Adaptee，适配者类
  - 是被适配的角色，它定义了一个已经存在的接口，这个接口需要适配；
- Client，客户类
  - 针对目标抽象类进行编程，调用在目标抽象类中定义的业务方法。

## 1.3 优缺点

- 优点
  - 增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。
  - 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。
  - 类适配器模式还具有如下优点：由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。
  - 对象适配器模式还具有如下优点：一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。
- 缺点
  - 类适配器模式的缺点如下：对于Java、C#等不支持多重继承的语言，一次最多只能适配一个适配者类，而且目标抽象类只能为抽象类，不能为具体类，其使用有一定的局限性，不能将一个适配者类和它的子类都适配到目标接口。
  - 对象适配器模式的缺点如下：与类适配器模式相比，要想置换适配者类的方法就不容易。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。

## 1.4 适用环境

- 系统需要使用现有的类，而这些类的接口不符合系统的需要。
- 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作


# 2. 桥接（Bridge）

## 2.1 简介
- 将抽象与实现分离开来，使它们可以独立变化（脱耦）。
  - 抽象化就是忽略一些信息，把不同的实体当作同样的实体对待。在面向对象中，将对象的共同性质抽取出来形成类的过程即为抽象化的过程。
  - 实现化就是针对抽象化给出的具体实现，抽象化与实现化是一对互逆的概念，实现化产生的对象比抽象化更具体，是对抽象化事物的进一步具体化的产物。
  - 脱耦就是将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系
- 将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。
- 是一种对象结构型模式

## 2.2 模式结构

- Abstraction：抽象类
  - 定义了一个实现类接口类型的对象并可以维护该对象
  - 包含了实现类接口对象，关联关系
- RefinedAbstraction：扩充抽象类
  - 扩充由抽象类定义的接口，它实现了在抽象类中定义的抽象业务方法，在扩充抽象类中可以调用在实现类接口中定义的业务方法
- Implementor：实现类接口
  - 定义了实现类的接口，实现类接口仅提供基本操作，而抽象类定义的接口可能会做更多更复杂的操作
- ConcreteImplementor：具体实现类
  - 实现了实现类接口并且具体实现它，在不同的具体实现类中提供基本操作的不同实现，在程序运行时，具体实现类对象将替换其父类对象，提供给客户端具体的业务操作方法。
- 通过更换不同的实现具体类修改实现类的操作，同时通过扩充抽象类修改抽象类的操作
## 2.3 优缺点


## 2.4 适用场景

- 桥接模式用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化

# 3. 装饰模式（Decorator）

## 3.1 简介

- 一般有两种方式可以实现给一个类或对象增加行为：
  - 继承机制，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。
  - 关联机制，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)
  - 与继承关系相比，关联关系的主要优势在于不会破坏类的封装性，而且继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展。在软件开发阶段，关联关系虽然不会比继承关系减少编码量，但是到了软件维护阶段，由于关联关系使系统具有较好的松耦合性，因此使得系统更加容易维护。当然，关联关系的缺点是比继承关系要创建更多的对象
- 装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。
- 装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展

## 3.2 模式结构

- Component: 抽象构件
  - 定义了对象的接口，可以给这些对象动态增加职责（方法）
- ConcreteComponent: 具体构件
  - 定义了具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法
- Decorator: 抽象装饰类
  - 是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现
  - 并且包含一个抽象构件的成员
- ConcreteDecorator: 具体装饰类
  - 是抽象装饰类的子类，负责向构 件添加新的职责
- 一个装饰类的接口必须与被装饰类的接口保持相同，对于客户端来说无论是装饰之前的对象还是装饰之后的对象都可以一致对待。
- 尽量保持具体构件类Component作为一个“轻”类，也就是说不要把太多的逻辑和状态放在具体构件类中，可以通过装饰类对其进行扩展。 
- 如果只有一个具体构件类而没有抽象构件类，那么抽象装饰类可以作为具体构件类的直接子类。




## 3.3 优缺点

- 优点
  - 使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任
  - 可以在不需要创造更多子 类的情况下，将对象的功能加以扩展
- 缺点
  - 将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度

## 3.4 适用范围

- 在不影响其他对象的情况下，以动态、透明的方式给 单个对象添加职责；
- 需要动态地给一个对象增加功能，这些功能也可以动态地 被撤销；
- 当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展 和维护时

# 4. 外观（Facade）
    
## 4.1 简介  

- 提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用
- 外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面
- 外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用
- 对象结构型模式

## 4.2 模式结构

- Facade: 外观角色
- SubSystem:子系统角色


# 5. 享元模式（Flyweight）

## 5.1 简介

- 用于减少创建对象的数量，以减少内存占用和提高性能
- 提供了减少对象数量从而改善应用所需的对象结构的方式
- 通过共享技术实现相同或相似对象的重用
- 尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象
- 享元对象能做到共享的关键是区分内部状态(Internal State)和外部状态(External State)。
  - 内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，因此内部状态可以共享。
  - 外部状态是随环境改变而改变的、不可以共享的状态。
  - 享元对象的外部状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。一个外部状态与另一个外部状态之间是相互独立的。
## 5.2 模式结构

- Flyweight: 抽象享元类
- ConcreteFlyweight: 具体享元类
- UnsharedConcreteFlyweight: 非共享具体享元类
- FlyweightFactory: 享元工厂类
  - 提供一个用于存储享元对象的享元池
  - 用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。

## 5.4 适用范围

- 


# 6. 代理模式(Proxy)

- 通过引入代理对象来间接访问一个对象
- 给某一个对象提供一个代理，并由代理对象控制对原对象的引用
- 对象结构型模式
  
## 6.2 模式结构

- Subject: 抽象主题角色
  - 声明了真实主题和代理主题的共同接口
- Proxy: 代理主题角色
  - 内部包含对真实主题的引用，从而可以在任何时候操作真实主题对象
- RealSubject: 真实主题角色
  - 定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作

## 6.3 优缺点
- 在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。

## 6.4 使用场景


# 7. 组合模式(Composite)

- 将对象组合成树形结构来表示“整体/部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。
- 模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。    
    
    * 组件（Component）类是组合类（Composite）和叶子类（Leaf）的父类，可以把组合类看成是树的中间节点。
    * 组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。

# 8. 过滤器模式(Filter)

- 使用不同的标准来过滤一组对象
