
# GCC

## gcc编译常用命令选项

* -E
预编译后停下来，生成后缀为 .i 的预编译文件。
* -S
编译后停下来，生成后缀为 .s 的汇编文件。
* -c
汇编后停止下来生成目标文件，不链接成为可执行文件。编译器只是由输入的 .c 等源代码文件生成 .o 为后缀的目标文件，通常用于编译不包含主程序的子程序文件。
* -o output_filename
确定输出文件的名称为output_filename。同时这个名称不能和源文件同名。如果不给出这个选项，gcc就给出默认的可执行文件 a.out。
* [补充知识：文件的编译过程](#文件的编译过程)
* -g  
产生符号调试工具（GNU的 gdb）所必要的符号信息。想要对源代码进行调试，就必须加入这个选项。
* -O0，-O1，-O2, -O3  
对程序进行优化编译、链接。采用这个选项，整个源代码会在编译、链接过程中进行优化处理，这样产生的可执行文件的执行效率可以提高，但是编译、链接的速度就相应地要慢一些，而且对执行文件的调试会产生一定的影响，造成一些执行效果与对应源文件代码不一致等一些令人“困惑”的情况。因此，一般在编译输出软件发行版时使用此选项。-O0 表示没有优化, -O1 为默认值，-O3 优化级别最高。
* -v
查看完整和详细的gcc编译过程

* **警告提示功能选项**

* -w
不生成任何警告信息。
* -Wall
生成所有警告信息。
* -Werror
它要求 gcc 将所有的警告当成错误进行处理，会在所有产生警告的地方停止编译
* -Wcast-align
当源程序中地址不需要对齐的指针指向一个地址需要对齐的变量地址时，则产生一个警告。例如，char* 指向一个 int* 地址，而通常在机器中 int 变量类型是需要地址能被2或4整除的对齐地址。

* **库操作选项**

* -Idirname
将 dirname 所指出的目录加入到程序头文件目录列表中  
在你是用 #include "file" 的时候, gcc/g++ 会先在当前目录查找你所制定的头文件, 如果没有找到, 他回到默认的头文件目录找, 如果使用 -I 制定了目录,他会先在你所制定的目录查找, 然后再按常规的顺序去找。
对于 #include<file>, gcc/g++ 会到 -I制定的目录查找, 查找不到, 然后将到系统的默认的头文件目录查找 。
* -Ldirname  
将dirname所指出的目录加入到程序函数库文件的目录列表中，是在链接过程中使用的参数。在默认状态下，链接程序 ld 在系统默认路径中（如 /usr/lib）寻找所需要的库文件。这个选项告诉链接程序，首先到 -L 指定的目录中去寻找，然后到系统默认路径中寻找；如果函数库存放在多个目录下，就需要依次使用这个选项，给出相应的存放目录。
* -lname  
链接时装载名为 libname.a 的函数库。该函数库位于系统默认的目录或者由 -L 选项确定的目录下。例如，-lm 表示链接名为 libm.a 的数学函数库。

**调试选项**

* -g 和 -ggdb
默认情况下，gcc 在编译时不会将调试符号插入到生成的二进制代码中，因为这样会增加可执行文件的大小。如果需要在编译时生成调试符号信息，可以使用 gcc 的 -g 或 -ggdb 选项。
gcc 在产生调试符号时，同样采用了分级的思路，开发人员可以通过在 -g 选项后附加数字1、2、3指定在代码中加入调试信息的多少。默认的级别是2（-g2），此时产生的调试信息包括：扩展的符号表、行号、局部或外部变量信息。
级别3（-g3）包含级别2中的所有调试信息以及源代码中定义的宏。
级别1（-g1）不包含局部变量和与行号有关的调试信息，因此只能够用于回溯跟踪和堆栈转储。
回溯追踪：指的是监视程序在运行过程中函数调用历史。
堆栈转储：则是一种以原始的十六进制格式保存程序执行环境的方法。

注意：使用任何一个调试选项都会使最终生成的二进制文件的大小急剧增加，同时增加程序在执行时的开销，因此，调试选项通常仅在软件的开发和调试阶段使用。

* -p 和 -pg
会将剖析（Profiling）信息加入到最终生成的二进制代码中。剖析信息对于找出程序的性能瓶颈很有帮助，是协助Linux程序员开发出高性能程序的有力工具。

* -save-temps
保存编译过程中生成的一些列中间文件。

# gcc test.c -o test -save-temps

除了生成执行文件test之外，还保存了test.i 和 test.s 中间文件，供用户查询调试。

-----------------------------------------------
[参考资料](https://www.cnblogs.com/qigaohua/p/6077790.html)
https://blog.csdn.net/haoel/article/details/2883
https://blog.csdn.net/haoel/article/month/2003/07

## GDB

http://blog.sina.com.cn/s/blog_4fcd1ea30100xhio.html

### GDB的功能

* 启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。
* 可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）
* 当程序被停住时，可以检查此时你的程序中所发生的事。
* 动态的改变你程序的执行环境。

### 编译期

* 编译时，我们必须要把调试信息加到可执行文件中。使用编译器（cc/gcc/g++）的 -g 参数可以做到这一点
* 如果没有-g，将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。

### 常用命名汇总

* 直接回车表示重复上一次命令
* 输入命令时，可以不用打全命令，只用打命令的前几个字符就可以了，当然，命令的前几个字符应该要标志着一个唯一的命令
* 可以敲击两次TAB键来补齐命令的全称，如果有重复的，那么gdb会把其例出来。

|命令|命令缩写|命令说明|
|:---:|:-----:|:-----:|
list|l|显示多行源代码|
break|b|设置断点,程序运行到断点的位置会停下来|
info|i|描述程序的状态|
run|r|开始运行程序|
display|disp|跟踪查看某个变量,每次停下来都显示它的值
step|s|执行下一条语句,如果该语句为函数调用,则进入函数执行其中的第一条语句
next|n|执行下一条语句,如果该语句为函数调用,不会进入函数内部执行(即不会一步步地调试函数内部语句)
print|p|打印内部变量值
continue|c|继续程序的运行,直到遇到下一个断点
set var name=v||设置变量的值
start|st|开始执行程序,在main函数的第一条语句前面停下来
file||装入需要调试的程序|
kill|k|终止正在调试的程序
watch||监视变量值的变化,使用观察点可以使得当某表达式的值发生变化时,程序暂停执行
backtrace|bt|产看函数调用信息(堆栈)
frame|f|查看栈帧
whatis 变量名||查看变量的类型
quit|q|退出GDB环境

### GDB打印数据显示格式

* x (hexadecimal) 按十六进制格式显示变量。 
* d (signed decimal) 按十进制格式显示变量。 
* u (unsigned decimal) 按十进制格式显示无符号整型。 
* o (octal) 按八进制格式显示变量。 
* t (binary) 按二进制格式显示变量。 
* a (address) 按十六进制格式显示地址，并显示距离前继符号的偏移量(offset)。常用于定位未知地址(变量)。 
* c (character) 按字符格式显示变量。 
* f (floating) 按浮点数格式显示变量。
* s (string) 显示为字符串
* i 显示为机器语言（仅在显示内存的x命令中可用）
* 使用时用/跟在命令的后面，例如`p/c buf`,以字符格式打印buf的内容

### 启动和退出

* 载入程序
    * `gdb <program>` program也就是执行文件，一般在当前目录下。
    * `gdb <program> core` 用gdb同时调试一个运行程序和core文件，core是程序非法执行后core dump后产生的文件。
    * 调试服务程序     
        * 在UNIX下用ps查看正在运行的程序的PID（进程ID），然后用`gdb <program> PID`格式挂接正在运行的程序。
        * 先用`gdb <program>`关联上源代码，并进行gdb，在gdb中用attach命令来挂接进程的PID。并用detach来取消挂接的进程。
* 程序运行参数
    * `set args` 可指定运行时参数。（如：set args 10 20 30 40 50）
    * `show args` 命令可以查看设置好的运行参数。
* 运行环境。    
    * `path <dir>` 可设定程序的运行路径。    
    * `show paths` 查看程序的运行路径。    
    * `set environment varname [=value]` 设置环境变量。如：set env USER=hchen
    * `show environment [varname]` 查看环境变量。
* 工作目录。    
    * `cd <dir>` 相当于shell的cd命令。
    * `pwd` 显示当前的所在目录。
* 程序的输入输出。    
    * info terminal 显示你程序用到的终端的模式。    
    * 使用重定向控制程序输出。如：run > outfile    
    * tty命令可以指写输入输出的终端设备。如：tty /dev/ttyb
* 退出
    * quit或q

### 运行UNIX的shell程序

* `shell <command string>`
调用UNIX的shell来执行<command string>，环境变量SHELL中定义的UNIX的shell将会被用来执行<command string>，如果SHELL没有定义，那就使用UNIX的标准shell：/bin/sh。（在Windows中使用Command.com或cmd.exe）
*  `make <make-args>` 
可以在gdb中执行make命令来重新build自己的程序。这个命令等价于“shell make <make-args>”。 

### list l 查看代码

* list命令显示多行源代码,从上次的位置开始显示,默认情况下,一次显示10行,第一次使用时,从代码其实位置显示
* list n显示已第n行为中心的10行代码
* list functionname显示以functionname的函数为中心的10行代码
* list - 显示刚才打印过的源代码之前的代码

### break 断点设置

* `break <function>` 在进入指定函数时停住。C++中可以使用class::function或function(type,type)格式来指定函数名。
* `break <linenum>`  在指定行号停住。
* `break +offset`和`break -offset`   在当前行号的前面或后面的offset行停住。offiset为自然数。
* `break filename:linenum`  在源文件filename的linenum行处停住。
* `break filename:function` 在源文件filename的function函数的入口处停住。
* `break *address` 在程序运行的内存地址处停住。
* `break` break命令没有参数时，表示在下一条指令处停住。
* `break ... if <condition>` ...可以是上述的参数，condition表示条件，在条件成立时停住。

* `info break(points) [n]` 可使用info查看断点相关的信息

* `clear` 清除所有的已定义的停止点。
* `clear <function>``clear <filename:function>`  清除所有设置在函数上的停止点。
* `clear <linenum>``clear <filename:linenum>`   清除所有设置在指定行上的停止点。
* `delete [breakpoints] [range...]`  删除指定的断点，breakpoints为断点号。如果不指定断点号，则表示删除所有的断点。range 表示断点号的范围（如：3-7）。其简写命令为d。
* `disable [breakpoints] [range...]` disable所指定的停止点，breakpoints为停止点号。如果什么都不指定，表示disable所有的停止点。简写命令是dis.
* `enable [breakpoints] [range...]`   enable所指定的停止点，breakpoints为停止点号。
* `enable [breakpoints] [range...]  once`     enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动disable。
* `enable [breakpoints] [range...]  delete`      enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动删除。

* `condition <bnum> <expression>`        修改断点号为bnum的停止条件为expression。
* `condition <bnum>`        清除断点号为bnum的停止条件。
* `ignore <bnum> <count>`        表示忽略断点号为bnum的停止条件count次。

* 为停止点设定运行命令
  * 我们可以使用GDB提供的command命令来设置停止点的运行命令。也就是说，当运行的程序在被停止住时，我们可以让其自动运行一些别的命令，这很有利行自动化调试。对基于GDB的自动化调试是一个强大的支持。
  * 为断点号bnum指写一个命令列表。当程序被该断点停住时，gdb会依次运行命令列表中的命令。

    ```
      commands [bnum]
      ... command-list ...
      end
    ```

    * 例如：
    ```
        break foo if x>0
        commands
        printf "x is %d/n",x
        continue        
        end 
    ```       

    * 断点设置在函数foo中，断点条件是x>0，如果程序被断住后，也就是，一旦x的值在foo函数中大于0，GDB会自动打印出x的值，并继续运行程序。
* 如果你要清除断点上的命令序列，那么只要简单的执行一下commands命令，并直接在打个end就行了。


### watchpoint 观察点设置
* 观察点一般来观察某个表达式（变量也是一种表达式）的值是否有变化了，如果有变化，马上停住程序。
* `watch <expr>`  为表达式（变量）expr设置一个观察点。一量表达式值有变化时，马上停住程序
* `rwatch <expr>` 当表达式（变量）expr被读时，停住程序。
  `awatch <expr>`  当表达式（变量）的值被读或被写时，停住程序。        
* `info watchpoints`  列出当前所设置了的所有观察点。

### CatchPoint 捕捉点设置
* 设置捕捉点来补捉程序运行时的一些事件。如：载入共享库（动态链接库）或是C++的异常。
* 设置捕捉点的格式为：`catch <event>`。当event发生时，停住程序。
* event可以是下面的内容：
    1、throw 一个C++抛出的异常。（throw为关键字） 
    2、catch 一个C++捕捉到的异常。（catch为关键字） 
    3、exec 调用系统调用exec时。（exec为关键字，目前此功能只在HP-UX下有用）  
    4、fork 调用系统调用fork时。（fork为关键字，目前此功能只在HP-UX下有用）        
    5、vfork 调用系统调用vfork时。（vfork为关键字，目前此功能只在HP-UX下有用）        
    6、load 或 load <libname> 载入共享库（动态链接库）时。（load为关键字，目前此功能只在HP-UX下有用）        
    7、unload 或 unload <libname> 卸载共享库（动态链接库）时。（unload为关键字，目前此功能只在HP-UX下有用）
* tcatch <event>         只设置一次捕捉点，当程序停住以后，应点被自动删除。


### 单步调试

* `continue [ignore-count]`, `c [ignore-count]`,`fg [ignore-count]`  
   恢复程序运行，直到程序结束，或是下一个断点到来。ignore-count表示忽略其后的断点次数。continue，c，fg三个命令都是一样的意思。
* `step <count>`  单步跟踪，如果有函数调用，他会进入该函数。后面可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后再停住。
* `next <count>`  单步跟踪，如果有函数调用，他不会进入该函数。后面可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后再停住。
* `finish`        运行程序，直到当前函数完成返回。并打印函数返回时的堆栈地址和返回值及参数值等信息。
* `until 或 u`        当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。
* `stepi 或 si`,`nexti 或 ni`        单步跟踪一条机器指令！一条程序代码有可能由数条机器指令完成，stepi和nexti可以单步执行机器指令。与之一样有相同功能的命令是“display/i $pc” ，当运行完这个命令后，单步跟踪会在打出程序代码的同时打出机器指令（也就是汇编代码）

### print p 显示数据
print / p
查看变量的值
//利用print 命令可以检查各个变量的值。
(gdb) print p (p为变量名)
print 是 gdb 的一个功能很强的命令，利用它可以显示被调试的语言中任何有效的表达式。表达式除了包含你程序中的变量外，还可以包含以下内容：
//对程序中函数的调用
(gdb) print find_entry(1, 0)

//数据结构和其他复杂对象
(gdb) print *table_start
$8={e=reference=’\000’,location=0x0,next=0x0}

//值的历史成分
(gdb)print $1 ($1为历史记录变量,在以后可以直接引用 $1 的值)
whatis 
查看变量的类型
//whatis 命令可以显示某个变量的类型
(gdb) whatis p
type = int *

### 查看指定内存地址内容
`x/  <n/f/u>  <addr>`    
* 其中，n、f、u是可选的参数。addr表示待查看的内存地址。
* n: 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址（units）的内容。
* f: 表示显示的格式（format），默认初始使用十六进制格式。
* u: 表示（the unit size）从当前地址往后请求的位宽大小。如果不指定的话，GDB默认是4个bytes。u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字节，g表示八字节。当我们指定了位宽长度后，GDB会从指内存定的内存地址开始，读写指定位宽大小，并把其当作一个值取出来。


### backtrace bt 查看函数堆栈

* `backtrace` `bt` 打印当前的函数调用栈的所有信息。
* `backtrace <n>` `bt <n>` n是一个正整数，表示只打印栈顶上n层的栈信息。
* `backtrace <-n>` `bt <-n>` -n表一个负整数，表示只打印栈底下n层的栈信息。





### 信号处理
* GDB有能力在你调试程序的时候处理任何一种信号，你可以告诉GDB需要处理哪一种信号。你可以要求GDB收到你所指定的信号时，马上停住正在运行的程序，以供你进行调试。
* `handle <signal> <keywords...>`  在GDB中定义一个信号处理。
* 信号<signal>可以以SIG开头或不以SIG开头，可以用定义一个要处理信号的范围（如：SIGIO-SIGKILL，表示处理从SIGIO信号到SIGKILL的信号，其中包括SIGIO，SIGIOT，SIGKILL三个信号），也可以使用关键字all来标明要处理所有的信号。
* 一旦被调试的程序接收到信号，运行程序马上会被GDB停住，以供调试。
* 其<keywords>可以是以下几种关键字的一个或多个。
    * nostop  当被调试的程序收到信号时，GDB不会停住程序的运行，但会打出消息告诉你收到这种信号。
    * stop  当被调试的程序收到信号时，GDB会停住你的程序。       
    * print 当被调试的程序收到信号时，GDB会显示出一条信息。 
    * noprint 当被调试的程序收到信号时，GDB不会告诉你收到信号的信息。
    * pass, noignore 当被调试的程序收到信号时，GDB不处理信号。这表示，GDB会把这个信号交给被调试程序会处理。
    * nopass, ignore  当被调试的程序收到信号时，GDB不会让被调试程序来处理这个信号。
    * info signals, info handle    查看有哪些信号在被GDB检测中。


### 多线程处理
* 如果你程序是多线程的话，你可以定义你的断点是否在所有的线程上，或是在某个特定的线程。GDB很容易帮你完成这一工作。
* `break <linespec> thread <threadno>`    `break <linespec> thread <threadno> if ...`
* linespec指定了断点设置在的源程序的行号。threadno指定了线程的ID，注意，这个ID是GDB分配的，你可以通过“info threads”命令来查看正在运行程序中的线程信息。
* 如果你不指定thread <threadno>则表示你的断点设在所有线程上面。你还可以为某线程指定断点条件。
* 当你的程序被GDB停住时，所有的运行线程都会被停住。这方便你你查看运行程序的总体情况。而在你恢复程序运行时，所有的线程也会被恢复运行。那怕是主进程在被单步调试时。

----------------------------
## 补充知识

### 文件的编译过程

[gcc](#gcc)
1. **预编译**
主要处理源代码文件中的以“#”开头的预编译指令,生成.i或.ii文件。处理规则见下 
    1. 删除所有的#define，展开所有的宏定义。 
    2. 处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。 
    3. 处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。 
    4. 删除所有的注释，“//”和“/**/”。 
    5. 保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。 
    6. 添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。 
2. **编译**
把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件xxx.s。 
    1. 词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。 
    2. 语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。 
    3. 语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。 
    4. 优化：源代码级别的一个优化过程。 
    5. 目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。 
    6. 目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。 
3. **汇编**
将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows下)、xxx.obj(Linux下)。
4. **链接**
将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序


* **静态链接**   
函数和数据被编译进一个二进制文件。在编译时和静态库链接在一起成为完整的可执行程序。这里所说的静态库就是对多个目标文件（.o）文件的打包，通常静态链接的包名为lib****.a。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。 
    * 空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本； 
    * 更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。 
    * 运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。 

* **动态链接**  
动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。文件名格式为lib + 动态库名 + .so后缀。 
    * 共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本； 
    * 更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。 
    * 性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。 

