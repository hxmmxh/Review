# 目录
* [事务](#事务)
* [锁](#锁)
* [索引](#索引)
* [关系数据库](#关系数据库)
* [SQL](#SQL)


--------------------
# 事务

### 数据库事务
* 事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。
* 事务是DBMS中最基础的单位，事务不可分割。 


### 事务的四个特征 ACID
1. 原子性（Atomicity）   
    事务被视为不可分割的最小单元，事务包含的所有操作要么全部成功，要么全部失败回滚。
2. 一致性（Consistency）   
    一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。  
3. 隔离性（Isolation）   
    多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。 
4. 持久性（Durability）   
    一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。

### 并发一致性问题
在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。
* 丢失修改  
T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。
* 读脏数据  
T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。
* 不可重复读  
T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。
* 幻读  
T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。


### 4种隔离级别
* 未提交读READ UNCOMMITTED  
一个事务在提交之前，对其他事务是可见的，即事务可以读取未提交的数据。存在“脏读”（读到了脏数据）问题；
* 提交读READ COMMITTED  
事务在提交之前，对其它事务是不可见的。存在“不可重复读”（两次查询的得到的结果可能不同，即可能在查询的间隙，有事务提交了修改）问题。解决了“脏读”问题。
* 可重复读REPEATABLE READ  
在同一事务中多次读取的数据是一致的。解决了脏读和不可重复读问题，存在“幻读”（在事务两次查询间隙，有其他事务又插入或删除了新的记录）。MySQL默认隔离级别。
* 可串行化SERIALIZABLE  
强制事务串行化执行。即一个事物一个事物挨个来执行，可以解决上述所有问题。在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争
* 隔离级别高的数据库的可靠性高，但并发量低，而隔离级别低的数据库可靠性低，但并发量高，系统开销小。

---------------------------------------
# 锁

### 锁粒度和策略
* 锁粒度：锁定的数据量越少（粒度越小），并发程度越高，但相应的加锁、检测锁、释放锁用的系统开销也随之增大。
    * 应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。
    * 加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。
    * 在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。
* 锁策略：锁开销与数据安全性之间的平衡
    * 表锁：锁住整张表，读锁互不阻塞，写锁阻塞其他所有读写锁（同一张表）。开销最小。
    * 行级锁：对每一行数据（记录）加锁，开销大，并发程度高。

### 锁类型
* 共享锁（S)(Shared)：又称读锁，允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
* 排他锁（X)(Exclusive)：又称写锁，允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。
* 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。
* 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A加 S 锁，但是不能加 X 锁。
* 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
* 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。


### 封锁协议
* 三级封锁协议
    * 一级封锁协议  
        * 事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。  
        * 可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖  
    * 二级封锁协议
        * 在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。
        * 可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S锁了，也就是不会读入数据。
    * 三级封锁协议
        * 在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。  
        * 可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。  
* 两段加锁协议
    * 扩展阶段：在对任何数据项的读、写之前，要申请并获得该数据项的封锁。
    * 收缩阶段：每个事务中，所有的封锁请求必须先于解锁请求。


----------------------------------------
# 索引

### 索引概念和优缺点
* 概念
    * 索引是对数据库表中一列或多列的值进行排序的一种结构
    * 对数据库表列进行增加恰当索引，可以快速的找到匹配的记录行数，相比于默认的全表扫描，可以大大加快查找的速度。
* 优点
    * 加快查找速度；
    * 创建唯一性索引，保证数据库表中每一行数据的唯一性；
    * 加速表和表之间的连接; 
    * 在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。
* 缺点
    * 索引需要占用数据表以外的物理存储空间；
    * 创建索引和维护索引要花费一定的时间；
    * 当对表进行更新操作时，索引需要被重建，这样降低了数据的维护速度。
    * 索引太多反而拖慢查找时间。有时候数据量不多时，建立索引还不如全表查询。索引加快了检索的速度，但是插入删除修改都需要DBMS动态更新内部索引结构，要耗费开销。
* 添加索引原则 
    * 在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。 
    * 只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。 
    * 定义为text、image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。 
    * 当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。 


### 何时该建立何时不该建立索引
* 哪些情况需要创建索引
    * 主键自动建立唯一索引
    * 频繁作为查询条件的字段应该创建索引
    * 查询中与其他表关联的字段，外键关系建立索引
    * 频繁更新的字段不适合建立索引，因为每次更新不单单是更新了记录还会更新索引
    * WHERE条件里用不到的字段不创建索引
    * 单键/组合索引的选择问题，who?(在高并发下倾向创建组合索引)
    * 查询中排序的字段，排序的字段若通过索引去访问将大大提高排序速度
    * 查询中统计或者分组字段
* 哪些情况不要创建索引
    * 表记录太少
    * 经常增删改的表。提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE、和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据建立索引。
    * 如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。


### 索引分类
* 唯一索引——UNIQUE，例如：create unique index stusno on student（sno）；表明此索引的每一个索引值只对应唯一的数据记录，对于单列惟一性索引，这保证单列不包含重复的值。对于多列惟一性索引，保证多个值的组合不重复。
* 主键索引——primary key，数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。 在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。
* 聚集索引（也叫聚簇索引）——cluster，在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引，如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。

* 聚集索引和非聚集索引的区别
    * 聚集索引表示表中存储的数据按照索引的顺序存储，检索效率比非聚集索引高，但对数据更新影响较大。
    * 非聚集索引表示数据存储在一个地方，索引存储在另一个地方，索引带有指针指向数据的存储位置，非聚集索引检索效率比聚集索引低，但对数据更新影响较小。
    * 聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个。聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续


### 索引实现方法
一般分为B+树索引和哈希索引。
* B+树索引：在B-tree上改进得到，其非叶子节点均为key值，叶子节点是key-data键值对。叶子节点前后相连且有序。
* 哈希索引：通过对key进行hash(crc/MD5/sha1/sha256...)而将记录存储在不同的bucket种，可以做到常数时间的查找，但要注意哈希冲突的避免（链表法、线性探测、二次探测、公共溢出区的方法）。其中MD5 128位，和sha1/256码都较长不太适合作为hash函数。默认无序。
* 为什么有了B+树索引还要hash索引？
    * B+树默认有序，hash默认无序，所以哈希索引无法用于排序；
    * 哈希索引O(1)在速度上毋庸置疑要快于B+树近似O(logn);
    * 哈希索引只能进行等值查询（因为他要计算hash(key)再去匹配）而B+树索引可以进行等值、部分前缀、范围查询；
    * 底层实现结构不同：B+树是非线性结构，hash桶是线性结构。
    * 对于某些场景如热点页/活跃查询页，需要借助哈希索引来实现快速查询。

### B树和B+树
B-Tree 索引是大多数 MySQL 存储引擎的默认索引类型。
* B树
    * 使用原因
        * b树（balance tree）和b+树应用在数据库索引，可以认为是m叉的多路平衡查找树，但是从理论上讲，二叉树查找速度和比较次数都是最小的，为什么不用二叉树呢？ 因为我们要考虑磁盘IO的影响，它相对于内存来说是很慢的。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。所以我们要减少IO次数，对于树来说，IO次数就是树的高度，而“矮胖”就是b树的特征之一，它的每个节点最多包含m个孩子，m称为b树的阶，m的大小取决于磁盘页的大小。
    * 一个M阶的b树具有如下几个特征
        * 定义任意非叶子结点最多只有M个儿子，且M>2；
        * 根结点的儿子数为[2, M]；
        * 除根结点以外的非叶子结点的儿子数为[M/2, M]，向上取整；
        * 非叶子结点的关键字个数=儿子数-1；
        * 所有叶子结点位于同一层；
        * k个关键字把节点拆成k+1段，分别指向k+1个儿子，同时满足查找树的大小关系。非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；
    * 与B+树不同的特性
        * 关键字集合分布在整颗树中；
        * 任何一个关键字出现且只出现在一个结点中；
        * 搜索有可能在非叶子结点结束；
        * 其搜索性能等价于在关键字全集内做一次二分查找；
* B+树
    * m阶的b+树的特征：
        * 有n棵子树的非叶子结点中含有n个关键字（b树是n-1个），这些关键字不保存数据，只用来索引，所有数据都保存在叶子节点（b树是每个关键字都保存数据）。
        * 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
        * 所有的非叶子结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。
        * 通常在b+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。
        * 同一个数字会在不同节点中重复出现，根节点的最大元素就是b+树的最大元素。
    * b+树相比于b树的查询优势：
        * b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”；
        * b+树查询必须查找到叶子节点，b树只要匹配到即可不用管元素位置，因此b+树查找更稳定（并不慢）；
        * 对于范围查找来说，b+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历，如下两图：

---------------------------
# 关系数据库

### 函数依赖
* 记 A->B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。
* 如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。
* 对于 A->B，如果能找到 A 的真子集 A'，使得 A'-> B，那么 A->B 就是部分函数依赖，否则就是完全函数依赖。
* 对于 A->B，B->C，则 A->C 是一个传递函数依赖。

### 异常
* 冗余数据
* 修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。
* 删除异常：删除一个信息，那么也会丢失其它信息。
* 插入异常

### 三大范式
* 第一范式，属性不可分
    * 所有属性都不能再分解为更基本的数据单位
    * 如果实体中的某个属性有多个值时，必须拆分为不同的属性
    * 1NF是关系模式应具备的最起码的条件，如果数据库设计不能满足第一范式，就不称为关系型数据库。也就是说，只要是关系型数据库，就一定满足第一范式。
* 第二范式，每个非主属性完全函数依赖于键码。
    * 数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖，即符合第二范式；
    * 如果一个表中某一个字段A的值是由另外一个字段或一组字段B的值来确定的，就称为A函数依赖于B；
    * 当某张表中的非主键信息不是由整个主键函数来决定时，即存在依赖于该表中不是主键的部分或者依赖于主键一部分的部分时，通常会违反2NF。
* 第三范式，非主属性不传递函数依赖于键码。
    * 数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系
    * 一张表最多只存2层同类型信息 。

---------------------------------------------------

# SQL
GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。
WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。
GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；
除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；
NULL 的行会单独分为一组；






















----------------------------------------------------
SQL与NoSQL的区别
存储方式： SQL数据存在特定结构的表中；而NoSQL则更加灵活和可扩展，存储方式可以省是JSON文档、哈希表或者其他方式。SQL通常以数据库表形式存储数据。
表/数据集合的数据的关系： 在SQL中，必须定义好表和字段结构后才能添加数据，例如定义表的主键(primary key)，索引(index),触发器(trigger),存储过程(stored procedure)等。表结构可以在被定义之后更新，但是如果有比较大的结构变更的话就会变得比较复杂。在NoSQL中，数据可以在任何时候任何地方添加，不需要先定义表。 NoSQL可能更加适合初始化数据还不明确或者未定的项目中。
SQL提供了Join查询，可以将多个关系数据表中的数据用一条查询语句查询出来。NoSQL没有提供。
SQL删数据为了数据完整性，比如外键，不能随便删，而NoSQL是可以随意删除的。
在处理非结构化/半结构化的大数据时；在水平方向上进行扩展时；随时应对动态增加的数据项时可以优先考虑使用NoSQL数据库。
NoSQL缺点：事务支持较弱，join等复杂操作能力较弱，通用性较差



* InnoDB
    * 是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。
    * 实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ 间隙锁（Next-Key Locking）防止幻影读。
    * 主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。  
    * 内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。
    * 支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。
* MyISAM
    * 设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。
    * 提供了大量的特性，包括压缩表、空间数据索引等。
    * 不支持事务。
    * 不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。
* 两种对比
    * 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
    * 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
    * 外键：InnoDB 支持外键。
    * 备份：InnoDB 支持在线热备份。
    * 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
    * 其它特性：MyISAM 支持压缩表和空间数据索引。