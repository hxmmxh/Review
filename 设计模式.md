## 设计原则
1. 单一责任原则
    * 修改一个类的原因应该只有一个。
    * 换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。
    * 如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。
2. 开放封闭原则
    * 类应该对扩展开放，对修改关闭。
    * 扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。
3. 里氏替换原则
    * 子类对象必须能够替换掉所有父类对象。
    * 继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。
    * 如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。
4. 接口分离原则
    * 不应该强迫客户依赖于它们不用的方法。
    * 因此使用多个专门的接口比使用单一的总接口要好。
5. 依赖倒置原则
    * 抽象的模块不应该依赖于具体的模块  
    * 具体应该依赖于抽象     简单来说，解决耦合。一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。    抽象出共同点，然后让实现细节依赖于抽象，客户端也使用抽象：
6. 合成复用原则
    * 合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。

## GOF
* 对接口编程而不是对实现编程。
* 优先使用对象组合而不是继承。
* 总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）

[参考资料](https://www.runoob.com/design-pattern/factory-pattern.html)
## 创建型

### 1.1 工厂模式
* 在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象
* 意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。
* 主要解决：主要解决接口选择的问题。
* 何时使用：我们明确地计划不同条件下创建不同实例时。
* 如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。
* 关键代码：创建过程在其子类执行。
* 应用实例： 您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 
* 优点：
    * 一个调用者想创建一个对象，只要知道其名称就可以了。 
    * 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。
    * 屏蔽产品的具体实现，调用者只关心产品的接口。 
* 缺点
    * 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。
* 注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。

### 1.2 抽象工厂
* 围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。
* 意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
* 主要解决：主要解决接口选择的问题。
* 何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。
* 如何解决：在一个产品族里面，定义多个产品。
* 关键代码：在一个工厂里聚合多个同类产品。
* 应用实例: 有些东西需要搭配在一起使用，比如衣物之类
* 优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。
* 缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。
* 注意事项：产品族难扩展，产品等级易扩展。

### 1.3 单例（Singleton）
* 确保一个类只有一个实例，并提供该实例的全局访问点。
* 使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。
* 私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。
* 实现方法
    * 懒汉式
    * 饿汉式
    * 双重锁
    * pthread_once

### 1.4 建造者模式
* 使用多个简单的对象一步一步构建成一个复杂的对象
* 意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。
* 主要解决：主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。
* 何时使用：一些基本部件不会变，而其组合经常变化的时候。
* 如何解决：将变与不变分离开。
* 关键代码：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。
* 应用实例： 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"。 2、JAVA 中的 StringBuilder。 
* 优点： 1、建造者独立，易扩展。 2、便于控制细节风险。 
* 缺点： 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。 
* 使用场景： 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。 
* 注意事项：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。


### 1.5 原型模式
* 一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。
意图：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
主要解决：在运行期建立和删除原型。
何时使用： 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。
如何解决：利用已有的一个原型对象，快速地生成和原型对象一样的实例。
关键代码： 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些"易变类"拥有稳定的接口。 
应用实例： 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。 
优点： 1、性能提高。 2、逃避构造函数的约束。 
缺点： 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。 
使用场景： 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。 
注意事项：与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。






## 行为型

### 责任链型 
* 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。




















1. 观察者（Observer）
    * 定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。
    * 主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。
    * 实现细节
        * 主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。
        * 观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。
        * 所有观察者必须实现观察者接口，这个接口只有update()一个方法，当主题状态改变时，它被调用
2. 迭代器（Iterator）
    * 提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。

## 结构型

1. 适配器（Adapter）
    * 把一个类接口转换成另一个用户需要的接口。
    * STL中用deque实现queue和stack,用vector实现priority_queue
2. 桥接（Bridge）
    * 将抽象与实现分离开来，使它们可以独立变化。
3. 组合（Composite）
    * 将对象组合成树形结构来表示“整体/部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。
    * 组件（Component）类是组合类（Composite）和叶子类（Leaf）的父类，可以把组合类看成是树的中间节点。
    * 组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。
4. 装饰（Decorator）
    * 为对象动态添加功能。
5. 外观（Facade）
    * 提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。
6. 享元
7. 代理