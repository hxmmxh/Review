## 设计原则
1. 单一责任原则
    * 修改一个类的原因应该只有一个。
    * 换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。
    * 如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。
2. 开放封闭原则
    * 类应该对扩展开放，对修改关闭。
    * 扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。
3. 里氏替换原则
    * 子类对象必须能够替换掉所有父类对象。
    * 继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。
    * 如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。
4. 接口分离原则
    * 不应该强迫客户依赖于它们不用的方法。
    * 因此使用多个专门的接口比使用单一的总接口要好。
5. 依赖倒置原则
    * 抽象的模块不应该依赖于具体的模块  
    * 具体应该依赖于抽象     简单来说，解决耦合。一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。    抽象出共同点，然后让实现细节依赖于抽象，客户端也使用抽象：



## 创建型
1. 单例（Singleton）
    * 确保一个类只有一个实例，并提供该实例的全局访问点。
    * 使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。
    * 私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。
    * 实现方法
        * 懒汉式
        * 饿汉式
        * 双重锁
        * pthread_once




## 行为型


1. 观察者（Observer）
    * 定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。
    * 主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。
    * 实现细节
        * 主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。
        * 观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。
2. 迭代器（Iterator）
    * 提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。

## 结构型

1. 适配器（Adapter）
    * 把一个类接口转换成另一个用户需要的接口。
2. 装饰（Decorator）
    * 为对象动态添加功能。
2. 外观（Facade）
    * 提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。