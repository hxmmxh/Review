可调用对象

-----------------------------------------------------------
- 对于一个对象或一个表达式，如果可以对其使用调用运算符，就是可调用的
- 包含有函数、函数指针、lambda表达式、bind创建的对象、函数对象

# 1. Lambda表达式

- 用于定义并创建匿名的函数对象，以简化编程工作
- 语法：`[capture list] (params list) mutable exception-> return type { function body }`
  - capture list：捕获外部变量列表
  - params list：形参列表
  - mutable指示符：用来说用是否可以修改捕获的变量
  - exception：异常设定
  - return type：返回类型
  - function body：函数体
- 可以省略参数列表和返回类型，但必须永远包含捕获列表和函数体
- [参考资料](https://www.cnblogs.com/DswCnblog/p/5629165.html)  
  
## 捕获外部变量

- 捕获列表只用于局部的非static变量，lambda表达式可以直接使用局部static变量和它所在的函数之外声明的名字
- 值捕获
  - 前提是变量可以被拷贝
  - 被捕获的变量的值在Lambda表达式**创建时**通过值拷贝的方式传入，因此随后对该变量的修改不会影响Lambda表达式中该变量的值。
  - 在Lambda表达式中，如果以传值方式捕获外部变量，则函数体中不能修改该外部变量，否则会引发编译错误
    - 使用**mutable**关键字，说明表达式体内的代码可以修改值捕获的变量
- 引用捕获
  - 使用引用捕获一个外部变量，只需要在捕获列表变量前面加上一个引用说明符&
  - 必须保证被引用的对象在lambda执行的时候是存在的
- 隐式捕获
  - 让编译器根据函数体中的代码来推断需要捕获哪些变量
  - 有两种方式，分别是[=]和[&]。[=]表示以值捕获的方式捕获外部变量，[&]表示以引用捕获的方式捕获外部变量
- 常见捕获列表
  - [] 不捕获任何变量
  - [&] 以引用方式捕获所有变量
  - [=] 用值的方式捕获所有变量（可能被编译器优化为const &)
  - [=, &foo] 以引用捕获foo, 但其余变量都靠值捕获
  - [&, foo] 以值捕获foo, 但其余变量都靠引用捕获
  - [bar] 以值方式捕获bar; 不捕获其它变量
  - [this] 捕获所在类的this指针,只能按值捕获

## 形参列表

- 参数列表中不能有默认参数
- 不支持可变参数
- 所有参数必须有参数名

## 返回类型

- 默认情况下，如果一个lambda体包含return之外的任何语句，则编译器假定此lambda返回void
- 如果不是返回void，就需要显式地指定返回类型

## 用例
```cpp
[] (int x, int y) { return x + y; } // 隐式返回类型
[] (int& x) { ++x;  } // 没有 return 语句 -> Lambda 函数的返回类型是 'void'
[] () { ++global_x;  } // 没有参数，仅访问某个全局变量
[] { ++global_x; } // 与上一个相同，省略了 (操作符重载函数参数)

std::vector<int> some_list;
int total = 0;
for (int i = 0; i < 5; ++i) some_list.push_back(i);
std::for_each(begin(some_list), end(some_list), [&total](int x)
{
    total += x;
});

auto lam =[]() -> int { cout << "Hello, World!"; return 1; };
auto ret = lam();
auto lam2 =[]() -> string { cout << "Hello, World!"; return "test"; };
auto ret1 = lam2();

int a=1,b=2,c=3;
auto lam2  =[&,a](){ cout << a<<b<<c<<endl;};//b，c以引用捕获，a以值捕获。
lam2();
```
# 2. 标准库定义的函数对象

- 标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的模板类
```cpp
#include <functional>
plus<Type>
minus<Type>
multiplies<Type>
divides<Type>
modulus<Type>
negate<Type>

equal_to<Type>
not_equal_to<Type>
greater<Type>
greater_equal<Type>
less<Type>
less_equal<Type>

logical_and<Type>
logical_not<Type>
logical_or<Type>
```
- 可以用来替换算法中的默认运算符（需要传入一个可调用对象）
  - `sort(a.begin(),a.end(),greater<int>())`

# 3. 标准库function

- 调用形式指明了调用返回的类型以及传递给调用的实参类型
  - 例如`int(int,int)`,接受两个int,返回一个int
- 不同的可调用对象可以共享同一种调用形式
- functional头文件中
  - 下列的T表示函数类型
  - `function<T> f`,f是一个用来存储可调用对象的空function
  - `function<T> f(nullptr)`,显示构造一个空的function
  - `funciont<T> f(obj)`,在f中存储可调用对象obj的副本
  - `f`,将f作为条件，f含有一个可调用对象时为真
  - `f(args)`,调用f中的对象，参数是args
  - f中包含以下几个成员
    - result_type，该function类型的可调用对象返回的类型
    - argument_type，参数的类型
    - first_argument_type
    - second_argument_type
- 不能直接将重载函数的名字存入function类型的对象中
  - 可以通过传递函数指针而不是函数的名字解决
```cpp
int add(int i, int j) { return i + j; }
auto mod = [](int i, int j) { return i % j; };
struct divide
{
    int operator()(int i, int j)
    {
        return i / j;
    }
};

function<int(int, int)> f1 = add;
function<int(int, int)> f2 = divide();
function<int(int, int)> f3 = mod;
function<int(int, int)> f4 = [](int i, int j) { return i * j; };
function<int(int, int)> f3 = std::minus<int>();
```

# 4. bind

- 定义在头文件functional中
- 可以看作一个通用的函数适配器，接受一个可调用对象，生成一个新的可调用对象
- `auto newCallable= bind(callable, arg_list)`
  - arg_list是一个逗号分隔的参数列表，对应给callable的参数
  - 调用newCallable时，会调用callable，并传递给它arg_list中的参数
- arg_list中的参数会包括形如_n的名字，其中n是一个整数，这些参数是占位符
  - 数值n表示newCallable中参数的位置
  - 定义在std::placeholders命名空间中
  - 例如：_1为newCallable的第一个参数，`using std::placeholders::_1`
  - 可以利用占位符重排参数顺序
- 默认情况下，那些不是占位符的参数被拷贝到可调用对象中
  - 如果要用引用，不拷贝
  - 需要用ref函数，ref返回一个对象，包含给定的引用，还有cref，返回const引用
  - 也定义在头文件functional中
  - `bind(print, ref(os),_1,' ')`
```cpp
void f(int,int,int,int,int);//f是一个有5个参数的可调用对象
auto g=bind(f,a,b,_2,c,_1);
//生成的g有两个参数
// 第一个参数绑定到_1,传递给f的第五个参数
// 第二个参数绑定到_2,传递给f的第三个参数
// g(X,Y)等于f(a,b,Y,c,X)
```