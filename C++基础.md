# 概述
* [C++关键字](#C++关键字)











------------------------
# C++关键字

### static的作用

* 对于函数定义和代码块之外的变量声明，static修改标识符的链接属性，由默认的external变为internal，作用域和存储类型不改变，这些符号只能在声明它们的源文件中访问。 
* 对于代码块内部的变量声明，static修改标识符的存储类型，由自动变量改为静态变量，作用域和链接属性不变。这种变量在程序执行之前就创建，在程序执行的整个周期都存在。 
* 对于被static修饰的普通函数，其只能在定义它的源文件中使用，不能在其他源文件中被引用 
* 对于被static修饰的类成员变量和成员函数，它们是属于类的，而不是某个对象，所有对象共享一个静态成员。静态成员通过<类名>::<静态成员>来使用。 


1. 全局静态变量  
在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。  
静态存储区，在整个程序运行期间一直存在。  
初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）。  
作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。  
2. 局部静态变量  
在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。  
内存中的位置：静态存储区。  
初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）。  
作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变。  
3. 静态函数  
在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。  
函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突。  
warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰。  
4. 类的静态成员  
在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。  
5. 类的静态函数  
静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。  
在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);  


### malloc和new的区别
1. new分配内存按照数据类型进行分配，malloc分配内存按照指定的大小分配； 
2. new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化。 
3. new不仅分配一段内存，而且会调用构造函数，malloc不会。 
4. new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候会调用对象的析构函数，而free则不会。 
5. new是一个操作符可以重载，malloc是一个库函数。 
6. new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。 
7. 申请数组时： new[]一次分配所有内存，多次调用构造函数，搭配使用delete[]，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int) * n。


### 引用和指针的区别
1. 指针有自己的一块空间，而引用只是一个别名； 
2. 使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小； 
3. 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用； 
4. 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象； 
5. 可以有const指针，但是没有const引用； 
6. 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变； 
7. 指针可以有多级指针（**p），而引用只有一级； 
8. 指针和引用使用++运算符的意义不一样； 
9. 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。 


### volatile关键字
* volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。
* 多线程中被几个任务共享的变量需要定义为volatile类型。


### 四个cast转换关键字 
C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast   
1. const_cast 
用于将const变量转为非const 
2. static_cast 
用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知； 
3. dynamic_cast 
用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。   
向上转换：指的是子类向基类的转换   
向下转换：指的是基类向子类的转换   
它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。   
4. reinterpret_cast 
几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用； 
5. 为什么不使用C的强制转换？ 
C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。 

### 野指针
* 野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针
* 产生原因及解决办法：
    * 指针变量未及时初始化 => 定义指针变量及时初始化，要么置空。
    * 指针free或delete之后没有及时置空 => 释放操作后立即置空。








### 数组和指针的区别
* 二者均可通过增减偏移量来访问数组中的元素。
* 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。
* 当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。









-----------------------------
## 类相关问题

### 面向对象三大特性
* 封装性：数据和代码捆绑在一起，避免外界干扰和不确定性访问。
* 继承性：让某种类型对象获得另一个类型对象的属性和方法。
* 多态性：同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为（重载实现编译时多态，虚函数实现运行时多态）。


### C++空类有哪些成员函数
* 空类大小为1字节。
* 默认函数有：构造函数，析构函数，拷贝构造函数，赋值运算符

### 构造函数和析构函数能否为虚函数
* 析构函数：
    * 析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。
    * 只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。
    * 析构函数可以是纯虚函数，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。
    * C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。
* 构造函数：
    * 构造函数不能定义为虚函数。在构造函数中可以调用虚函数，不过此时调用的是正在构造的类中的虚函数，而不是子类的虚函数，因为此时子类尚未构造好。


### 构造函数和析构函数的调用顺序



### 深拷贝和浅拷贝的区别
* 深拷贝时，当被拷贝对象存在动态分配的存储空间时，需要先动态申请一块存储空间，然后逐字节拷贝内容。
* 浅拷贝仅仅是拷贝指针字面值。
* 当使用浅拷贝时，如果原来的对象调用析构函数释放掉指针所指向的数据，则会产生空悬指针。因为所指向的内存空间已经被释放了。



### 构造函数和析构函数调用时机
* 全局范围中的对象：构造函数在所有函数调用之前执行，在主函数执行完调用析构函数。
* 局部自动对象：建立对象时调用构造函数，离开作用域时调用析构函数。
* 动态分配的对象：建立对象时调用构造函数，调用释放时调用析构函数。
* 静态局部变量对象：建立时调用一次构造函数，主函数结束时调用析构函数。

### 覆盖、重载和隐藏
* 覆盖是派生类中重新定义的函数，其函数名、参数列表（个数、类型和顺序）、返回值类型和父类完全相同，只有函数体有区别。派生类虽然继承了基类的同名函数，但用派生类对象调用该函数时会根据对象类型调用相应的函数。覆盖只能发生在类的成员函数中。
* 隐藏是指派生类函数屏蔽了与其同名的函数，这里仅要求基类和派生类函数同名即可。其他状态同覆盖。可以说隐藏比覆盖涵盖的范围更宽泛，毕竟参数不加限定。
* 重载是具有相同函数名但参数列表不同（个数、类型或顺序）的两个函数（不关心返回值），当调用函数时根据传递的参数列表来确定具体调用哪个函数。重载可以是同一个类的成员函数也可以是类外函数。

### 虚函数和多态 
* 多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。
* 虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。

### 虚函数表

* 多态是由虚函数实现的，而虚函数主要是通过虚函数表（V-Table）来实现的。
* 如果一个类中包含虚函数（virtual修饰的函数），那么这个类就会包含一张虚函数表，虚函数表存储的每一项是一个虚函数的地址。
* 这个类的每一个对象都会包含一个虚指针（虚指针存在于对象实例地址的最前面，保证虚函数表有最高的性能），这个虚指针指向虚函数表。
* 对象不包含虚函数表，只有虚指针，类才包含虚函数表，派生类会生成一个兼容基类的虚函数表。


* 原始基类的虚函数表  
    * 虚指针在地址的最前面，指向基类的虚函数表
* 单继承时的虚函数（无重写基类虚函数）
    * 派生类会自己产生一个兼容基类虚函数表的属于自己的虚函数表。
    * 该函数实体的地址被拷贝到 Derive类的虚函数表，派生类新增的虚函数置于虚函数表的后面，并按声明顺序存放。
* 单继承时的虚函数（重写基类虚函数）
    * 构建自己的虚函数表的时候，修改了基类虚函数的地址，指向自己的虚函数。
* 多重继承时的虚函数
    * 有多个虚函数表，它的对象会有多个虚指针，指向不同的虚函数表。
* 虚继承时的虚函数表
    * 除了每个基类（MyClassA和MyClassB）和公共基类（MyClass）的虚函数表指针需要记录外，每个虚拟继承了MyClass的父类还需要记录一个虚基类表vbtable的指针vbptr。




### 哪几种情况必须用到初始化成员列表
* 初始化一个const成员。
* 初始化一个reference成员。
* 调用一个基类的构造函数，而该函数有一组参数。
* 调用一个数据成员对象的构造函数，而该函数有一组参数。

-------------------------------
# STL

### STL六大组件
















-----------------------
## C++11新特性相关问题

### 智能指针的用法
C++里面的三个智能指针: shared_ptr, weak_ptr, unique_ptr。     
智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。     

1. unique_ptr
    * unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。
    * 当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做

2. shared_ptr 
    * shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放
    * 它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数

3. weak_ptr 
    * weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个shared_ptr管理的对象. 进行该对象的内存管理的是那个强引用的shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。
    * 构造和析构不会引起引用记数的增加或减少
    * 用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放
    * 不能通过weak_ptr直接访问对象的方法，需要先通过调用lock函数来获得shared_ptr

### 可变参数模板



-----------------------
## 底层实现

### 堆和栈的区别
* 申请方式不同。
    * 栈由系统自动分配。
    * 堆由程序员手动分配。
* 申请大小限制不同。
    * 栈顶和栈底是之前预设好的，大小固定，可以通过ulimit -a查看，由ulimit -s修改。
    * 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。
* 申请效率不同。
    * 栈由系统分配，速度快，不会有碎片。
    * 堆由程序员分配，速度慢，且会有碎片。

### C++的内存模型

![内存管理](pic/C++内存模型.png)
* text segment(代码段):包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。 
* data segment(数据段)：存储程序中已初始化的全局变量和静态变量 
* bss segment：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0  
* heap（堆）： 当进程未调用malloc时是没有堆段的，只有调用malloc时采用分配一个堆，并且在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。分配小内存时使用该区域。  堆的起始地址由mm_struct 结构体中的start_brk标识，结束地址由brk标识。 
* memory mapping segment(映射区):存储动态链接库等文件映射、申请大内存（malloc时调用mmap函数） 
* stack（栈）：使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。在创建进程时会有一个最大栈大小，Linux可以通过ulimit命令指定。 


### 段错误
段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况： 
* 使用野指针 
* 试图修改字符串常量的内容 

### 内存泄漏 
内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。申请了一块内存空间，使用完毕后没有释放掉 
* 堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak. 
* 系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。 
* 没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。 

###  valgrind内存泄漏检测
* valgrind是个开源的工具，包含下列工具
    * memcheck:一个重量级的内存检查器，能够发现开发中绝大多数内存错误使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等。
    * callgrind:它主要用来检查程序中函数调用过程中出现的问题。
    * cachegrind:它主要用来检查程序中缓存使用出现的问题。
    * helgrind: 它主要用来检查多线程程序中出现的竞争问题。
    * massif: 它主要用来检查程序中堆栈使用中出现的问题。
    * extension: 可以利用core提供的功能，自己编写特定的内存调试工具
* memcheck

|内容|描述|
|:---:|:---:|
使用未初始化的内存|Use of uninitialised memory
使用已经释放了的内存|Reading/writing memory after it has been free’d
使用超过 malloc分配的内存空间|Reading/writing off the end of malloc’d blocks
对堆栈的非法访问|Reading/writing inappropriate areas on the stack
申请的空间是否有释放|Memory leaks – where pointers to malloc’d blocks are lost forever
malloc/free/new/delete申请和释放内存的匹配|Mismatched use of malloc/new/new [] vs free/delete/delete []
src和dst的重叠|Overlapping src and dst pointers in memcpy() and related functions

* 使用操作
    * gcc 编译时加上-g，保留调试信息
    * valgrind工具使用: `valgrind --tool=tool_name program_name`
    * memcheck工具使用: `valgrind --tool=memcheck --leak-check=full --show-reachable=yes --trace-children=yes`
        * 其中–leak-check=full 指的是完全检查内存泄漏，
        * –show-reachable=yes是显示内存泄漏的地点，
        * –trace-children=yes是跟入子进程。
        * 根据需要添加
    * 当程序正常退出的时候valgrind自然会输出内存泄漏的信息原理
        * Memcheck将内存泄露分为两种，一种是可能的内存泄露（Possibly lost），另外一种是确定的内存泄露（Definitely lost）。
        * Possibly lost 是指仍然存在某个指针能够访问某块内存，但该指针指向的已经不是该内存首地址。
        * Definitely lost 是指已经不能够访问这块内存。而Definitely lost又分为两种：直接的（direct）和间接的（indirect）。直接和间接的区别就是，直接是没有任何指针指向该内存，间接是指指向该内存的指针都位于内存泄露处


### mtrace检测内存泄露
* mtrace是GNU扩展函数，是Linux自带工具，用来跟踪malloc。
* mtrace为内存分配函数（malloc, realloc, memalign, free）安装hook函数。这些hook函数记录内存的申请和释放的trace信息。
* 当调用mtrace，mtrace会检查环境变量MALLOC_TRACE。该环境变量应该包含记录trace信息的文件路径。如果文件可以被成功打开，它的大小被截断为0。* 如果MALLOC_TRACE没有设置，或者设置的文件不可用或者不可写，那么将不会安装hook函数，mtrace不生效。
* 使用操作
    * 在程序的起始处包含头文件 `#include <mcheck.h>`
    * 更改环境变量：`setenv("MALLOC_TRACE", "mtrace.out", 1)` mtrace.out是文件名可修改
    * 调用函数mtrace()
    * 编译程序带上 -g 选项
    * 运行程序一次，尽量调用所有程序内的函数。这时调试信息就已经被写入我们指定的mtrace.out文件中
    * `mtrace a.out  mtrace.out` 查看内存监测情况


### 内存对齐
* 每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍，不是整数倍空出内存，直到偏移量是整数倍为止
* 整个结构体的大小必须是里面变量类型最大值的整数倍
* 结构体变量的首地址能够被其最宽基本类型成员的大小所整除
* 添加了#pragma pack(n)后
    1. 偏移量要是n和当前变量大小中较小值的整数倍
    2. 整体大小要是n和最大变量大小中较小值的整数倍
    3. n值必须为1,2,4,8…，为其他值时就按照默认的分配规则
* 原因
    * 不是所有的硬件平台都能访问任意地址上的任意数据的；
    * 为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。

### 文件的编译过程

1. **预编译**   
主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下 
    1. 删除所有的#define，展开所有的宏定义。 
    2. 处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。 
    3. 处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。 
    4. 删除所有的注释，“//”和“/**/”。 
    5. 保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。 
    6. 添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。 
2. **编译**   
把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。 
    1. 词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。 
    2. 语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。 
    3. 语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。 
    4. 优化：源代码级别的一个优化过程。 
    5. 目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。 
    6. 目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。 
3. **汇编**   
将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows下)、xxx.obj(Linux下)。 
4. **链接**
将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序


* **静态链接**   
函数和数据被编译进一个二进制文件。在编译时和静态库链接在一起成为完整的可执行程序。这里所说的静态库就是对多个目标文件（.o）文件的打包，通常静态链接的包名为lib****.a。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。 
    * 空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本； 
    * 更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。 
    * 运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。 

* **动态链接**  
动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。文件名格式为lib + 动态库名 + .so后缀。 
    * 共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本； 
    * 更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。 
    * 性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。 